/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(12)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(14)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
    var a = (typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' ? factory(require("react"), require("classnames"), require("prop-types")) : factory(root["React"], root["classNames"], root["PropTypes"]);
    for (var i in a) {
      ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' ? exports : root)[i] = a[i];
    }
  }
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_8__) {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 55);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports) {

      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

      /***/
    },
    /* 1 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {
        /**
        * Copyright 2013-2015, Facebook, Inc.
        * All rights reserved.
        *
        * This source code is licensed under the BSD-style license found in the
        * LICENSE file in the root directory of this source tree. An additional grant
        * of patent rights can be found in the PATENTS file in the same directory.
        */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var invariant = function invariant(condition, format, a, b, c, d, e, f) {
          if (process.env.NODE_ENV !== 'production') {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          }

          if (!condition) {
            var error;
            if (format === undefined) {
              error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(format.replace(/%s/g, function () {
                return args[argIndex++];
              }));
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame
            throw error;
          }
        };

        module.exports = invariant;

        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 2 */
    /***/function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(20),
          getPrototype = __webpack_require__(64),
          isObjectLike = __webpack_require__(10);

      /** `Object#toString` result references. */
      var objectTag = '[object Object]';

      /** Used for built-in method references. */
      var funcProto = Function.prototype,
          objectProto = Object.prototype;

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Used to infer the `Object` constructor. */
      var objectCtorString = funcToString.call(Object);

      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }

      module.exports = isPlainObject;

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _Time = __webpack_require__(19);

      var _Time2 = _interopRequireDefault(_Time);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * 一度生成したオブジェクトは変更しません。
       * 変更メソッドは新しいオブジェクトを帰します。
       */
      var TimeSpan = function () {
        _createClass(TimeSpan, null, [{
          key: 'create',
          value: function create(start, end) {
            return new TimeSpan(new _Time2.default(start[0], start[1]), new _Time2.default(end[0], end[1]));
          }
        }]);

        function TimeSpan(startTime, endTime) {
          _classCallCheck(this, TimeSpan);

          if (startTime === undefined) {
            startTime = new _Time2.default();
          }
          if (endTime === undefined) {
            endTime = new _Time2.default();
          }
          while (startTime.compare(endTime) >= 0) {
            endTime = endTime.addMin(24 * 60);
          }

          this._startTime = startTime;
          this._endTime = endTime;
        }

        _createClass(TimeSpan, [{
          key: 'clone',
          value: function clone() {
            return new TimeSpan(this.getStartTime().clone(), this.getEndTime().clone());
          }
        }, {
          key: 'getDistance',
          value: function getDistance() {
            return this._startTime.getDistance(this._endTime);
          }
        }, {
          key: 'getStartTime',
          value: function getStartTime() {
            return this._startTime;
          }
        }, {
          key: 'getEndTime',
          value: function getEndTime() {
            return this._endTime;
          }
        }, {
          key: 'shiftEndTime',
          value: function shiftEndTime(time) {
            return new TimeSpan(time.addMin(-this.getDistance()), time);
          }
        }, {
          key: 'shiftStartHour',
          value: function shiftStartHour(hour) {
            return this.shiftStartTime(new _Time2.default(hour, this._startTime.getMin()));
          }
        }, {
          key: 'shiftStartMin',
          value: function shiftStartMin(min) {
            return this.shiftStartTime(new _Time2.default(this._startTime.getHour(), min));
          }
        }, {
          key: 'shiftStartTime',
          value: function shiftStartTime(time) {
            return new TimeSpan(time, time.addMin(this.getDistance()));
          }
        }, {
          key: 'addMin',
          value: function addMin(minute) {
            return new TimeSpan(this.getStartTime(), this.getEndTime().addMin(minute));
          }
        }, {
          key: 'equals',
          value: function equals(timeSpan) {
            return this.getStartTime().equals(timeSpan.getStartTime()) && this.getEndTime().equals(timeSpan.getEndTime());
          }
        }, {
          key: 'contains',
          value: function contains(timeSpan) {
            return this.getStartTime().compare(timeSpan.getStartTime()) < 0 && this.getEndTime().compare(timeSpan.getEndTime()) > 0;
          }
        }, {
          key: 'containsTime',
          value: function containsTime(time) {
            return this.getStartTime().compare(time) < 0 && this.getEndTime().compare(time) > 0;
          }
        }, {
          key: 'overlaps',
          value: function overlaps(timeSpan) {
            if (timeSpan.contains(this)) {
              return true;
            }

            if (this.containsTime(timeSpan.getStartTime())) {
              return true;
            }

            if (this.containsTime(timeSpan.getEndTime())) {
              return true;
            }

            return false;
          }
        }, {
          key: 'eachHour',
          value: function eachHour(callback) {
            var hour = this.getStartTime().getHour();
            var end = this.getEndTime().getHour();
            var key = 0;

            while (true) {
              if (hour === end) {
                callback.call(hour, key, hour, this.getEndTime().getMin());
                break;
              } else {
                callback.call(hour, key, hour);
              }

              hour += 1;
              ++key;
            }
          }
        }, {
          key: 'eachTime',
          value: function eachTime(callback, minuteInterval) {
            var key = 0;
            minuteInterval = minuteInterval ? minuteInterval : 60;

            var time = this.getStartTime();
            while (true) {
              if (time.compare(this.getEndTime()) > 0) {
                break;
              }

              callback.call(time, key, time);

              time = time.addMin(minuteInterval);
              ++key;
            }
          }
        }, {
          key: 'toString',
          value: function toString() {
            return this._startTime + '~' + this._endTime;
          }
        }]);

        return TimeSpan;
      }();

      exports.default = TimeSpan;

      /***/
    },
    /* 4 */
    /***/function (module, exports) {

      module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

      /***/
    },
    /* 5 */
    /***/function (module, exports) {

      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };

      /***/
    },
    /* 6 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */
      var isArray = Array.isArray;

      module.exports = isArray;

      /***/
    },
    /* 7 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var Ruler = function (_React$Component) {
        _inherits(Ruler, _React$Component);

        function Ruler(props) {
          _classCallCheck(this, Ruler);

          var _this = _possibleConstructorReturn(this, (Ruler.__proto__ || Object.getPrototypeOf(Ruler)).call(this, props));

          _this.state = {
            hours: []
          };
          _this.props.timeSpan.eachTime(function (key, time) {
            if (!time.equals(_this.props.timeSpan.getEndTime())) {
              var style = {
                //border1pxを足す
                height: (_this.props.minHeight + 1) * 4
              };
              _this.state.hours.push(_react2.default.createElement('div', { key: time.getHour(), style: style }, time.getDisplayHour()));
            }
          });
          return _this;
        }

        _createClass(Ruler, [{
          key: 'render',
          value: function render() {
            return _react2.default.createElement('div', { className: 'tlRulerView', style: { width: Ruler.width + 'px' } }, this.state.hours);
          }
        }]);

        return Ruler;
      }(_react2.default.Component);

      // Ruler.propTypes = {
      //   minHeight: React.PropTypes.number.isRequired,
      //   timeSpan: React.PropTypes.instanceOf(TimeSpan).isRequired
      // }

      exports.default = Ruler;
      Ruler.width = 30;

      /***/
    },
    /* 8 */
    /***/function (module, exports) {

      module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

      /***/
    },
    /* 9 */
    /***/function (module, exports, __webpack_require__) {

      var freeGlobal = __webpack_require__(61);

      /** Detect free variable `self`. */
      var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      module.exports = root;

      /***/
    },
    /* 10 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';
      }

      module.exports = isObjectLike;

      /***/
    },
    /* 11 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.END_DRAG = exports.DROP = exports.HOVER = exports.PUBLISH_DRAG_SOURCE = exports.BEGIN_DRAG = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      exports.beginDrag = beginDrag;
      exports.publishDragSource = publishDragSource;
      exports.hover = hover;
      exports.drop = drop;
      exports.endDrag = endDrag;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _isArray = __webpack_require__(6);

      var _isArray2 = _interopRequireDefault(_isArray);

      var _isObject = __webpack_require__(23);

      var _isObject2 = _interopRequireDefault(_isObject);

      var _matchesType = __webpack_require__(39);

      var _matchesType2 = _interopRequireDefault(_matchesType);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var BEGIN_DRAG = exports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';
      var PUBLISH_DRAG_SOURCE = exports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';
      var HOVER = exports.HOVER = 'dnd-core/HOVER';
      var DROP = exports.DROP = 'dnd-core/DROP';
      var END_DRAG = exports.END_DRAG = 'dnd-core/END_DRAG';

      function beginDrag(sourceIds) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { publishSource: true, clientOffset: null };
        var publishSource = options.publishSource,
            clientOffset = options.clientOffset,
            getSourceClientOffset = options.getSourceClientOffset;

        (0, _invariant2.default)((0, _isArray2.default)(sourceIds), 'Expected sourceIds to be an array.');

        var monitor = this.getMonitor();
        var registry = this.getRegistry();
        (0, _invariant2.default)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');

        for (var i = 0; i < sourceIds.length; i++) {
          (0, _invariant2.default)(registry.getSource(sourceIds[i]), 'Expected sourceIds to be registered.');
        }

        var sourceId = null;
        for (var _i = sourceIds.length - 1; _i >= 0; _i--) {
          if (monitor.canDragSource(sourceIds[_i])) {
            sourceId = sourceIds[_i];
            break;
          }
        }
        if (sourceId === null) {
          return;
        }

        var sourceClientOffset = null;
        if (clientOffset) {
          (0, _invariant2.default)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
          sourceClientOffset = getSourceClientOffset(sourceId);
        }

        var source = registry.getSource(sourceId);
        var item = source.beginDrag(monitor, sourceId);
        (0, _invariant2.default)((0, _isObject2.default)(item), 'Item must be an object.');

        registry.pinSource(sourceId);

        var itemType = registry.getSourceType(sourceId);
        return {
          type: BEGIN_DRAG,
          itemType: itemType,
          item: item,
          sourceId: sourceId,
          clientOffset: clientOffset,
          sourceClientOffset: sourceClientOffset,
          isSourcePublic: publishSource
        };
      }

      function publishDragSource() {
        var monitor = this.getMonitor();
        if (!monitor.isDragging()) {
          return;
        }

        return { type: PUBLISH_DRAG_SOURCE };
      }

      function hover(targetIdsArg) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$clientOffset = _ref.clientOffset,
            clientOffset = _ref$clientOffset === undefined ? null : _ref$clientOffset;

        (0, _invariant2.default)((0, _isArray2.default)(targetIdsArg), 'Expected targetIds to be an array.');
        var targetIds = targetIdsArg.slice(0);

        var monitor = this.getMonitor();
        var registry = this.getRegistry();
        (0, _invariant2.default)(monitor.isDragging(), 'Cannot call hover while not dragging.');
        (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call hover after drop.');

        // First check invariants.
        for (var i = 0; i < targetIds.length; i++) {
          var targetId = targetIds[i];
          (0, _invariant2.default)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');

          var target = registry.getTarget(targetId);
          (0, _invariant2.default)(target, 'Expected targetIds to be registered.');
        }

        var draggedItemType = monitor.getItemType();

        // Remove those targetIds that don't match the targetType.  This
        // fixes shallow isOver which would only be non-shallow because of
        // non-matching targets.
        for (var _i2 = targetIds.length - 1; _i2 >= 0; _i2--) {
          var _targetId = targetIds[_i2];
          var targetType = registry.getTargetType(_targetId);
          if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
            targetIds.splice(_i2, 1);
          }
        }

        // Finally call hover on all matching targets.
        for (var _i3 = 0; _i3 < targetIds.length; _i3++) {
          var _targetId2 = targetIds[_i3];
          var _target = registry.getTarget(_targetId2);
          _target.hover(monitor, _targetId2);
        }

        return {
          type: HOVER,
          targetIds: targetIds,
          clientOffset: clientOffset
        };
      }

      function drop() {
        var _this = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var monitor = this.getMonitor();
        var registry = this.getRegistry();
        (0, _invariant2.default)(monitor.isDragging(), 'Cannot call drop while not dragging.');
        (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');

        var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);

        targetIds.reverse();
        targetIds.forEach(function (targetId, index) {
          var target = registry.getTarget(targetId);

          var dropResult = target.drop(monitor, targetId);
          (0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isObject2.default)(dropResult), 'Drop result must either be an object or undefined.');
          if (typeof dropResult === 'undefined') {
            dropResult = index === 0 ? {} : monitor.getDropResult();
          }

          _this.store.dispatch({
            type: DROP,
            dropResult: _extends({}, options, dropResult)
          });
        });
      }

      function endDrag() {
        var monitor = this.getMonitor();
        var registry = this.getRegistry();
        (0, _invariant2.default)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');

        var sourceId = monitor.getSourceId();
        var source = registry.getSource(sourceId, true);
        source.endDrag(monitor, sourceId);

        registry.unpinSource();

        return { type: END_DRAG };
      }

      /***/
    },
    /* 12 */
    /***/function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(13);

      /* Built-in method references that are verified to be native. */
      var nativeCreate = getNative(Object, 'create');

      module.exports = nativeCreate;

      /***/
    },
    /* 13 */
    /***/function (module, exports, __webpack_require__) {

      var baseIsNative = __webpack_require__(77),
          getValue = __webpack_require__(81);

      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }

      module.exports = getNative;

      /***/
    },
    /* 14 */
    /***/function (module, exports, __webpack_require__) {

      var eq = __webpack_require__(89);

      /**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }

      module.exports = assocIndexOf;

      /***/
    },
    /* 15 */
    /***/function (module, exports, __webpack_require__) {

      var isKeyable = __webpack_require__(95);

      /**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
      }

      module.exports = getMapData;

      /***/
    },
    /* 16 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addSource = addSource;
      exports.addTarget = addTarget;
      exports.removeSource = removeSource;
      exports.removeTarget = removeTarget;
      var ADD_SOURCE = exports.ADD_SOURCE = 'dnd-core/ADD_SOURCE';
      var ADD_TARGET = exports.ADD_TARGET = 'dnd-core/ADD_TARGET';
      var REMOVE_SOURCE = exports.REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';
      var REMOVE_TARGET = exports.REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';

      function addSource(sourceId) {
        return {
          type: ADD_SOURCE,
          sourceId: sourceId
        };
      }

      function addTarget(targetId) {
        return {
          type: ADD_TARGET,
          targetId: targetId
        };
      }

      function removeSource(sourceId) {
        return {
          type: REMOVE_SOURCE,
          sourceId: sourceId
        };
      }

      function removeTarget(targetId) {
        return {
          type: REMOVE_TARGET,
          targetId: targetId
        };
      }

      /***/
    },
    /* 17 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = checkDecoratorArguments;
        function checkDecoratorArguments(functionName, signature) {
          if (process.env.NODE_ENV !== 'production') {
            for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i += 1) {
              var arg = arguments.length <= i + 2 ? undefined : arguments[i + 2];
              if (arg && arg.prototype && arg.prototype.render) {
                console.error( // eslint-disable-line no-console
                'You seem to be applying the arguments in the wrong order. ' + ('It should be ' + functionName + '(' + signature + ')(Component), not the other way around. ') + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#you-seem-to-be-applying-the-arguments-in-the-wrong-order');
                return;
              }
            }
          }
        }
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 18 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      var _Frame = __webpack_require__(56);

      var _Frame2 = _interopRequireDefault(_Frame);

      var _Ruler = __webpack_require__(7);

      var _Ruler2 = _interopRequireDefault(_Ruler);

      var _Line = __webpack_require__(34);

      var _Line2 = _interopRequireDefault(_Line);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var Timeline = function (_React$Component) {
        _inherits(Timeline, _React$Component);

        function Timeline(props) {
          _classCallCheck(this, Timeline);

          var _this = _possibleConstructorReturn(this, (Timeline.__proto__ || Object.getPrototypeOf(Timeline)).call(this, props));

          _this.timeSpan = _this.props.timeSpan;

          //minViewがいくつあるかカウント。minViewは15分おき。それを元に高さを計算。border分1px足す
          _this.lineHeight = _this.timeSpan.getDistance() / 15 * (_this.props.minHeight + 1);

          //1分あたりの高さを算出
          _this.perMinHeight = _this.lineHeight / _this.timeSpan.getDistance();

          _this.lineWidth = props.lineWidth;

          _this.createdEventId = 0;
          _this.draggingOverLineComponent = null;

          _this.frameComponent = undefined;
          _this.eventComponents = [];
          return _this;
        }

        _createClass(Timeline, [{
          key: 'draggingOver',
          value: function draggingOver(left) {

            var lineComponent = this.findLineByLeft(left);
            if (lineComponent) {
              if (this.draggingOverLineComponent !== lineComponent) {
                if (this.draggingOverLineComponent) {
                  this.draggingOverLineComponent.clearDraggingOver();
                }
                this.draggingOverLineComponent = lineComponent;
                this.draggingOverLineComponent.draggingOver();
              }
            } else {
              if (this.draggingOverLineComponent) {
                this.draggingOverLineComponent.clearDraggingOver();
                this.draggingOverLineComponent = null;
              }
            }

            return lineComponent;
          }
        }, {
          key: 'clearDraggingOver',
          value: function clearDraggingOver() {
            if (this.draggingOverLineComponent) {
              this.draggingOverLineComponent.clearDraggingOver();
            }
          }
        }, {
          key: 'getTotalWidth',
          value: function getTotalWidth() {
            var _this2 = this;

            if (this.totalWidthCache === undefined) {
              this.totalWidthCache = this.props.lineData.reduce(function (val, data, index) {
                var hasRuler = index % _this2.props.rulerInterval === 0;
                return val + (hasRuler ? _this2.lineWidth + _Ruler2.default.width : _this2.lineWidth);
              }, 0);
            }

            return this.totalWidthCache;
          }
        }, {
          key: 'findEventById',
          value: function findEventById(eventId) {
            return this.eventComponents.find(function (ev) {
              return ev.props.id == eventId;
            });
          }
        }, {
          key: 'findLineByLeft',
          value: function findLineByLeft(left) {
            var _this3 = this;

            var width = 0;
            return this.lineComponents.find(function (line) {
              width += line.props.hasRuler ? _this3.props.lineWidth + _Ruler2.default.width : _this3.props.lineWidth;
              if (left < width) {
                return line;
              }
            });
          }
        }, {
          key: 'getLineLeft',
          value: function getLineLeft(lineId) {
            var left = 0;
            for (var i = 0; i < this.props.lineData.length; i++) {
              var lineData = this.props.lineData[i];
              var hasRuler = i % this.props.rulerInterval === 0;
              if (hasRuler) {
                left += _Ruler2.default.width;
              }

              if (lineData.id == lineId) {
                break;
              }

              left += this.props.lineWidth;
            }

            left += _Line2.default.sidePadding;

            return left;
          }
        }, {
          key: 'getTimeSpan',
          value: function getTimeSpan(top, height) {
            var startTime = this.topToTime(top);

            var endTime = startTime.addMin(height / this.perMinHeight);
            return new _TimeSpan2.default(startTime, endTime);
          }
        }, {
          key: 'minuteToHeight',
          value: function minuteToHeight(minute) {
            return minute * this.perMinHeight - 1;
          }
        }, {
          key: 'timeSpanToHeight',
          value: function timeSpanToHeight(timeSpan) {
            return this.minuteToHeight(timeSpan.getDistance());
          }
        }, {
          key: 'timeToTop',
          value: function timeToTop(time) {
            return this.timeSpan.getStartTime().getDistance(time) * this.perMinHeight - 1;
          }
        }, {
          key: 'topToTime',
          value: function topToTime(top) {
            if (top <= 0) {
              return this.timeSpan.getStartTime();
            }
            var minute = top / this.perMinHeight;
            var rest = minute % this.props.minInterval;
            if (rest !== 0) {
              if (rest > this.props.minInterval / 2) {
                minute += this.props.minInterval - rest;
              } else {
                minute -= rest;
              }
            }
            return this.timeSpan.getStartTime().addMin(minute);
          }
        }, {
          key: 'findPrevEvent',
          value: function findPrevEvent(eventComponent) {
            return this.eventComponents.filter(function (ev) {
              return !ev.state.draggable && ev.lineId == eventComponent.lineId;
            }) //同じ列のものだけに絞る
            .sort(function (a, b) {
              return -a.currentTimeSpan.getStartTime().compare(b.currentTimeSpan.getStartTime());
            }) //時間の降順で並び替え
            .find(function (ev) {
              return ev.currentTimeSpan.getEndTime().compare(eventComponent.currentTimeSpan.getStartTime()) <= 0;
            }) //降順なので対象より最初に開始時間が若いものがprev
            ;
          }
        }, {
          key: 'getPrevBottom',
          value: function getPrevBottom(eventComponent) {
            var prevEvent = this.findPrevEvent(eventComponent);
            var bottomTime = void 0;
            if (prevEvent) {
              bottomTime = prevEvent.currentTimeSpan.getEndTime();
            } else {
              bottomTime = this.timeSpan.getStartTime();
            }

            return this.timeToTop(bottomTime);
          }
        }, {
          key: 'findNextEvent',
          value: function findNextEvent(eventComponent) {
            return this.findNextEventByTime(eventComponent.lineId, eventComponent.currentTimeSpan.getEndTime());
          }
        }, {
          key: 'findNextEventByTime',
          value: function findNextEventByTime(lineId, time) {
            return this.eventComponents.filter(function (ev) {
              return !ev.state.draggable && ev.lineId == lineId;
            }) //同じ列のものだけに絞る
            .sort(function (a, b) {
              return a.currentTimeSpan.getStartTime().compare(b.currentTimeSpan.getStartTime());
            }) //時間の昇順で並び替え
            .find(function (ev) {
              return ev.currentTimeSpan.getStartTime().compare(time) >= 0;
            }) //昇順なので対象より最初に開始時間が遅いものがnext
            ;
          }
        }, {
          key: 'getEventsOnLine',
          value: function getEventsOnLine(lineId) {
            return this.eventComponents.filter(function (ev) {
              return !ev.state.draggable && ev.lineId == lineId;
            });
          }
        }, {
          key: 'getNextTime',
          value: function getNextTime(lineId, time) {
            var nextEvent = this.findNextEventByTime(lineId, time);
            var nextTime = void 0;
            if (nextEvent) {
              nextTime = nextEvent.currentTimeSpan.getStartTime();
            } else {
              nextTime = this.timeSpan.getEndTime();
            }

            return nextTime;
          }
        }, {
          key: 'getFreeMinute',
          value: function getFreeMinute(lineId, time) {
            var nextTime = this.getNextTime(lineId, time);
            return time.getDistance(nextTime);
          }
        }, {
          key: 'getNextTop',
          value: function getNextTop(eventComponent) {
            return this.timeToTop(this.getNextTime(eventComponent.lineId, eventComponent.currentTimeSpan.getEndTime()));
          }
        }, {
          key: 'addEvents',
          value: function addEvents(events) {
            return this.frameComponent.addEvents(events);
          }
        }, {
          key: 'setHeight',
          value: function setHeight(height) {
            this.frameComponent.setHeight(height);
          }
        }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
            if (nextProps.lineData !== this.props.lineData) {
              this.totalWidthCache = undefined;
            }
          }
        }, {
          key: 'render',
          value: function render() {
            return _react2.default.createElement(_Frame2.default, {
              ref: 'frame',
              lineData: this.props.lineData,
              timeSpan: this.props.timeSpan,
              lineWidth: this.props.lineWidth,
              minHeight: this.props.minHeight,
              height: this.props.height,
              width: this.props.width,
              lineHeight: this.lineHeight,
              timeline: this,
              rulerInterval: this.props.rulerInterval,
              events: this.props.events,
              children: this.props.children,
              childWidth: this.props.childWidth
            });
          }
        }, {
          key: 'lineComponents',
          get: function get() {
            var _this4 = this;

            // refsはオブジェクトなので順番の保証がないためDOMからとります。
            var lines = this.frameComponent.refs.linesWrapper.querySelectorAll('.tlLineWrapper');
            return Array.prototype.slice.call(lines).map(function (elem) {
              var id = elem.getAttribute('data-id');
              return _this4.frameComponent.refs['line@' + id];
            });
          }
        }, {
          key: 'lastLine',
          get: function get() {
            var lines = this.lineComponents;
            return lines[lines.length - 1];
          }
        }]);

        return Timeline;
      }(_react2.default.Component);

      // Timeline.propTypes = {
      //   timeSpan: React.PropTypes.instanceOf(TimeSpan).isRequired,
      //   lineData: React.PropTypes.arrayOf(React.PropTypes.shape({
      //     id: React.PropTypes.string.isRequired,
      //     label: React.PropTypes.string.isRequired
      //   })).isRequired,
      //   lineWidth: React.PropTypes.number.isRequired,
      //   minHeight: React.PropTypes.number.isRequired,
      //   onClick: React.PropTypes.func,
      //   rulerInterval: React.PropTypes.number.isRequired,
      //   minInterval: React.PropTypes.number,
      //   height: React.PropTypes.number.isRequired
      // }

      exports.default = Timeline;
      Timeline.defaultProps = {
        minInterval: 1,
        childWidth: 0
      };

      /***/
    },
    /* 19 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * 一度生成したオブジェクトは変更しません。
       * 変更メソッドは新しいオブジェクトを帰します。
       */
      var Time = function () {
        _createClass(Time, null, [{
          key: 'eachMin',
          value: function eachMin(callback, minuteInterval) {
            var count = 60 / minuteInterval;
            for (var i = 0; i < count; i++) {
              var min = i * minuteInterval;
              if (min < 60) {
                var displayMin = min < 10 ? '0' + min : min + '';
                callback.call(min, i, min, displayMin);
              }
            };
          }
        }, {
          key: 'create',

          /**
           * 配列からTimeを生成
           * @param  {array} time [hour, min]の配列
           * @return {Time}
           */
          value: function create(time) {
            return new Time(time[0], time[1]);
          }
        }]);

        function Time(hour, min) {
          _classCallCheck(this, Time);

          this._hour = hour === undefined ? 0 : parseInt(hour, 10);
          this._min = min === undefined ? 0 : parseInt(min, 10);
          while (this._min < 0) {
            --this._hour;
            this._min = 60 + this._min;
          }

          while (this._min > 59) {
            ++this._hour;
            this._min = this._min - 60;
          }

          if (this._hour < 0) {
            throw new Error(this.toString() + ' is not valid time.');
          }
        }

        _createClass(Time, [{
          key: 'getHour',
          value: function getHour() {
            return this._hour;
          }
        }, {
          key: 'getMin',
          value: function getMin() {
            return this._min;
          }
        }, {
          key: 'clone',
          value: function clone() {
            return new Time(this.getHour(), this.getMin());
          }
        }, {
          key: 'addMin',
          value: function addMin(min) {
            return new Time(this.getHour(), this.getMin() + parseInt(min, 10));
          }
        }, {
          key: 'equals',
          value: function equals(time) {
            return this.getHour() === time.getHour() && this.getMin() === time.getMin();
          }
        }, {
          key: 'compare',
          value: function compare(time) {
            if (this.getHour() > time.getHour()) {
              return 1;
            } else if (this.getHour() < time.getHour()) {
              return -1;
            } else {
              if (this.getMin() > time.getMin()) {
                return 1;
              } else if (this.getMin() < time.getMin()) {
                return -1;
              }
            }

            return 0;
          }
        }, {
          key: 'getDistance',
          value: function getDistance(targetTime) {
            var targetHour = targetTime.getHour();
            var hourDistance = targetHour - this._hour;
            return hourDistance * 60 + (targetTime.getMin() - this._min);
          }
        }, {
          key: 'toString',
          value: function toString() {
            return this.getDisplayTime();
          }
        }, {
          key: 'getDisplayHour',
          value: function getDisplayHour() {
            return this._hour < 24 ? this._hour : this._hour - 24;
          }
        }, {
          key: 'getDisplayMin',
          value: function getDisplayMin() {
            return this._min < 10 ? '0' + this._min : this._min;
          }
        }, {
          key: 'getDisplayTime',
          value: function getDisplayTime() {
            return this.getDisplayHour() + ':' + this.getDisplayMin();
          }
        }]);

        return Time;
      }();

      exports.default = Time;

      /***/
    },
    /* 20 */
    /***/function (module, exports, __webpack_require__) {

      var _Symbol2 = __webpack_require__(21),
          getRawTag = __webpack_require__(62),
          objectToString = __webpack_require__(63);

      /** `Object#toString` result references. */
      var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';

      /** Built-in value references. */
      var symToStringTag = _Symbol2 ? _Symbol2.toStringTag : undefined;

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }

      module.exports = baseGetTag;

      /***/
    },
    /* 21 */
    /***/function (module, exports, __webpack_require__) {

      var root = __webpack_require__(9);

      /** Built-in value references. */
      var _Symbol3 = root.Symbol;

      module.exports = _Symbol3;

      /***/
    },
    /* 22 */
    /***/function (module, exports) {

      var g;

      // This works in non-strict mode
      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        // This works if the window reference is available
        if ((typeof window === 'undefined' ? 'undefined' : _typeof2(window)) === "object") g = window;
      }

      // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}

      module.exports = g;

      /***/
    },
    /* 23 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
        return value != null && (type == 'object' || type == 'function');
      }

      module.exports = isObject;

      /***/
    },
    /* 24 */
    /***/function (module, exports, __webpack_require__) {

      var MapCache = __webpack_require__(73),
          setCacheAdd = __webpack_require__(99),
          setCacheHas = __webpack_require__(100);

      /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */
      function SetCache(values) {
        var index = -1,
            length = values == null ? 0 : values.length;

        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }

      // Add methods to `SetCache`.
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;

      module.exports = SetCache;

      /***/
    },
    /* 25 */
    /***/function (module, exports, __webpack_require__) {

      var baseIndexOf = __webpack_require__(101);

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      module.exports = arrayIncludes;

      /***/
    },
    /* 26 */
    /***/function (module, exports) {

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      module.exports = arrayIncludesWith;

      /***/
    },
    /* 27 */
    /***/function (module, exports) {

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      module.exports = arrayMap;

      /***/
    },
    /* 28 */
    /***/function (module, exports) {

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      module.exports = cacheHas;

      /***/
    },
    /* 29 */
    /***/function (module, exports, __webpack_require__) {

      var identity = __webpack_require__(43),
          overRest = __webpack_require__(105),
          setToString = __webpack_require__(107);

      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '');
      }

      module.exports = baseRest;

      /***/
    },
    /* 30 */
    /***/function (module, exports, __webpack_require__) {

      var isArrayLike = __webpack_require__(112),
          isObjectLike = __webpack_require__(10);

      /**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }

      module.exports = isArrayLikeObject;

      /***/
    },
    /* 31 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /**
       * Copyright 2015, Yahoo! Inc.
       * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
       */

      var REACT_STATICS = {
        childContextTypes: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };

      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        arguments: true,
        arity: true
      };

      var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

      module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
        if (typeof sourceComponent !== 'string') {
          // don't hoist over string (html) components
          var keys = Object.getOwnPropertyNames(sourceComponent);

          /* istanbul ignore else */
          if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
          }

          for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
              try {
                targetComponent[keys[i]] = sourceComponent[keys[i]];
              } catch (error) {}
            }
          }
        }

        return targetComponent;
      };

      /***/
    },
    /* 32 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = shallowEqual;
      function shallowEqual(objA, objB) {
        if (objA === objB) {
          return true;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        // Test for A's keys different from B.
        var hasOwn = Object.prototype.hasOwnProperty;
        for (var i = 0; i < keysA.length; i += 1) {
          if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
            return false;
          }

          var valA = objA[keysA[i]];
          var valB = objB[keysA[i]];

          if (valA !== valB) {
            return false;
          }
        }

        return true;
      }

      /***/
    },
    /* 33 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      exports.__esModule = true;
      exports['default'] = isDisposable;

      function isDisposable(obj) {
        return Boolean(obj && typeof obj.dispose === 'function');
      }

      module.exports = exports['default'];

      /***/
    },
    /* 34 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      var _Hour = __webpack_require__(57);

      var _Hour2 = _interopRequireDefault(_Hour);

      var _Ruler = __webpack_require__(7);

      var _Ruler2 = _interopRequireDefault(_Ruler);

      var _LineLabel = __webpack_require__(35);

      var _LineLabel2 = _interopRequireDefault(_LineLabel);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      var _Timeline = __webpack_require__(18);

      var _Timeline2 = _interopRequireDefault(_Timeline);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var Line = function (_React$Component) {
        _inherits(Line, _React$Component);

        function Line(props) {
          _classCallCheck(this, Line);

          var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, props));

          _this.state = {
            hours: [],
            events: [],
            draggingOver: false
          };
          _this.props.timeSpan.eachTime(function (key, time) {
            if (!time.equals(_this.props.timeSpan.getEndTime())) {
              _this.state.hours.push(_react2.default.createElement(_Hour2.default, {
                key: time.getHour(),
                time: time,
                minHeight: _this.props.minHeight
              }));
            }
          });

          _this.vars = _this.props.vars || {};
          return _this;
        }

        _createClass(Line, [{
          key: 'getRelativeTop',
          value: function getRelativeTop(e) {
            var parentElement = this.props.frame.refs.linesWrapper;
            var parentRect = parentElement.getBoundingClientRect();
            return e.clientY - parentRect.top + parentElement.scrollTop;
          }
        }, {
          key: 'onClick',
          value: function onClick(e) {
            if (this.props.timeline.props.lineDidClick) {
              var time = this.props.timeline.topToTime(this.getRelativeTop(e));
              this.props.timeline.props.lineDidClick({
                component: this,
                time: time,
                freeMinute: this.props.timeline.getFreeMinute(this.props.id, time),
                position: {
                  scrollTop: this.props.timeline.frameComponent.refs.linesWrapper.scrollTop,
                  scrollLeft: this.props.timeline.frameComponent.element.scrollLeft,
                  top: e.clientY,
                  left: e.clientX
                },
                event: e
              });
            }
          }
        }, {
          key: 'onContextMenu',
          value: function onContextMenu(e) {
            if (this.props.timeline.props.lineDidRightClick) {
              this.props.timeline.props.lineDidRightClick({
                event: e,
                component: this
              });
            }
          }
        }, {
          key: 'draggingOver',
          value: function draggingOver() {
            this.setState({ draggingOver: true });
          }
        }, {
          key: 'clearDraggingOver',
          value: function clearDraggingOver() {
            this.setState({ draggingOver: false });
          }
        }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
            if (this.props.timeline.draggingOverLineComponent == this) {
              this.props.timeline.draggingOverLineComponent = undefined;
            }
          }
        }, {
          key: 'render',
          value: function render() {
            var _this2 = this;

            return _react2.default.createElement('div', { className: 'tlLineWrapper', 'data-id': this.props.id, onContextMenu: function onContextMenu(e) {
                return _this2.onContextMenu(e);
              } }, function () {
              if (_this2.props.hasRuler) {
                return _react2.default.createElement(_Ruler2.default, {
                  key: 'ruler_' + _this2.props.id,
                  minHeight: _this2.props.minHeight,
                  timeSpan: _this2.props.timeSpan
                });
              }
            }(), _react2.default.createElement('div', { onClick: function onClick(e) {
                return _this2.onClick(e);
              }, className: (0, _classnames2.default)('tlLineView', { tlEven: this.props.even, tlOdd: !this.props.even }, { tlOver: this.state.draggingOver }), style: { width: this.props.width + 'px' } }, this.state.hours));
          }
        }]);

        return Line;
      }(_react2.default.Component);

      exports.default = Line;

      Line.sidePadding = 1;

      // Line.propTypes = {
      //   width: React.PropTypes.number.isRequired,
      //   minHeight: React.PropTypes.number.isRequired,
      //   timeSpan: React.PropTypes.instanceOf(TimeSpan).isRequired,
      //   id: React.PropTypes.string.isRequired,
      //   onClick: React.PropTypes.func,
      //   even: React.PropTypes.bool.isRequired,
      //   //TODO 循環参照になるのでimportできず。とりあえずanyでごまかしてます。
      //   timeline: React.PropTypes.any.isRequired,
      //   hasRuler: React.PropTypes.bool.isRequired
      // }

      /***/
    },
    /* 35 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _Ruler = __webpack_require__(7);

      var _Ruler2 = _interopRequireDefault(_Ruler);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var LineLabel = function (_React$Component) {
        _inherits(LineLabel, _React$Component);

        function LineLabel(props) {
          _classCallCheck(this, LineLabel);

          var _this = _possibleConstructorReturn(this, (LineLabel.__proto__ || Object.getPrototypeOf(LineLabel)).call(this, props));

          _this.state = {
            hasRuler: _this.props.hasRuler,
            prevRuler: _this.props.prevRuler,
            isLast: _this.props.isLast
          };
          return _this;
        }

        _createClass(LineLabel, [{
          key: 'render',
          value: function render() {
            return _react2.default.createElement('div', {
              style: { width: this.props.width, marginLeft: this.state.hasRuler ? _Ruler2.default.width + 'px' : 0 },
              className: (0, _classnames2.default)({ tlLabel: true, tlHasRuler: this.state.hasRuler, tlPrevRuler: this.state.prevRuler, tlLast: this.state.isLast })
            }, this.props.label);
          }
        }]);

        return LineLabel;
      }(_react2.default.Component);

      exports.default = LineLabel;

      LineLabel.height = 16;

      /***/
    },
    /* 36 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DragDropContext = __webpack_require__(37);

      Object.defineProperty(exports, 'DragDropContext', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragDropContext).default;
        }
      });

      var _DragDropContextProvider = __webpack_require__(138);

      Object.defineProperty(exports, 'DragDropContextProvider', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragDropContextProvider).default;
        }
      });

      var _DragLayer = __webpack_require__(47);

      Object.defineProperty(exports, 'DragLayer', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragLayer).default;
        }
      });

      var _DragSource = __webpack_require__(139);

      Object.defineProperty(exports, 'DragSource', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragSource).default;
        }
      });

      var _DropTarget = __webpack_require__(149);

      Object.defineProperty(exports, 'DropTarget', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DropTarget).default;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 37 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unpackBackendForEs5Users = exports.createChildContext = exports.CHILD_CONTEXT_TYPES = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      exports.default = DragDropContext;

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _propTypes = __webpack_require__(8);

      var _propTypes2 = _interopRequireDefault(_propTypes);

      var _dndCore = __webpack_require__(58);

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _hoistNonReactStatics = __webpack_require__(31);

      var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

      var _checkDecoratorArguments = __webpack_require__(17);

      var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var CHILD_CONTEXT_TYPES = exports.CHILD_CONTEXT_TYPES = {
        dragDropManager: _propTypes2.default.object.isRequired
      };

      var createChildContext = exports.createChildContext = function createChildContext(backend, context) {
        return {
          dragDropManager: new _dndCore.DragDropManager(backend, context)
        };
      };

      var unpackBackendForEs5Users = exports.unpackBackendForEs5Users = function unpackBackendForEs5Users(backendOrModule) {
        // Auto-detect ES6 default export for people still using ES5
        var backend = backendOrModule;
        if ((typeof backend === 'undefined' ? 'undefined' : _typeof(backend)) === 'object' && typeof backend.default === 'function') {
          backend = backend.default;
        }
        (0, _invariant2.default)(typeof backend === 'function', 'Expected the backend to be a function or an ES6 module exporting a default function. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-drop-context.html');
        return backend;
      };

      function DragDropContext(backendOrModule) {
        _checkDecoratorArguments2.default.apply(undefined, ['DragDropContext', 'backend'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params

        var backend = unpackBackendForEs5Users(backendOrModule);
        var childContext = createChildContext(backend);

        return function decorateContext(DecoratedComponent) {
          var _class, _temp;

          var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

          var DragDropContextContainer = (_temp = _class = function (_Component) {
            _inherits(DragDropContextContainer, _Component);

            function DragDropContextContainer() {
              _classCallCheck(this, DragDropContextContainer);

              return _possibleConstructorReturn(this, (DragDropContextContainer.__proto__ || Object.getPrototypeOf(DragDropContextContainer)).apply(this, arguments));
            }

            _createClass(DragDropContextContainer, [{
              key: 'getDecoratedComponentInstance',
              value: function getDecoratedComponentInstance() {
                (0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can ' + 'not be a stateless component.');
                return this.child;
              }
            }, {
              key: 'getManager',
              value: function getManager() {
                return childContext.dragDropManager;
              }
            }, {
              key: 'getChildContext',
              value: function getChildContext() {
                return childContext;
              }
            }, {
              key: 'render',
              value: function render() {
                var _this2 = this;

                return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, {
                  ref: function ref(child) {
                    return _this2.child = child;
                  }
                }));
              }
            }]);

            return DragDropContextContainer;
          }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragDropContext(' + displayName + ')', _class.childContextTypes = CHILD_CONTEXT_TYPES, _temp);

          return (0, _hoistNonReactStatics2.default)(DragDropContextContainer, DecoratedComponent);
        };
      }

      /***/
    },
    /* 38 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      exports.default = dragOffset;
      exports.getSourceClientOffset = getSourceClientOffset;
      exports.getDifferenceFromInitialOffset = getDifferenceFromInitialOffset;

      var _dragDrop = __webpack_require__(11);

      var initialState = {
        initialSourceClientOffset: null,
        initialClientOffset: null,
        clientOffset: null
      };

      function areOffsetsEqual(offsetA, offsetB) {
        if (offsetA === offsetB) {
          return true;
        }
        return offsetA && offsetB && offsetA.x === offsetB.x && offsetA.y === offsetB.y;
      }

      function dragOffset() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
        var action = arguments[1];

        switch (action.type) {
          case _dragDrop.BEGIN_DRAG:
            return {
              initialSourceClientOffset: action.sourceClientOffset,
              initialClientOffset: action.clientOffset,
              clientOffset: action.clientOffset
            };
          case _dragDrop.HOVER:
            if (areOffsetsEqual(state.clientOffset, action.clientOffset)) {
              return state;
            }
            return _extends({}, state, {
              clientOffset: action.clientOffset
            });
          case _dragDrop.END_DRAG:
          case _dragDrop.DROP:
            return initialState;
          default:
            return state;
        }
      }

      function getSourceClientOffset(state) {
        var clientOffset = state.clientOffset,
            initialClientOffset = state.initialClientOffset,
            initialSourceClientOffset = state.initialSourceClientOffset;

        if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
          return null;
        }
        return {
          x: clientOffset.x + initialSourceClientOffset.x - initialClientOffset.x,
          y: clientOffset.y + initialSourceClientOffset.y - initialClientOffset.y
        };
      }

      function getDifferenceFromInitialOffset(state) {
        var clientOffset = state.clientOffset,
            initialClientOffset = state.initialClientOffset;

        if (!clientOffset || !initialClientOffset) {
          return null;
        }
        return {
          x: clientOffset.x - initialClientOffset.x,
          y: clientOffset.y - initialClientOffset.y
        };
      }

      /***/
    },
    /* 39 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = matchesType;

      var _isArray = __webpack_require__(6);

      var _isArray2 = _interopRequireDefault(_isArray);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function matchesType(targetType, draggedItemType) {
        if ((0, _isArray2.default)(targetType)) {
          return targetType.some(function (t) {
            return t === draggedItemType;
          });
        } else {
          return targetType === draggedItemType;
        }
      }

      /***/
    },
    /* 40 */
    /***/function (module, exports, __webpack_require__) {

      var SetCache = __webpack_require__(24),
          arrayIncludes = __webpack_require__(25),
          arrayIncludesWith = __webpack_require__(26),
          arrayMap = __webpack_require__(27),
          baseUnary = __webpack_require__(42),
          cacheHas = __webpack_require__(28);

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            isCommon = true,
            length = array.length,
            result = [],
            valuesLength = values.length;

        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee == null ? value : iteratee(value);

          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
        return result;
      }

      module.exports = baseDifference;

      /***/
    },
    /* 41 */
    /***/function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(20),
          isObject = __webpack_require__(23);

      /** `Object#toString` result references. */
      var asyncTag = '[object AsyncFunction]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          proxyTag = '[object Proxy]';

      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

      module.exports = isFunction;

      /***/
    },
    /* 42 */
    /***/function (module, exports) {

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }

      module.exports = baseUnary;

      /***/
    },
    /* 43 */
    /***/function (module, exports) {

      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */
      function identity(value) {
        return value;
      }

      module.exports = identity;

      /***/
    },
    /* 44 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = dirtyHandlerIds;
      exports.areDirty = areDirty;

      var _xor = __webpack_require__(115);

      var _xor2 = _interopRequireDefault(_xor);

      var _intersection = __webpack_require__(126);

      var _intersection2 = _interopRequireDefault(_intersection);

      var _dragDrop = __webpack_require__(11);

      var _registry = __webpack_require__(16);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var NONE = [];
      var ALL = [];

      function dirtyHandlerIds() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NONE;
        var action = arguments[1];
        var dragOperation = arguments[2];

        switch (action.type) {
          case _dragDrop.HOVER:
            break;
          case _registry.ADD_SOURCE:
          case _registry.ADD_TARGET:
          case _registry.REMOVE_TARGET:
          case _registry.REMOVE_SOURCE:
            return NONE;
          case _dragDrop.BEGIN_DRAG:
          case _dragDrop.PUBLISH_DRAG_SOURCE:
          case _dragDrop.END_DRAG:
          case _dragDrop.DROP:
          default:
            return ALL;
        }

        var targetIds = action.targetIds;
        var prevTargetIds = dragOperation.targetIds;

        var result = (0, _xor2.default)(targetIds, prevTargetIds);

        var didChange = false;
        if (result.length === 0) {
          for (var i = 0; i < targetIds.length; i++) {
            if (targetIds[i] !== prevTargetIds[i]) {
              didChange = true;
              break;
            }
          }
        } else {
          didChange = true;
        }

        if (!didChange) {
          return NONE;
        }

        var prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
        var innermostTargetId = targetIds[targetIds.length - 1];

        if (prevInnermostTargetId !== innermostTargetId) {
          if (prevInnermostTargetId) {
            result.push(prevInnermostTargetId);
          }
          if (innermostTargetId) {
            result.push(innermostTargetId);
          }
        }

        return result;
      }

      function areDirty(state, handlerIds) {
        if (state === NONE) {
          return false;
        }

        if (state === ALL || typeof handlerIds === 'undefined') {
          return true;
        }

        return (0, _intersection2.default)(handlerIds, state).length > 0;
      }

      /***/
    },
    /* 45 */
    /***/function (module, exports) {

      /**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */
      function noop() {
        // No operation performed.
      }

      module.exports = noop;

      /***/
    },
    /* 46 */
    /***/function (module, exports) {

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function (value) {
          result[++index] = value;
        });
        return result;
      }

      module.exports = setToArray;

      /***/
    },
    /* 47 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = DragLayer;

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _propTypes = __webpack_require__(8);

      var _propTypes2 = _interopRequireDefault(_propTypes);

      var _hoistNonReactStatics = __webpack_require__(31);

      var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

      var _isPlainObject = __webpack_require__(2);

      var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _shallowEqual = __webpack_require__(32);

      var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

      var _shallowEqualScalar = __webpack_require__(48);

      var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

      var _checkDecoratorArguments = __webpack_require__(17);

      var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      function DragLayer(collect) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _checkDecoratorArguments2.default.apply(undefined, ['DragLayer', 'collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
        (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the first argument to DragLayer ' + 'to be a function that collects props to inject into the component. ', 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', collect);
        (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the second argument to DragLayer to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', options);

        return function decorateLayer(DecoratedComponent) {
          var _class, _temp;

          var _options$arePropsEqua = options.arePropsEqual,
              arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

          var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

          var DragLayerContainer = (_temp = _class = function (_Component) {
            _inherits(DragLayerContainer, _Component);

            _createClass(DragLayerContainer, [{
              key: 'getDecoratedComponentInstance',
              value: function getDecoratedComponentInstance() {
                (0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can ' + 'not be a stateless component.');
                return this.child;
              }
            }, {
              key: 'shouldComponentUpdate',
              value: function shouldComponentUpdate(nextProps, nextState) {
                return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
              }
            }]);

            function DragLayerContainer(props, context) {
              _classCallCheck(this, DragLayerContainer);

              var _this = _possibleConstructorReturn(this, (DragLayerContainer.__proto__ || Object.getPrototypeOf(DragLayerContainer)).call(this, props));

              _this.handleChange = _this.handleChange.bind(_this);

              _this.manager = context.dragDropManager;
              (0, _invariant2.default)(_typeof(_this.manager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

              _this.state = _this.getCurrentState();
              return _this;
            }

            _createClass(DragLayerContainer, [{
              key: 'componentDidMount',
              value: function componentDidMount() {
                this.isCurrentlyMounted = true;

                var monitor = this.manager.getMonitor();
                this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
                this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);

                this.handleChange();
              }
            }, {
              key: 'componentWillUnmount',
              value: function componentWillUnmount() {
                this.isCurrentlyMounted = false;

                this.unsubscribeFromOffsetChange();
                this.unsubscribeFromStateChange();
              }
            }, {
              key: 'handleChange',
              value: function handleChange() {
                if (!this.isCurrentlyMounted) {
                  return;
                }

                var nextState = this.getCurrentState();
                if (!(0, _shallowEqual2.default)(nextState, this.state)) {
                  this.setState(nextState);
                }
              }
            }, {
              key: 'getCurrentState',
              value: function getCurrentState() {
                var monitor = this.manager.getMonitor();
                return collect(monitor);
              }
            }, {
              key: 'render',
              value: function render() {
                var _this2 = this;

                return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
                  ref: function ref(child) {
                    return _this2.child = child;
                  }
                }));
              }
            }]);

            return DragLayerContainer;
          }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragLayer(' + displayName + ')', _class.contextTypes = {
            dragDropManager: _propTypes2.default.object.isRequired
          }, _temp);

          return (0, _hoistNonReactStatics2.default)(DragLayerContainer, DecoratedComponent);
        };
      }

      /***/
    },
    /* 48 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      exports.default = shallowEqualScalar;
      function shallowEqualScalar(objA, objB) {
        if (objA === objB) {
          return true;
        }

        if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
          return false;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        // Test for A's keys different from B.
        var hasOwn = Object.prototype.hasOwnProperty;
        for (var i = 0; i < keysA.length; i += 1) {
          if (!hasOwn.call(objB, keysA[i])) {
            return false;
          }

          var valA = objA[keysA[i]];
          var valB = objB[keysA[i]];

          if (valA !== valB || (typeof valA === 'undefined' ? 'undefined' : _typeof(valA)) === 'object' || (typeof valB === 'undefined' ? 'undefined' : _typeof(valB)) === 'object') {
            return false;
          }
        }

        return true;
      }

      /***/
    },
    /* 49 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }return target;
        };

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        exports.default = decorateHandler;

        var _react = __webpack_require__(0);

        var _react2 = _interopRequireDefault(_react);

        var _propTypes = __webpack_require__(8);

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _disposables = __webpack_require__(140);

        var _isPlainObject = __webpack_require__(2);

        var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

        var _invariant = __webpack_require__(1);

        var _invariant2 = _interopRequireDefault(_invariant);

        var _hoistNonReactStatics = __webpack_require__(31);

        var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

        var _shallowEqual = __webpack_require__(32);

        var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

        var _shallowEqualScalar = __webpack_require__(48);

        var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
          }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        function decorateHandler(_ref) {
          var _class, _temp;

          var DecoratedComponent = _ref.DecoratedComponent,
              createHandler = _ref.createHandler,
              createMonitor = _ref.createMonitor,
              createConnector = _ref.createConnector,
              registerHandler = _ref.registerHandler,
              containerDisplayName = _ref.containerDisplayName,
              getType = _ref.getType,
              collect = _ref.collect,
              options = _ref.options;
          var _options$arePropsEqua = options.arePropsEqual,
              arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

          var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

          var DragDropContainer = (_temp = _class = function (_Component) {
            _inherits(DragDropContainer, _Component);

            _createClass(DragDropContainer, [{
              key: 'getHandlerId',
              value: function getHandlerId() {
                return this.handlerId;
              }
            }, {
              key: 'getDecoratedComponentInstance',
              value: function getDecoratedComponentInstance() {
                return this.decoratedComponentInstance;
              }
            }, {
              key: 'shouldComponentUpdate',
              value: function shouldComponentUpdate(nextProps, nextState) {
                return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
              }
            }]);

            function DragDropContainer(props, context) {
              _classCallCheck(this, DragDropContainer);

              var _this = _possibleConstructorReturn(this, (DragDropContainer.__proto__ || Object.getPrototypeOf(DragDropContainer)).call(this, props, context));

              _this.handleChange = _this.handleChange.bind(_this);
              _this.handleChildRef = _this.handleChildRef.bind(_this);

              (0, _invariant2.default)(_typeof(_this.context.dragDropManager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

              _this.manager = _this.context.dragDropManager;
              _this.handlerMonitor = createMonitor(_this.manager);
              _this.handlerConnector = createConnector(_this.manager.getBackend());
              _this.handler = createHandler(_this.handlerMonitor);

              _this.disposable = new _disposables.SerialDisposable();
              _this.receiveProps(props);
              _this.state = _this.getCurrentState();
              _this.dispose();
              return _this;
            }

            _createClass(DragDropContainer, [{
              key: 'componentDidMount',
              value: function componentDidMount() {
                this.isCurrentlyMounted = true;
                this.disposable = new _disposables.SerialDisposable();
                this.currentType = null;
                this.receiveProps(this.props);
                this.handleChange();
              }
            }, {
              key: 'componentWillReceiveProps',
              value: function componentWillReceiveProps(nextProps) {
                if (!arePropsEqual(nextProps, this.props)) {
                  this.receiveProps(nextProps);
                  this.handleChange();
                }
              }
            }, {
              key: 'componentWillUnmount',
              value: function componentWillUnmount() {
                this.dispose();
                this.isCurrentlyMounted = false;
              }
            }, {
              key: 'receiveProps',
              value: function receiveProps(props) {
                this.handler.receiveProps(props);
                this.receiveType(getType(props));
              }
            }, {
              key: 'receiveType',
              value: function receiveType(type) {
                if (type === this.currentType) {
                  return;
                }

                this.currentType = type;

                var _registerHandler = registerHandler(type, this.handler, this.manager),
                    handlerId = _registerHandler.handlerId,
                    unregister = _registerHandler.unregister;

                this.handlerId = handlerId;
                this.handlerMonitor.receiveHandlerId(handlerId);
                this.handlerConnector.receiveHandlerId(handlerId);

                var globalMonitor = this.manager.getMonitor();
                var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });

                this.disposable.setDisposable(new _disposables.CompositeDisposable(new _disposables.Disposable(unsubscribe), new _disposables.Disposable(unregister)));
              }
            }, {
              key: 'handleChange',
              value: function handleChange() {
                if (!this.isCurrentlyMounted) {
                  return;
                }

                var nextState = this.getCurrentState();
                if (!(0, _shallowEqual2.default)(nextState, this.state)) {
                  this.setState(nextState);
                }
              }
            }, {
              key: 'dispose',
              value: function dispose() {
                this.disposable.dispose();
                this.handlerConnector.receiveHandlerId(null);
              }
            }, {
              key: 'handleChildRef',
              value: function handleChildRef(component) {
                this.decoratedComponentInstance = component;
                this.handler.receiveComponent(component);
              }
            }, {
              key: 'getCurrentState',
              value: function getCurrentState() {
                var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor);

                if (process.env.NODE_ENV !== 'production') {
                  (0, _invariant2.default)((0, _isPlainObject2.default)(nextState), 'Expected `collect` specified as the second argument to ' + '%s for %s to return a plain object of props to inject. ' + 'Instead, received %s.', containerDisplayName, displayName, nextState);
                }

                return nextState;
              }
            }, {
              key: 'render',
              value: function render() {
                return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
                  ref: this.handleChildRef
                }));
              }
            }]);

            return DragDropContainer;
          }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = containerDisplayName + '(' + displayName + ')', _class.contextTypes = {
            dragDropManager: _propTypes2.default.object.isRequired
          }, _temp);

          return (0, _hoistNonReactStatics2.default)(DragDropContainer, DecoratedComponent);
        }
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 50 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = wrapConnectorHooks;

      var _react = __webpack_require__(0);

      var _cloneWithRef = __webpack_require__(148);

      var _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function throwIfCompositeComponentElement(element) {
        // Custom components can no longer be wrapped directly in React DnD 2.0
        // so that we don't need to depend on findDOMNode() from react-dom.
        if (typeof element.type === 'string') {
          return;
        }

        var displayName = element.type.displayName || element.type.name || 'the component';

        throw new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');
      }

      function wrapHookToRecognizeElement(hook) {
        return function () {
          var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          // When passed a node, call the hook straight away.
          if (!(0, _react.isValidElement)(elementOrNode)) {
            var node = elementOrNode;
            hook(node, options);
            return undefined;
          }

          // If passed a ReactElement, clone it and attach this function as a ref.
          // This helps us achieve a neat API where user doesn't even know that refs
          // are being used under the hood.
          var element = elementOrNode;
          throwIfCompositeComponentElement(element);

          // When no options are passed, use the hook directly
          var ref = options ? function (node) {
            return hook(node, options);
          } : hook;

          return (0, _cloneWithRef2.default)(element, ref);
        };
      }

      function wrapConnectorHooks(hooks) {
        var wrappedHooks = {};

        Object.keys(hooks).forEach(function (key) {
          var hook = hooks[key];
          var wrappedHook = wrapHookToRecognizeElement(hook);
          wrappedHooks[key] = function () {
            return wrappedHook;
          };
        });

        return wrappedHooks;
      }

      /***/
    },
    /* 51 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = areOptionsEqual;

      var _shallowEqual = __webpack_require__(32);

      var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function areOptionsEqual(nextOptions, currentOptions) {
        if (currentOptions === nextOptions) {
          return true;
        }

        return currentOptions !== null && nextOptions !== null && (0, _shallowEqual2.default)(currentOptions, nextOptions);
      }

      /***/
    },
    /* 52 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      exports.default = isValidType;

      var _isArray = __webpack_require__(6);

      var _isArray2 = _interopRequireDefault(_isArray);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function isValidType(type, allowArray) {
        return typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || allowArray && (0, _isArray2.default)(type) && type.every(function (t) {
          return isValidType(t, false);
        });
      }

      /***/
    },
    /* 53 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      var _utils = __webpack_require__(157);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var EventBase = function (_React$Component) {
        _inherits(EventBase, _React$Component);

        function EventBase() {
          _classCallCheck(this, EventBase);

          return _possibleConstructorReturn(this, (EventBase.__proto__ || Object.getPrototypeOf(EventBase)).apply(this, arguments));
        }

        _createClass(EventBase, [{
          key: 'renderDisplay',
          value: function renderDisplay(row) {
            if (!row.value) {
              return null;
            }

            var className = (0, _classnames2.default)('tlEventDisplayRow', row.key);
            if (Array.isArray(row.value)) {
              if (row.value.length === 0) {
                return null;
              }

              return _react2.default.createElement('div', { className: className, key: row.key }, row.value.map(function (val, key) {
                return _react2.default.createElement('div', { key: key, className: 'item' }, val);
              }));
            }

            return _react2.default.createElement('div', { className: className, key: row.key }, row.value);
          }
        }, {
          key: 'render',
          value: function render() {
            var _this2 = this;

            var displayPosition = 'left';
            if (this.refs.base) {
              var previewRect = this.refs.base.getBoundingClientRect();
              // ドラッグ中に0で取れることがある。
              // 特に右端でドラッグをやめると０で終わってdisplayPositionがrightになってしう
              if (previewRect.width !== 0 && previewRect.width !== 0) {
                var previewRightSide = previewRect.left + previewRect.width;
                if (this.props.timeline.getTotalWidth() > previewRightSide + 70) {
                  displayPosition = 'right';
                }
              }
            }
            return _react2.default.createElement('div', { ref: 'base', style: { height: '100%' } }, function () {
              if (_this2.props.draggingDisplay) {
                return _react2.default.createElement('div', { className: (0, _classnames2.default)('tlDraggingDisplay', displayPosition), style: { top: _this2.props.draggingDisplayTop } }, _this2.props.draggingDisplay);
              }
            }(), _react2.default.createElement('div', { className: 'tlEventDisplay' }, this.props.display.map(function (row) {
              return _this2.renderDisplay(row);
            })), '\xA0');
          }
        }]);

        return EventBase;
      }(_react2.default.Component);

      exports.default = EventBase;

      EventBase.defaultProps = { display: [] };

      /***/
    },
    /* 54 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /* eslint-disable no-unused-vars */

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }

          // Detect buggy property enumeration order in older V8 versions.

          // https://bugs.chromium.org/p/v8/issues/detail?id=4118
          var test1 = new String('abc'); // eslint-disable-line
          test1[5] = 'de';
          if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
          }

          // https://bugs.chromium.org/p/v8/issues/detail?id=3056
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });
          if (order2.join('') !== '0123456789') {
            return false;
          }

          // https://bugs.chromium.org/p/v8/issues/detail?id=3056
          var test3 = {};
          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
            return false;
          }

          return true;
        } catch (e) {
          // We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;

        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (Object.getOwnPropertySymbols) {
            symbols = Object.getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };

      /***/
    },
    /* 55 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TimeSpan = exports.Time = exports.Timeline = undefined;

      var _Timeline = __webpack_require__(18);

      var _Timeline2 = _interopRequireDefault(_Timeline);

      var _Time = __webpack_require__(19);

      var _Time2 = _interopRequireDefault(_Time);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.Timeline = _Timeline2.default;
      exports.Time = _Time2.default;
      exports.TimeSpan = _TimeSpan2.default;

      /***/
    },
    /* 56 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      var _Line = __webpack_require__(34);

      var _Line2 = _interopRequireDefault(_Line);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      var _reactDnd = __webpack_require__(36);

      var _reactDndTouchBackend = __webpack_require__(154);

      var _reactDndTouchBackend2 = _interopRequireDefault(_reactDndTouchBackend);

      var _EventPreview = __webpack_require__(156);

      var _EventPreview2 = _interopRequireDefault(_EventPreview);

      var _Event = __webpack_require__(158);

      var _Event2 = _interopRequireDefault(_Event);

      var _Ruler = __webpack_require__(7);

      var _Ruler2 = _interopRequireDefault(_Ruler);

      var _LineLabel = __webpack_require__(35);

      var _LineLabel2 = _interopRequireDefault(_LineLabel);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var target = {
        drop: function drop(props, monitor, component) {
          var item = monitor.getItem();
          var delta = monitor.getDifferenceFromInitialOffset();

          var initalOffset = item.draggingComponent.getOffset();
          var top = Math.round(initalOffset.top + delta.y);
          var left = Math.round(initalOffset.left + delta.x);

          item.draggingComponent.moveTo(top, left);
        },
        hover: function hover(props, monitor, component) {
          var clientOffset = monitor.getSourceClientOffset();
          if (clientOffset) {
            var item = monitor.getItem();
            var lineWrapperBounds = component.refs.linesWrapper.getBoundingClientRect();
            var lineComponent = props.timeline.draggingOver(clientOffset.x - lineWrapperBounds.left + item.draggingComponent.props.width / 2 /*eventの真ん中を基準にする*/);
            var time = props.timeline.topToTime(clientOffset.y + component.refs.linesWrapper.scrollTop - lineWrapperBounds.top);
            item.draggingComponent.dragging(time, lineComponent ? lineComponent.props.id : null);
          }
        }
      };

      function collect(connect, monitor) {
        return {
          connectDropTarget: connect.dropTarget()
        };
      }

      var Frame = function (_React$Component) {
        _inherits(Frame, _React$Component);

        function Frame(props) {
          _classCallCheck(this, Frame);

          var _this = _possibleConstructorReturn(this, (Frame.__proto__ || Object.getPrototypeOf(Frame)).call(this, props));

          var rulerInterval = 4;

          _this.state = {
            minWidth: 0
          };

          _this.resizingEvent = null;
          _this.element = null;
          _this.props.timeline.frameComponent = _this;
          return _this;
        }

        _createClass(Frame, [{
          key: 'resizeUp',
          value: function resizeUp(eventComponent, clickedTop) {
            var _this2 = this;

            var initialHeight = eventComponent.state.height;
            var prevBottom = this.props.timeline.getPrevBottom(eventComponent);
            var mouseMoveEvent = function mouseMoveEvent(moveEvent) {
              eventComponent.resizing = true;
              var targetHeight = initialHeight + clickedTop - moveEvent.clientY;
              if (targetHeight > 36) {
                var targetTop = eventComponent.state.top - (targetHeight - eventComponent.state.height);
                if (targetTop <= prevBottom) {
                  targetTop = prevBottom;
                }

                eventComponent.resizingTimeSpan = new _TimeSpan2.default(_this2.props.timeline.topToTime(targetTop), eventComponent.currentTimeSpan.getEndTime());
                eventComponent.setState({
                  height: _this2.props.timeline.timeSpanToHeight(eventComponent.resizingTimeSpan),
                  top: _this2.props.timeline.timeToTop(eventComponent.resizingTimeSpan.getStartTime()),
                  draggingDisplay: eventComponent.resizingTimeSpan.getStartTime().getDisplayTime()
                });
              }
            };

            var stopMoveEvent = function stopMoveEvent(mouseEvent) {
              _this2.refs.linesWrapper.removeEventListener('mousemove', mouseMoveEvent);
              _this2.refs.linesWrapper.removeEventListener('mouseup', stopMoveEvent);
              _this2.refs.linesWrapper.removeEventListener('mouseleave', stopMoveEvent);
              eventComponent.endResizing(mouseEvent);
            };

            this.refs.linesWrapper.addEventListener('mousemove', mouseMoveEvent);
            this.refs.linesWrapper.addEventListener('mouseup', stopMoveEvent);
            this.refs.linesWrapper.addEventListener('mouseleave', stopMoveEvent);
          }
        }, {
          key: 'resizeDown',
          value: function resizeDown(eventComponent, clickedTop) {
            var _this3 = this;

            var initialHeight = eventComponent.state.height;
            var nextTop = this.props.timeline.getNextTop(eventComponent);
            var mouseMoveEvent = function mouseMoveEvent(moveEvent) {
              eventComponent.resizing = true;
              var targetHeight = initialHeight + moveEvent.clientY - clickedTop;
              if (targetHeight > 36) {
                var targetBottom = eventComponent.state.top + targetHeight;
                if (targetBottom >= nextTop) {
                  targetBottom = nextTop;
                }

                eventComponent.resizingTimeSpan = new _TimeSpan2.default(eventComponent.currentTimeSpan.getStartTime(), _this3.props.timeline.topToTime(targetBottom));
                eventComponent.setState({
                  height: _this3.props.timeline.timeSpanToHeight(eventComponent.resizingTimeSpan),
                  draggingDisplay: eventComponent.resizingTimeSpan.getEndTime().getDisplayTime(),
                  draggingDisplayTop: targetHeight - 10
                });
              }
            };

            var stopMoveEvent = function stopMoveEvent(mouseEvent) {
              _this3.refs.linesWrapper.removeEventListener('mousemove', mouseMoveEvent);
              _this3.refs.linesWrapper.removeEventListener('mouseup', stopMoveEvent);
              _this3.refs.linesWrapper.removeEventListener('mouseleave', stopMoveEvent);
              eventComponent.endResizing(mouseEvent);
            };

            this.refs.linesWrapper.addEventListener('mousemove', mouseMoveEvent);
            this.refs.linesWrapper.addEventListener('mouseup', stopMoveEvent);
            this.refs.linesWrapper.addEventListener('mouseleave', stopMoveEvent);
          }
        }, {
          key: 'setHeight',
          value: function setHeight(height) {
            this.setState({ height: height });
          }
        }, {
          key: 'getRelativePos',
          value: function getRelativePos(e) {
            return {
              top: e.clientY - e.currentTarget.offsetTop + e.currentTarget.scrollTop,
              left: e.clientX - e.currentTarget.offsetLeft + e.currentTarget.scrollLeft
            };
          }
        }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
            var newState = {
              minWidth: this.props.timeline.getTotalWidth()
            };

            this.setState(newState, this.correctOutsideEvents);
          }
        }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
            var newState = {};

            if (nextProps.lineData !== this.props.lineData) {
              newState.minWidth = this.props.timeline.getTotalWidth();
            }

            this.setState(newState, this.correctOutsideEvents);
          }
        }, {
          key: 'correctOutsideEvents',
          value: function correctOutsideEvents() {
            this.props.timeline.eventComponents.forEach(function (event) {
              return event.correctPosition();
            });
          }
        }, {
          key: 'render',
          value: function render() {
            var _this4 = this;

            var connectDropTarget = this.props.connectDropTarget;

            return _react2.default.createElement('div', { ref: function ref(elem) {
                return _this4.element = elem;
              }, className: 'tlFrameView scrollWrapper', style: { width: this.props.width, overflowX: 'auto' } }, _react2.default.createElement('div', { style: { minWidth: this.state.minWidth + this.props.childWidth, display: "flex" } }, function () {
              return connectDropTarget(_react2.default.createElement('div', { className: 'linesFrame', style: { width: _this4.state.minWidth, overflow: 'hidden' } }, _react2.default.createElement('div', { style: { width: _this4.state.minWidth + 20 } }, _react2.default.createElement('div', { className: 'tlLabelView', style: { height: _LineLabel2.default.height } }, _this4.props.lineData.map(function (data, key) {
                var hasRuler = key % _this4.props.rulerInterval === 0;
                var prevRuler = (key + 1) % _this4.props.rulerInterval === 0;
                return _react2.default.createElement(_LineLabel2.default, {
                  key: data.id + "@" + key,
                  width: _this4.props.lineWidth,
                  hasRuler: hasRuler,
                  prevRuler: prevRuler,
                  label: data.label,
                  timeline: _this4.props.timeline,
                  isLast: key == _this4.props.lineData.length - 1
                });
              })), _react2.default.createElement('div', { ref: 'linesWrapper', className: 'tlLinesWrapper scrollWrapper', style: { height: _this4.props.height - _LineLabel2.default.height } }, _react2.default.createElement('div', { style: { height: _this4.props.lineHeight, overflowY: "hidden", position: "relative" } }, _this4.props.lineData.map(function (data, key) {
                var hasRuler = key % _this4.props.rulerInterval === 0;
                var prevRuler = (key + 1) % _this4.props.rulerInterval === 0;
                return _react2.default.createElement(_Line2.default, {
                  ref: "line@" + data.id,
                  hasRuler: hasRuler,
                  key: data.id + "@" + key,
                  id: data.id,
                  width: _this4.props.lineWidth,
                  minHeight: _this4.props.minHeight,
                  timeSpan: _this4.props.timeSpan,
                  even: key % 2 === 0,
                  timeline: _this4.props.timeline,
                  vars: data.vars,
                  frame: _this4
                });
              }), _this4.props.events.map(function (event) {
                return _react2.default.createElement(_Event2.default, {
                  ref: "event@" + event.id,
                  key: event.key || event.id,
                  id: event.id,
                  color: event.color,
                  timeSpan: event.timeSpan,
                  display: event.display,
                  lineId: event.lineId,
                  timeline: _this4.props.timeline,
                  width: _this4.props.timeline.props.lineWidth - 2 - _Line2.default.sidePadding * 2,
                  vars: event.vars,
                  float: event.float,
                  action: event.action
                });
              })), _react2.default.createElement(_EventPreview2.default, { timeline: _this4.props.timeline })))));
            }(), _react2.default.createElement('div', null, this.props.children)));
          }
        }]);

        return Frame;
      }(_react2.default.Component);

      // Frame.propTypes = {
      //   timeSpan: React.PropTypes.instanceOf(TimeSpan).isRequired,
      //   lineData: React.PropTypes.arrayOf(React.PropTypes.shape({
      //     id: React.PropTypes.string.isRequired,
      //     label: React.PropTypes.string.isRequired
      //   })).isRequired,
      //   lineWidth: React.PropTypes.number.isRequired,
      //   minHeight: React.PropTypes.number.isRequired,
      //   onClick: React.PropTypes.func,
      //   timeline: React.PropTypes.any.isRequired,
      //   rulerInterval: React.PropTypes.number.isRequired,
      //   height: React.PropTypes.number.isRequired
      // }

      Frame.defaultProps = {
        events: [],
        childWidth: 0
      };

      exports.default = (0, _reactDnd.DragDropContext)((0, _reactDndTouchBackend2.default)({ enableMouseEvents: true }))((0, _reactDnd.DropTarget)("Event", target, collect)(Frame));

      /***/
    },
    /* 57 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _Time = __webpack_require__(19);

      var _Time2 = _interopRequireDefault(_Time);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var Hour = function (_React$Component) {
        _inherits(Hour, _React$Component);

        function Hour(props) {
          _classCallCheck(this, Hour);

          var _this = _possibleConstructorReturn(this, (Hour.__proto__ || Object.getPrototypeOf(Hour)).call(this, props));

          _this.state = {
            minutes: []
          };

          var minStyle = {
            height: _this.props.minHeight + 'px'
          };
          _Time2.default.eachMin(function (key, min) {
            _this.state.minutes.push(_react2.default.createElement('div', {
              key: min,
              className: (0, _classnames2.default)('tlMinView', 'tl' + min),
              style: minStyle
            }, '\xA0'));
          }, 15);
          return _this;
        }

        _createClass(Hour, [{
          key: 'render',
          value: function render() {
            return _react2.default.createElement('div', { className: (0, _classnames2.default)('tlHourView', 'tl' + this.props.time.getHour()) }, this.state.minutes);
          }
        }]);

        return Hour;
      }(_react2.default.Component);

      // Hour.propTypes = {
      //   minHeight: React.PropTypes.number.isRequired,
      //   time: React.PropTypes.instanceOf(Time).isRequired
      // }


      exports.default = Hour;

      /***/
    },
    /* 58 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DragDropManager = __webpack_require__(59);

      Object.defineProperty(exports, 'DragDropManager', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragDropManager).default;
        }
      });

      var _DragSource = __webpack_require__(135);

      Object.defineProperty(exports, 'DragSource', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragSource).default;
        }
      });

      var _DropTarget = __webpack_require__(136);

      Object.defineProperty(exports, 'DropTarget', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DropTarget).default;
        }
      });

      var _createTestBackend = __webpack_require__(137);

      Object.defineProperty(exports, 'createTestBackend', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_createTestBackend).default;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 59 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _createStore = __webpack_require__(60);

      var _createStore2 = _interopRequireDefault(_createStore);

      var _reducers = __webpack_require__(70);

      var _reducers2 = _interopRequireDefault(_reducers);

      var _dragDrop = __webpack_require__(11);

      var dragDropActions = _interopRequireWildcard(_dragDrop);

      var _DragDropMonitor = __webpack_require__(130);

      var _DragDropMonitor2 = _interopRequireDefault(_DragDropMonitor);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DragDropManager = function () {
        function DragDropManager(createBackend) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck(this, DragDropManager);

          var store = (0, _createStore2.default)(_reducers2.default);
          this.context = context;
          this.store = store;
          this.monitor = new _DragDropMonitor2.default(store);
          this.registry = this.monitor.registry;
          this.backend = createBackend(this);

          store.subscribe(this.handleRefCountChange.bind(this));
        }

        _createClass(DragDropManager, [{
          key: 'handleRefCountChange',
          value: function handleRefCountChange() {
            var shouldSetUp = this.store.getState().refCount > 0;
            if (shouldSetUp && !this.isSetUp) {
              this.backend.setup();
              this.isSetUp = true;
            } else if (!shouldSetUp && this.isSetUp) {
              this.backend.teardown();
              this.isSetUp = false;
            }
          }
        }, {
          key: 'getContext',
          value: function getContext() {
            return this.context;
          }
        }, {
          key: 'getMonitor',
          value: function getMonitor() {
            return this.monitor;
          }
        }, {
          key: 'getBackend',
          value: function getBackend() {
            return this.backend;
          }
        }, {
          key: 'getRegistry',
          value: function getRegistry() {
            return this.registry;
          }
        }, {
          key: 'getActions',
          value: function getActions() {
            var manager = this;
            var dispatch = this.store.dispatch;

            function bindActionCreator(actionCreator) {
              return function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                var action = actionCreator.apply(manager, args);
                if (typeof action !== 'undefined') {
                  dispatch(action);
                }
              };
            }

            return Object.keys(dragDropActions).filter(function (key) {
              return typeof dragDropActions[key] === 'function';
            }).reduce(function (boundActions, key) {
              var action = dragDropActions[key];
              boundActions[key] = bindActionCreator(action); // eslint-disable-line no-param-reassign
              return boundActions;
            }, {});
          }
        }]);

        return DragDropManager;
      }();

      exports.default = DragDropManager;

      /***/
    },
    /* 60 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      exports.__esModule = true;
      exports.ActionTypes = undefined;
      exports['default'] = createStore;

      var _isPlainObject = __webpack_require__(2);

      var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

      var _symbolObservable = __webpack_require__(66);

      var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { 'default': obj };
      }

      /**
       * These are private action types reserved by Redux.
       * For any unknown actions, you must return the current state.
       * If the current state is undefined, you must return the initial state.
       * Do not reference these action types directly in your code.
       */
      var ActionTypes = exports.ActionTypes = {
        INIT: '@@redux/INIT'

        /**
         * Creates a Redux store that holds the state tree.
         * The only way to change the data in the store is to call `dispatch()` on it.
         *
         * There should only be a single store in your app. To specify how different
         * parts of the state tree respond to actions, you may combine several reducers
         * into a single reducer function by using `combineReducers`.
         *
         * @param {Function} reducer A function that returns the next state tree, given
         * the current state tree and the action to handle.
         *
         * @param {any} [preloadedState] The initial state. You may optionally specify it
         * to hydrate the state from the server in universal apps, or to restore a
         * previously serialized user session.
         * If you use `combineReducers` to produce the root reducer function, this must be
         * an object with the same shape as `combineReducers` keys.
         *
         * @param {Function} [enhancer] The store enhancer. You may optionally specify it
         * to enhance the store with third-party capabilities such as middleware,
         * time travel, persistence, etc. The only store enhancer that ships with Redux
         * is `applyMiddleware()`.
         *
         * @returns {Store} A Redux store that lets you read the state, dispatch actions
         * and subscribe to changes.
         */
      };function createStore(reducer, preloadedState, enhancer) {
        var _ref2;

        if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
          enhancer = preloadedState;
          preloadedState = undefined;
        }

        if (typeof enhancer !== 'undefined') {
          if (typeof enhancer !== 'function') {
            throw new Error('Expected the enhancer to be a function.');
          }

          return enhancer(createStore)(reducer, preloadedState);
        }

        if (typeof reducer !== 'function') {
          throw new Error('Expected the reducer to be a function.');
        }

        var currentReducer = reducer;
        var currentState = preloadedState;
        var currentListeners = [];
        var nextListeners = currentListeners;
        var isDispatching = false;

        function ensureCanMutateNextListeners() {
          if (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
          }
        }

        /**
         * Reads the state tree managed by the store.
         *
         * @returns {any} The current state tree of your application.
         */
        function getState() {
          return currentState;
        }

        /**
         * Adds a change listener. It will be called any time an action is dispatched,
         * and some part of the state tree may potentially have changed. You may then
         * call `getState()` to read the current state tree inside the callback.
         *
         * You may call `dispatch()` from a change listener, with the following
         * caveats:
         *
         * 1. The subscriptions are snapshotted just before every `dispatch()` call.
         * If you subscribe or unsubscribe while the listeners are being invoked, this
         * will not have any effect on the `dispatch()` that is currently in progress.
         * However, the next `dispatch()` call, whether nested or not, will use a more
         * recent snapshot of the subscription list.
         *
         * 2. The listener should not expect to see all state changes, as the state
         * might have been updated multiple times during a nested `dispatch()` before
         * the listener is called. It is, however, guaranteed that all subscribers
         * registered before the `dispatch()` started will be called with the latest
         * state by the time it exits.
         *
         * @param {Function} listener A callback to be invoked on every dispatch.
         * @returns {Function} A function to remove this change listener.
         */
        function subscribe(listener) {
          if (typeof listener !== 'function') {
            throw new Error('Expected listener to be a function.');
          }

          var isSubscribed = true;

          ensureCanMutateNextListeners();
          nextListeners.push(listener);

          return function unsubscribe() {
            if (!isSubscribed) {
              return;
            }

            isSubscribed = false;

            ensureCanMutateNextListeners();
            var index = nextListeners.indexOf(listener);
            nextListeners.splice(index, 1);
          };
        }

        /**
         * Dispatches an action. It is the only way to trigger a state change.
         *
         * The `reducer` function, used to create the store, will be called with the
         * current state tree and the given `action`. Its return value will
         * be considered the **next** state of the tree, and the change listeners
         * will be notified.
         *
         * The base implementation only supports plain object actions. If you want to
         * dispatch a Promise, an Observable, a thunk, or something else, you need to
         * wrap your store creating function into the corresponding middleware. For
         * example, see the documentation for the `redux-thunk` package. Even the
         * middleware will eventually dispatch plain object actions using this method.
         *
         * @param {Object} action A plain object representing “what changed”. It is
         * a good idea to keep actions serializable so you can record and replay user
         * sessions, or use the time travelling `redux-devtools`. An action must have
         * a `type` property which may not be `undefined`. It is a good idea to use
         * string constants for action types.
         *
         * @returns {Object} For convenience, the same action object you dispatched.
         *
         * Note that, if you use a custom middleware, it may wrap `dispatch()` to
         * return something else (for example, a Promise you can await).
         */
        function dispatch(action) {
          if (!(0, _isPlainObject2['default'])(action)) {
            throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
          }

          if (typeof action.type === 'undefined') {
            throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
          }

          if (isDispatching) {
            throw new Error('Reducers may not dispatch actions.');
          }

          try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
          } finally {
            isDispatching = false;
          }

          var listeners = currentListeners = nextListeners;
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            listener();
          }

          return action;
        }

        /**
         * Replaces the reducer currently used by the store to calculate the state.
         *
         * You might need this if your app implements code splitting and you want to
         * load some of the reducers dynamically. You might also need this if you
         * implement a hot reloading mechanism for Redux.
         *
         * @param {Function} nextReducer The reducer for the store to use instead.
         * @returns {void}
         */
        function replaceReducer(nextReducer) {
          if (typeof nextReducer !== 'function') {
            throw new Error('Expected the nextReducer to be a function.');
          }

          currentReducer = nextReducer;
          dispatch({ type: ActionTypes.INIT });
        }

        /**
         * Interoperability point for observable/reactive libraries.
         * @returns {observable} A minimal observable of state changes.
         * For more information, see the observable proposal:
         * https://github.com/tc39/proposal-observable
         */
        function observable() {
          var _ref;

          var outerSubscribe = subscribe;
          return _ref = {
            /**
             * The minimal observable subscription method.
             * @param {Object} observer Any object that can be used as an observer.
             * The observer object should have a `next` method.
             * @returns {subscription} An object with an `unsubscribe` method that can
             * be used to unsubscribe the observable from the store, and prevent further
             * emission of values from the observable.
             */
            subscribe: function subscribe(observer) {
              if ((typeof observer === 'undefined' ? 'undefined' : _typeof2(observer)) !== 'object') {
                throw new TypeError('Expected the observer to be an object.');
              }

              function observeState() {
                if (observer.next) {
                  observer.next(getState());
                }
              }

              observeState();
              var unsubscribe = outerSubscribe(observeState);
              return { unsubscribe: unsubscribe };
            }
          }, _ref[_symbolObservable2['default']] = function () {
            return this;
          }, _ref;
        }

        // When a store is created, an "INIT" action is dispatched so that every
        // reducer returns their initial state. This effectively populates
        // the initial state tree.
        dispatch({ type: ActionTypes.INIT });

        return _ref2 = {
          dispatch: dispatch,
          subscribe: subscribe,
          getState: getState,
          replaceReducer: replaceReducer
        }, _ref2[_symbolObservable2['default']] = observable, _ref2;
      }

      /***/
    },
    /* 61 */
    /***/function (module, exports, __webpack_require__) {

      /* WEBPACK VAR INJECTION */(function (global) {
        /** Detect free variable `global` from Node.js. */
        var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof2(global)) == 'object' && global && global.Object === Object && global;

        module.exports = freeGlobal;

        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(22));

      /***/
    },
    /* 62 */
    /***/function (module, exports, __webpack_require__) {

      var _Symbol4 = __webpack_require__(21);

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /** Built-in value references. */
      var symToStringTag = _Symbol4 ? _Symbol4.toStringTag : undefined;

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

      module.exports = getRawTag;

      /***/
    },
    /* 63 */
    /***/function (module, exports) {

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      module.exports = objectToString;

      /***/
    },
    /* 64 */
    /***/function (module, exports, __webpack_require__) {

      var overArg = __webpack_require__(65);

      /** Built-in value references. */
      var getPrototype = overArg(Object.getPrototypeOf, Object);

      module.exports = getPrototype;

      /***/
    },
    /* 65 */
    /***/function (module, exports) {

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }

      module.exports = overArg;

      /***/
    },
    /* 66 */
    /***/function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(67);

      /***/
    },
    /* 67 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (global, module) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _ponyfill = __webpack_require__(69);

        var _ponyfill2 = _interopRequireDefault(_ponyfill);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { 'default': obj };
        }

        var root; /* global window */

        if (typeof self !== 'undefined') {
          root = self;
        } else if (typeof window !== 'undefined') {
          root = window;
        } else if (typeof global !== 'undefined') {
          root = global;
        } else if (true) {
          root = module;
        } else {
          root = Function('return this')();
        }

        var result = (0, _ponyfill2['default'])(root);
        exports['default'] = result;
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(22), __webpack_require__(68)(module));

      /***/
    },
    /* 68 */
    /***/function (module, exports) {

      module.exports = function (module) {
        if (!module.webpackPolyfill) {
          module.deprecate = function () {};
          module.paths = [];
          // module.parent = undefined by default
          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function get() {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function get() {
              return module.i;
            }
          });
          module.webpackPolyfill = 1;
        }
        return module;
      };

      /***/
    },
    /* 69 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports['default'] = symbolObservablePonyfill;
      function symbolObservablePonyfill(root) {
        var result;
        var _Symbol = root.Symbol;

        if (typeof _Symbol === 'function') {
          if (_Symbol.observable) {
            result = _Symbol.observable;
          } else {
            result = _Symbol('observable');
            _Symbol.observable = result;
          }
        } else {
          result = '@@observable';
        }

        return result;
      };

      /***/
    },
    /* 70 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = reduce;

      var _dragOffset = __webpack_require__(38);

      var _dragOffset2 = _interopRequireDefault(_dragOffset);

      var _dragOperation = __webpack_require__(71);

      var _dragOperation2 = _interopRequireDefault(_dragOperation);

      var _refCount = __webpack_require__(114);

      var _refCount2 = _interopRequireDefault(_refCount);

      var _dirtyHandlerIds = __webpack_require__(44);

      var _dirtyHandlerIds2 = _interopRequireDefault(_dirtyHandlerIds);

      var _stateId = __webpack_require__(129);

      var _stateId2 = _interopRequireDefault(_stateId);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function reduce() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var action = arguments[1];

        return {
          dirtyHandlerIds: (0, _dirtyHandlerIds2.default)(state.dirtyHandlerIds, action, state.dragOperation),
          dragOffset: (0, _dragOffset2.default)(state.dragOffset, action),
          refCount: (0, _refCount2.default)(state.refCount, action),
          dragOperation: (0, _dragOperation2.default)(state.dragOperation, action),
          stateId: (0, _stateId2.default)(state.stateId)
        };
      }

      /***/
    },
    /* 71 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      exports.default = dragOperation;

      var _without = __webpack_require__(72);

      var _without2 = _interopRequireDefault(_without);

      var _dragDrop = __webpack_require__(11);

      var _registry = __webpack_require__(16);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var initialState = {
        itemType: null,
        item: null,
        sourceId: null,
        targetIds: [],
        dropResult: null,
        didDrop: false,
        isSourcePublic: null
      };

      function dragOperation() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
        var action = arguments[1];

        switch (action.type) {
          case _dragDrop.BEGIN_DRAG:
            return _extends({}, state, {
              itemType: action.itemType,
              item: action.item,
              sourceId: action.sourceId,
              isSourcePublic: action.isSourcePublic,
              dropResult: null,
              didDrop: false
            });
          case _dragDrop.PUBLISH_DRAG_SOURCE:
            return _extends({}, state, {
              isSourcePublic: true
            });
          case _dragDrop.HOVER:
            return _extends({}, state, {
              targetIds: action.targetIds
            });
          case _registry.REMOVE_TARGET:
            if (state.targetIds.indexOf(action.targetId) === -1) {
              return state;
            }
            return _extends({}, state, {
              targetIds: (0, _without2.default)(state.targetIds, action.targetId)
            });
          case _dragDrop.DROP:
            return _extends({}, state, {
              dropResult: action.dropResult,
              didDrop: true,
              targetIds: []
            });
          case _dragDrop.END_DRAG:
            return _extends({}, state, {
              itemType: null,
              item: null,
              sourceId: null,
              dropResult: null,
              didDrop: false,
              isSourcePublic: null,
              targetIds: []
            });
          default:
            return state;
        }
      }

      /***/
    },
    /* 72 */
    /***/function (module, exports, __webpack_require__) {

      var baseDifference = __webpack_require__(40),
          baseRest = __webpack_require__(29),
          isArrayLikeObject = __webpack_require__(30);

      /**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */
      var without = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
      });

      module.exports = without;

      /***/
    },
    /* 73 */
    /***/function (module, exports, __webpack_require__) {

      var mapCacheClear = __webpack_require__(74),
          mapCacheDelete = __webpack_require__(94),
          mapCacheGet = __webpack_require__(96),
          mapCacheHas = __webpack_require__(97),
          mapCacheSet = __webpack_require__(98);

      /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function MapCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `MapCache`.
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;

      module.exports = MapCache;

      /***/
    },
    /* 74 */
    /***/function (module, exports, __webpack_require__) {

      var Hash = __webpack_require__(75),
          ListCache = __webpack_require__(86),
          Map = __webpack_require__(93);

      /**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash(),
          'map': new (Map || ListCache)(),
          'string': new Hash()
        };
      }

      module.exports = mapCacheClear;

      /***/
    },
    /* 75 */
    /***/function (module, exports, __webpack_require__) {

      var hashClear = __webpack_require__(76),
          hashDelete = __webpack_require__(82),
          hashGet = __webpack_require__(83),
          hashHas = __webpack_require__(84),
          hashSet = __webpack_require__(85);

      /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Hash(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `Hash`.
      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;

      module.exports = Hash;

      /***/
    },
    /* 76 */
    /***/function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(12);

      /**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

      module.exports = hashClear;

      /***/
    },
    /* 77 */
    /***/function (module, exports, __webpack_require__) {

      var isFunction = __webpack_require__(41),
          isMasked = __webpack_require__(78),
          isObject = __webpack_require__(23),
          toSource = __webpack_require__(80);

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used for built-in method references. */
      var funcProto = Function.prototype,
          objectProto = Object.prototype;

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Used to detect if a method is native. */
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

      module.exports = baseIsNative;

      /***/
    },
    /* 78 */
    /***/function (module, exports, __webpack_require__) {

      var coreJsData = __webpack_require__(79);

      /** Used to detect methods masquerading as native. */
      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();

      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }

      module.exports = isMasked;

      /***/
    },
    /* 79 */
    /***/function (module, exports, __webpack_require__) {

      var root = __webpack_require__(9);

      /** Used to detect overreaching core-js shims. */
      var coreJsData = root['__core-js_shared__'];

      module.exports = coreJsData;

      /***/
    },
    /* 80 */
    /***/function (module, exports) {

      /** Used for built-in method references. */
      var funcProto = Function.prototype;

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return func + '';
          } catch (e) {}
        }
        return '';
      }

      module.exports = toSource;

      /***/
    },
    /* 81 */
    /***/function (module, exports) {

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

      module.exports = getValue;

      /***/
    },
    /* 82 */
    /***/function (module, exports) {

      /**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = hashDelete;

      /***/
    },
    /* 83 */
    /***/function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(12);

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }

      module.exports = hashGet;

      /***/
    },
    /* 84 */
    /***/function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(12);

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
      }

      module.exports = hashHas;

      /***/
    },
    /* 85 */
    /***/function (module, exports, __webpack_require__) {

      var nativeCreate = __webpack_require__(12);

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        return this;
      }

      module.exports = hashSet;

      /***/
    },
    /* 86 */
    /***/function (module, exports, __webpack_require__) {

      var listCacheClear = __webpack_require__(87),
          listCacheDelete = __webpack_require__(88),
          listCacheGet = __webpack_require__(90),
          listCacheHas = __webpack_require__(91),
          listCacheSet = __webpack_require__(92);

      /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function ListCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `ListCache`.
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;

      module.exports = ListCache;

      /***/
    },
    /* 87 */
    /***/function (module, exports) {

      /**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

      module.exports = listCacheClear;

      /***/
    },
    /* 88 */
    /***/function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(14);

      /** Used for built-in method references. */
      var arrayProto = Array.prototype;

      /** Built-in value references. */
      var splice = arrayProto.splice;

      /**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function listCacheDelete(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }

      module.exports = listCacheDelete;

      /***/
    },
    /* 89 */
    /***/function (module, exports) {

      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }

      module.exports = eq;

      /***/
    },
    /* 90 */
    /***/function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(14);

      /**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function listCacheGet(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        return index < 0 ? undefined : data[index][1];
      }

      module.exports = listCacheGet;

      /***/
    },
    /* 91 */
    /***/function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(14);

      /**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

      module.exports = listCacheHas;

      /***/
    },
    /* 92 */
    /***/function (module, exports, __webpack_require__) {

      var assocIndexOf = __webpack_require__(14);

      /**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */
      function listCacheSet(key, value) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }

      module.exports = listCacheSet;

      /***/
    },
    /* 93 */
    /***/function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(13),
          root = __webpack_require__(9);

      /* Built-in method references that are verified to be native. */
      var Map = getNative(root, 'Map');

      module.exports = Map;

      /***/
    },
    /* 94 */
    /***/function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(15);

      /**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = mapCacheDelete;

      /***/
    },
    /* 95 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */
      function isKeyable(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
      }

      module.exports = isKeyable;

      /***/
    },
    /* 96 */
    /***/function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(15);

      /**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

      module.exports = mapCacheGet;

      /***/
    },
    /* 97 */
    /***/function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(15);

      /**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

      module.exports = mapCacheHas;

      /***/
    },
    /* 98 */
    /***/function (module, exports, __webpack_require__) {

      var getMapData = __webpack_require__(15);

      /**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */
      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
            size = data.size;

        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

      module.exports = mapCacheSet;

      /***/
    },
    /* 99 */
    /***/function (module, exports) {

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }

      module.exports = setCacheAdd;

      /***/
    },
    /* 100 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */
      function setCacheHas(value) {
        return this.__data__.has(value);
      }

      module.exports = setCacheHas;

      /***/
    },
    /* 101 */
    /***/function (module, exports, __webpack_require__) {

      var baseFindIndex = __webpack_require__(102),
          baseIsNaN = __webpack_require__(103),
          strictIndexOf = __webpack_require__(104);

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      module.exports = baseIndexOf;

      /***/
    },
    /* 102 */
    /***/function (module, exports) {

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      module.exports = baseFindIndex;

      /***/
    },
    /* 103 */
    /***/function (module, exports) {

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      module.exports = baseIsNaN;

      /***/
    },
    /* 104 */
    /***/function (module, exports) {

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      module.exports = strictIndexOf;

      /***/
    },
    /* 105 */
    /***/function (module, exports, __webpack_require__) {

      var apply = __webpack_require__(106);

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max;

      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */
      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
        return function () {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }

      module.exports = overRest;

      /***/
    },
    /* 106 */
    /***/function (module, exports) {

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      module.exports = apply;

      /***/
    },
    /* 107 */
    /***/function (module, exports, __webpack_require__) {

      var baseSetToString = __webpack_require__(108),
          shortOut = __webpack_require__(111);

      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var setToString = shortOut(baseSetToString);

      module.exports = setToString;

      /***/
    },
    /* 108 */
    /***/function (module, exports, __webpack_require__) {

      var constant = __webpack_require__(109),
          defineProperty = __webpack_require__(110),
          identity = __webpack_require__(43);

      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var baseSetToString = !defineProperty ? identity : function (func, string) {
        return defineProperty(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(string),
          'writable': true
        });
      };

      module.exports = baseSetToString;

      /***/
    },
    /* 109 */
    /***/function (module, exports) {

      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */
      function constant(value) {
        return function () {
          return value;
        };
      }

      module.exports = constant;

      /***/
    },
    /* 110 */
    /***/function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(13);

      var defineProperty = function () {
        try {
          var func = getNative(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) {}
      }();

      module.exports = defineProperty;

      /***/
    },
    /* 111 */
    /***/function (module, exports) {

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeNow = Date.now;

      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */
      function shortOut(func) {
        var count = 0,
            lastCalled = 0;

        return function () {
          var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);

          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined, arguments);
        };
      }

      module.exports = shortOut;

      /***/
    },
    /* 112 */
    /***/function (module, exports, __webpack_require__) {

      var isFunction = __webpack_require__(41),
          isLength = __webpack_require__(113);

      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }

      module.exports = isArrayLike;

      /***/
    },
    /* 113 */
    /***/function (module, exports) {

      /** Used as references for various `Number` constants. */
      var MAX_SAFE_INTEGER = 9007199254740991;

      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */
      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

      module.exports = isLength;

      /***/
    },
    /* 114 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = refCount;

      var _registry = __webpack_require__(16);

      function refCount() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var action = arguments[1];

        switch (action.type) {
          case _registry.ADD_SOURCE:
          case _registry.ADD_TARGET:
            return state + 1;
          case _registry.REMOVE_SOURCE:
          case _registry.REMOVE_TARGET:
            return state - 1;
          default:
            return state;
        }
      }

      /***/
    },
    /* 115 */
    /***/function (module, exports, __webpack_require__) {

      var arrayFilter = __webpack_require__(116),
          baseRest = __webpack_require__(29),
          baseXor = __webpack_require__(117),
          isArrayLikeObject = __webpack_require__(30);

      /**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */
      var xor = baseRest(function (arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });

      module.exports = xor;

      /***/
    },
    /* 116 */
    /***/function (module, exports) {

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      module.exports = arrayFilter;

      /***/
    },
    /* 117 */
    /***/function (module, exports, __webpack_require__) {

      var baseDifference = __webpack_require__(40),
          baseFlatten = __webpack_require__(118),
          baseUniq = __webpack_require__(123);

      /**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */
      function baseXor(arrays, iteratee, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1,
            result = Array(length);

        while (++index < length) {
          var array = arrays[index],
              othIndex = -1;

          while (++othIndex < length) {
            if (othIndex != index) {
              result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
      }

      module.exports = baseXor;

      /***/
    },
    /* 118 */
    /***/function (module, exports, __webpack_require__) {

      var arrayPush = __webpack_require__(119),
          isFlattenable = __webpack_require__(120);

      /**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
            length = array.length;

        predicate || (predicate = isFlattenable);
        result || (result = []);

        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              // Recursively flatten arrays (susceptible to call stack limits).
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }

      module.exports = baseFlatten;

      /***/
    },
    /* 119 */
    /***/function (module, exports) {

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      module.exports = arrayPush;

      /***/
    },
    /* 120 */
    /***/function (module, exports, __webpack_require__) {

      var _Symbol5 = __webpack_require__(21),
          isArguments = __webpack_require__(121),
          isArray = __webpack_require__(6);

      /** Built-in value references. */
      var spreadableSymbol = _Symbol5 ? _Symbol5.isConcatSpreadable : undefined;

      /**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }

      module.exports = isFlattenable;

      /***/
    },
    /* 121 */
    /***/function (module, exports, __webpack_require__) {

      var baseIsArguments = __webpack_require__(122),
          isObjectLike = __webpack_require__(10);

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Built-in value references. */
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;

      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */
      var isArguments = baseIsArguments(function () {
        return arguments;
      }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
      };

      module.exports = isArguments;

      /***/
    },
    /* 122 */
    /***/function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(20),
          isObjectLike = __webpack_require__(10);

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]';

      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }

      module.exports = baseIsArguments;

      /***/
    },
    /* 123 */
    /***/function (module, exports, __webpack_require__) {

      var SetCache = __webpack_require__(24),
          arrayIncludes = __webpack_require__(25),
          arrayIncludesWith = __webpack_require__(26),
          cacheHas = __webpack_require__(28),
          createSet = __webpack_require__(124),
          setToArray = __webpack_require__(46);

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */
      function baseUniq(array, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            length = array.length,
            isCommon = true,
            result = [],
            seen = result;

        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }

      module.exports = baseUniq;

      /***/
    },
    /* 124 */
    /***/function (module, exports, __webpack_require__) {

      var Set = __webpack_require__(125),
          noop = __webpack_require__(45),
          setToArray = __webpack_require__(46);

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0;

      /**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */
      var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
        return new Set(values);
      };

      module.exports = createSet;

      /***/
    },
    /* 125 */
    /***/function (module, exports, __webpack_require__) {

      var getNative = __webpack_require__(13),
          root = __webpack_require__(9);

      /* Built-in method references that are verified to be native. */
      var Set = getNative(root, 'Set');

      module.exports = Set;

      /***/
    },
    /* 126 */
    /***/function (module, exports, __webpack_require__) {

      var arrayMap = __webpack_require__(27),
          baseIntersection = __webpack_require__(127),
          baseRest = __webpack_require__(29),
          castArrayLikeObject = __webpack_require__(128);

      /**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */
      var intersection = baseRest(function (arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });

      module.exports = intersection;

      /***/
    },
    /* 127 */
    /***/function (module, exports, __webpack_require__) {

      var SetCache = __webpack_require__(24),
          arrayIncludes = __webpack_require__(25),
          arrayIncludesWith = __webpack_require__(26),
          arrayMap = __webpack_require__(27),
          baseUnary = __webpack_require__(42),
          cacheHas = __webpack_require__(28);

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMin = Math.min;

      /**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */
      function baseIntersection(arrays, iteratee, comparator) {
        var includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = Infinity,
            result = [];

        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
        }
        array = arrays[0];

        var index = -1,
            seen = caches[0];

        outer: while (++index < length && result.length < maxLength) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }

      module.exports = baseIntersection;

      /***/
    },
    /* 128 */
    /***/function (module, exports, __webpack_require__) {

      var isArrayLikeObject = __webpack_require__(30);

      /**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }

      module.exports = castArrayLikeObject;

      /***/
    },
    /* 129 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = stateId;
      function stateId() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        return state + 1;
      }

      /***/
    },
    /* 130 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _isArray = __webpack_require__(6);

      var _isArray2 = _interopRequireDefault(_isArray);

      var _matchesType = __webpack_require__(39);

      var _matchesType2 = _interopRequireDefault(_matchesType);

      var _HandlerRegistry = __webpack_require__(131);

      var _HandlerRegistry2 = _interopRequireDefault(_HandlerRegistry);

      var _dragOffset = __webpack_require__(38);

      var _dirtyHandlerIds = __webpack_require__(44);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DragDropMonitor = function () {
        function DragDropMonitor(store) {
          _classCallCheck(this, DragDropMonitor);

          this.store = store;
          this.registry = new _HandlerRegistry2.default(store);
        }

        _createClass(DragDropMonitor, [{
          key: 'subscribeToStateChange',
          value: function subscribeToStateChange(listener) {
            var _this = this;

            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var handlerIds = options.handlerIds;

            (0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');
            (0, _invariant2.default)(typeof handlerIds === 'undefined' || (0, _isArray2.default)(handlerIds), 'handlerIds, when specified, must be an array of strings.');

            var prevStateId = this.store.getState().stateId;
            var handleChange = function handleChange() {
              var state = _this.store.getState();
              var currentStateId = state.stateId;
              try {
                var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !(0, _dirtyHandlerIds.areDirty)(state.dirtyHandlerIds, handlerIds);

                if (!canSkipListener) {
                  listener();
                }
              } finally {
                prevStateId = currentStateId;
              }
            };

            return this.store.subscribe(handleChange);
          }
        }, {
          key: 'subscribeToOffsetChange',
          value: function subscribeToOffsetChange(listener) {
            var _this2 = this;

            (0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');

            var previousState = this.store.getState().dragOffset;
            var handleChange = function handleChange() {
              var nextState = _this2.store.getState().dragOffset;
              if (nextState === previousState) {
                return;
              }

              previousState = nextState;
              listener();
            };

            return this.store.subscribe(handleChange);
          }
        }, {
          key: 'canDragSource',
          value: function canDragSource(sourceId) {
            var source = this.registry.getSource(sourceId);
            (0, _invariant2.default)(source, 'Expected to find a valid source.');

            if (this.isDragging()) {
              return false;
            }

            return source.canDrag(this, sourceId);
          }
        }, {
          key: 'canDropOnTarget',
          value: function canDropOnTarget(targetId) {
            var target = this.registry.getTarget(targetId);
            (0, _invariant2.default)(target, 'Expected to find a valid target.');

            if (!this.isDragging() || this.didDrop()) {
              return false;
            }

            var targetType = this.registry.getTargetType(targetId);
            var draggedItemType = this.getItemType();
            return (0, _matchesType2.default)(targetType, draggedItemType) && target.canDrop(this, targetId);
          }
        }, {
          key: 'isDragging',
          value: function isDragging() {
            return Boolean(this.getItemType());
          }
        }, {
          key: 'isDraggingSource',
          value: function isDraggingSource(sourceId) {
            var source = this.registry.getSource(sourceId, true);
            (0, _invariant2.default)(source, 'Expected to find a valid source.');

            if (!this.isDragging() || !this.isSourcePublic()) {
              return false;
            }

            var sourceType = this.registry.getSourceType(sourceId);
            var draggedItemType = this.getItemType();
            if (sourceType !== draggedItemType) {
              return false;
            }

            return source.isDragging(this, sourceId);
          }
        }, {
          key: 'isOverTarget',
          value: function isOverTarget(targetId) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { shallow: false };
            var shallow = options.shallow;

            if (!this.isDragging()) {
              return false;
            }

            var targetType = this.registry.getTargetType(targetId);
            var draggedItemType = this.getItemType();
            if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
              return false;
            }

            var targetIds = this.getTargetIds();
            if (!targetIds.length) {
              return false;
            }

            var index = targetIds.indexOf(targetId);
            if (shallow) {
              return index === targetIds.length - 1;
            } else {
              return index > -1;
            }
          }
        }, {
          key: 'getItemType',
          value: function getItemType() {
            return this.store.getState().dragOperation.itemType;
          }
        }, {
          key: 'getItem',
          value: function getItem() {
            return this.store.getState().dragOperation.item;
          }
        }, {
          key: 'getSourceId',
          value: function getSourceId() {
            return this.store.getState().dragOperation.sourceId;
          }
        }, {
          key: 'getTargetIds',
          value: function getTargetIds() {
            return this.store.getState().dragOperation.targetIds;
          }
        }, {
          key: 'getDropResult',
          value: function getDropResult() {
            return this.store.getState().dragOperation.dropResult;
          }
        }, {
          key: 'didDrop',
          value: function didDrop() {
            return this.store.getState().dragOperation.didDrop;
          }
        }, {
          key: 'isSourcePublic',
          value: function isSourcePublic() {
            return this.store.getState().dragOperation.isSourcePublic;
          }
        }, {
          key: 'getInitialClientOffset',
          value: function getInitialClientOffset() {
            return this.store.getState().dragOffset.initialClientOffset;
          }
        }, {
          key: 'getInitialSourceClientOffset',
          value: function getInitialSourceClientOffset() {
            return this.store.getState().dragOffset.initialSourceClientOffset;
          }
        }, {
          key: 'getClientOffset',
          value: function getClientOffset() {
            return this.store.getState().dragOffset.clientOffset;
          }
        }, {
          key: 'getSourceClientOffset',
          value: function getSourceClientOffset() {
            return (0, _dragOffset.getSourceClientOffset)(this.store.getState().dragOffset);
          }
        }, {
          key: 'getDifferenceFromInitialOffset',
          value: function getDifferenceFromInitialOffset() {
            return (0, _dragOffset.getDifferenceFromInitialOffset)(this.store.getState().dragOffset);
          }
        }]);

        return DragDropMonitor;
      }();

      exports.default = DragDropMonitor;

      /***/
    },
    /* 131 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _isArray = __webpack_require__(6);

      var _isArray2 = _interopRequireDefault(_isArray);

      var _asap = __webpack_require__(132);

      var _asap2 = _interopRequireDefault(_asap);

      var _registry = __webpack_require__(16);

      var _getNextUniqueId = __webpack_require__(134);

      var _getNextUniqueId2 = _interopRequireDefault(_getNextUniqueId);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var HandlerRoles = {
        SOURCE: 'SOURCE',
        TARGET: 'TARGET'
      };

      function validateSourceContract(source) {
        (0, _invariant2.default)(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');
        (0, _invariant2.default)(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');
        (0, _invariant2.default)(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');
      }

      function validateTargetContract(target) {
        (0, _invariant2.default)(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');
        (0, _invariant2.default)(typeof target.hover === 'function', 'Expected hover to be a function.');
        (0, _invariant2.default)(typeof target.drop === 'function', 'Expected beginDrag to be a function.');
      }

      function validateType(type, allowArray) {
        if (allowArray && (0, _isArray2.default)(type)) {
          type.forEach(function (t) {
            return validateType(t, false);
          });
          return;
        }

        (0, _invariant2.default)(typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');
      }

      function getNextHandlerId(role) {
        var id = (0, _getNextUniqueId2.default)().toString();
        switch (role) {
          case HandlerRoles.SOURCE:
            return 'S' + id;
          case HandlerRoles.TARGET:
            return 'T' + id;
          default:
            (0, _invariant2.default)(false, 'Unknown role: ' + role);
        }
      }

      function parseRoleFromHandlerId(handlerId) {
        switch (handlerId[0]) {
          case 'S':
            return HandlerRoles.SOURCE;
          case 'T':
            return HandlerRoles.TARGET;
          default:
            (0, _invariant2.default)(false, 'Cannot parse handler ID: ' + handlerId);
        }
      }

      var HandlerRegistry = function () {
        function HandlerRegistry(store) {
          _classCallCheck(this, HandlerRegistry);

          this.store = store;

          this.types = {};
          this.handlers = {};

          this.pinnedSourceId = null;
          this.pinnedSource = null;
        }

        _createClass(HandlerRegistry, [{
          key: 'addSource',
          value: function addSource(type, source) {
            validateType(type);
            validateSourceContract(source);

            var sourceId = this.addHandler(HandlerRoles.SOURCE, type, source);
            this.store.dispatch((0, _registry.addSource)(sourceId));
            return sourceId;
          }
        }, {
          key: 'addTarget',
          value: function addTarget(type, target) {
            validateType(type, true);
            validateTargetContract(target);

            var targetId = this.addHandler(HandlerRoles.TARGET, type, target);
            this.store.dispatch((0, _registry.addTarget)(targetId));
            return targetId;
          }
        }, {
          key: 'addHandler',
          value: function addHandler(role, type, handler) {
            var id = getNextHandlerId(role);
            this.types[id] = type;
            this.handlers[id] = handler;

            return id;
          }
        }, {
          key: 'containsHandler',
          value: function containsHandler(handler) {
            var _this = this;

            return Object.keys(this.handlers).some(function (key) {
              return _this.handlers[key] === handler;
            });
          }
        }, {
          key: 'getSource',
          value: function getSource(sourceId, includePinned) {
            (0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');

            var isPinned = includePinned && sourceId === this.pinnedSourceId;
            var source = isPinned ? this.pinnedSource : this.handlers[sourceId];

            return source;
          }
        }, {
          key: 'getTarget',
          value: function getTarget(targetId) {
            (0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
            return this.handlers[targetId];
          }
        }, {
          key: 'getSourceType',
          value: function getSourceType(sourceId) {
            (0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');
            return this.types[sourceId];
          }
        }, {
          key: 'getTargetType',
          value: function getTargetType(targetId) {
            (0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
            return this.types[targetId];
          }
        }, {
          key: 'isSourceId',
          value: function isSourceId(handlerId) {
            var role = parseRoleFromHandlerId(handlerId);
            return role === HandlerRoles.SOURCE;
          }
        }, {
          key: 'isTargetId',
          value: function isTargetId(handlerId) {
            var role = parseRoleFromHandlerId(handlerId);
            return role === HandlerRoles.TARGET;
          }
        }, {
          key: 'removeSource',
          value: function removeSource(sourceId) {
            var _this2 = this;

            (0, _invariant2.default)(this.getSource(sourceId), 'Expected an existing source.');
            this.store.dispatch((0, _registry.removeSource)(sourceId));

            (0, _asap2.default)(function () {
              delete _this2.handlers[sourceId];
              delete _this2.types[sourceId];
            });
          }
        }, {
          key: 'removeTarget',
          value: function removeTarget(targetId) {
            var _this3 = this;

            (0, _invariant2.default)(this.getTarget(targetId), 'Expected an existing target.');
            this.store.dispatch((0, _registry.removeTarget)(targetId));

            (0, _asap2.default)(function () {
              delete _this3.handlers[targetId];
              delete _this3.types[targetId];
            });
          }
        }, {
          key: 'pinSource',
          value: function pinSource(sourceId) {
            var source = this.getSource(sourceId);
            (0, _invariant2.default)(source, 'Expected an existing source.');

            this.pinnedSourceId = sourceId;
            this.pinnedSource = source;
          }
        }, {
          key: 'unpinSource',
          value: function unpinSource() {
            (0, _invariant2.default)(this.pinnedSource, 'No source is pinned at the time.');

            this.pinnedSourceId = null;
            this.pinnedSource = null;
          }
        }]);

        return HandlerRegistry;
      }();

      exports.default = HandlerRegistry;

      /***/
    },
    /* 132 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      // rawAsap provides everything we need except exception management.

      var rawAsap = __webpack_require__(133);
      // RawTasks are recycled to reduce GC churn.
      var freeTasks = [];
      // We queue errors to ensure they are thrown in right order (FIFO).
      // Array-as-queue is good enough here, since we are just dealing with exceptions.
      var pendingErrors = [];
      var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

      function throwFirstError() {
        if (pendingErrors.length) {
          throw pendingErrors.shift();
        }
      }

      /**
       * Calls a task as soon as possible after returning, in its own event, with priority
       * over other events like animation, reflow, and repaint. An error thrown from an
       * event will not interrupt, nor even substantially slow down the processing of
       * other events, but will be rather postponed to a lower priority event.
       * @param {{call}} task A callable object, typically a function that takes no
       * arguments.
       */
      module.exports = asap;
      function asap(task) {
        var rawTask;
        if (freeTasks.length) {
          rawTask = freeTasks.pop();
        } else {
          rawTask = new RawTask();
        }
        rawTask.task = task;
        rawAsap(rawTask);
      }

      // We wrap tasks with recyclable task objects.  A task object implements
      // `call`, just like a function.
      function RawTask() {
        this.task = null;
      }

      // The sole purpose of wrapping the task is to catch the exception and recycle
      // the task object after its single use.
      RawTask.prototype.call = function () {
        try {
          this.task.call();
        } catch (error) {
          if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
          } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
          }
        } finally {
          this.task = null;
          freeTasks[freeTasks.length] = this;
        }
      };

      /***/
    },
    /* 133 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (global) {

        // Use the fastest means possible to execute a task in its own turn, with
        // priority over other events including IO, animation, reflow, and redraw
        // events in browsers.
        //
        // An exception thrown by a task will permanently interrupt the processing of
        // subsequent tasks. The higher level `asap` function ensures that if an
        // exception is thrown by a task, that the task queue will continue flushing as
        // soon as possible, but if you use `rawAsap` directly, you are responsible to
        // either ensure that no exceptions are thrown from your task, or to manually
        // call `rawAsap.requestFlush` if an exception is thrown.
        module.exports = rawAsap;
        function rawAsap(task) {
          if (!queue.length) {
            requestFlush();
            flushing = true;
          }
          // Equivalent to push, but avoids a function call.
          queue[queue.length] = task;
        }

        var queue = [];
        // Once a flush has been requested, no further calls to `requestFlush` are
        // necessary until the next `flush` completes.
        var flushing = false;
        // `requestFlush` is an implementation-specific method that attempts to kick
        // off a `flush` event as quickly as possible. `flush` will attempt to exhaust
        // the event queue before yielding to the browser's own event loop.
        var requestFlush;
        // The position of the next task to execute in the task queue. This is
        // preserved between calls to `flush` so that it can be resumed if
        // a task throws an exception.
        var index = 0;
        // If a task schedules additional tasks recursively, the task queue can grow
        // unbounded. To prevent memory exhaustion, the task queue will periodically
        // truncate already-completed tasks.
        var capacity = 1024;

        // The flush function processes all tasks that have been scheduled with
        // `rawAsap` unless and until one of those tasks throws an exception.
        // If a task throws an exception, `flush` ensures that its state will remain
        // consistent and will resume where it left off when called again.
        // However, `flush` does not make any arrangements to be called again if an
        // exception is thrown.
        function flush() {
          while (index < queue.length) {
            var currentIndex = index;
            // Advance the index before calling the task. This ensures that we will
            // begin flushing on the next task the task throws an error.
            index = index + 1;
            queue[currentIndex].call();
            // Prevent leaking memory for long chains of recursive calls to `asap`.
            // If we call `asap` within tasks scheduled by `asap`, the queue will
            // grow, but to avoid an O(n) walk for every task we execute, we don't
            // shift tasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 tasks off the queue.
            if (index > capacity) {
              // Manually shift all values starting at the index back to the
              // beginning of the queue.
              for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
              }
              queue.length -= index;
              index = 0;
            }
          }
          queue.length = 0;
          index = 0;
          flushing = false;
        }

        // `requestFlush` is implemented using a strategy based on data collected from
        // every available SauceLabs Selenium web driver worker at time of writing.
        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

        // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
        // have WebKitMutationObserver but not un-prefixed MutationObserver.
        // Must use `global` or `self` instead of `window` to work in both frames and web
        // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

        /* globals self */
        var scope = typeof global !== "undefined" ? global : self;
        var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

        // MutationObservers are desirable because they have high priority and work
        // reliably everywhere they are implemented.
        // They are implemented in all modern browsers.
        //
        // - Android 4-4.3
        // - Chrome 26-34
        // - Firefox 14-29
        // - Internet Explorer 11
        // - iPad Safari 6-7.1
        // - iPhone Safari 7-7.1
        // - Safari 6-7
        if (typeof BrowserMutationObserver === "function") {
          requestFlush = makeRequestCallFromMutationObserver(flush);

          // MessageChannels are desirable because they give direct access to the HTML
          // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
          // 11-12, and in web workers in many engines.
          // Although message channels yield to any queued rendering and IO tasks, they
          // would be better than imposing the 4ms delay of timers.
          // However, they do not work reliably in Internet Explorer or Safari.

          // Internet Explorer 10 is the only browser that has setImmediate but does
          // not have MutationObservers.
          // Although setImmediate yields to the browser's renderer, it would be
          // preferrable to falling back to setTimeout since it does not have
          // the minimum 4ms penalty.
          // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
          // Desktop to a lesser extent) that renders both setImmediate and
          // MessageChannel useless for the purposes of ASAP.
          // https://github.com/kriskowal/q/issues/396

          // Timers are implemented universally.
          // We fall back to timers in workers in most engines, and in foreground
          // contexts in the following browsers.
          // However, note that even this simple case requires nuances to operate in a
          // broad spectrum of browsers.
          //
          // - Firefox 3-13
          // - Internet Explorer 6-9
          // - iPad Safari 4.3
          // - Lynx 2.8.7
        } else {
          requestFlush = makeRequestCallFromTimer(flush);
        }

        // `requestFlush` requests that the high priority event queue be flushed as
        // soon as possible.
        // This is useful to prevent an error thrown in a task from stalling the event
        // queue if the exception handled by Node.js’s
        // `process.on("uncaughtException")` or by a domain.
        rawAsap.requestFlush = requestFlush;

        // To request a high priority event, we induce a mutation observer by toggling
        // the text of a text node between "1" and "-1".
        function makeRequestCallFromMutationObserver(callback) {
          var toggle = 1;
          var observer = new BrowserMutationObserver(callback);
          var node = document.createTextNode("");
          observer.observe(node, { characterData: true });
          return function requestCall() {
            toggle = -toggle;
            node.data = toggle;
          };
        }

        // The message channel technique was discovered by Malte Ubl and was the
        // original foundation for this library.
        // http://www.nonblocking.io/2011/06/windownexttick.html

        // Safari 6.0.5 (at least) intermittently fails to create message ports on a
        // page's first load. Thankfully, this version of Safari supports
        // MutationObservers, so we don't need to fall back in that case.

        // function makeRequestCallFromMessageChannel(callback) {
        //     var channel = new MessageChannel();
        //     channel.port1.onmessage = callback;
        //     return function requestCall() {
        //         channel.port2.postMessage(0);
        //     };
        // }

        // For reasons explained above, we are also unable to use `setImmediate`
        // under any circumstances.
        // Even if we were, there is another bug in Internet Explorer 10.
        // It is not sufficient to assign `setImmediate` to `requestFlush` because
        // `setImmediate` must be called *by name* and therefore must be wrapped in a
        // closure.
        // Never forget.

        // function makeRequestCallFromSetImmediate(callback) {
        //     return function requestCall() {
        //         setImmediate(callback);
        //     };
        // }

        // Safari 6.0 has a problem where timers will get lost while the user is
        // scrolling. This problem does not impact ASAP because Safari 6.0 supports
        // mutation observers, so that implementation is used instead.
        // However, if we ever elect to use timers in Safari, the prevalent work-around
        // is to add a scroll event listener that calls for a flush.

        // `setTimeout` does not call the passed callback if the delay is less than
        // approximately 7 in web workers in Firefox 8 through 18, and sometimes not
        // even then.

        function makeRequestCallFromTimer(callback) {
          return function requestCall() {
            // We dispatch a timeout with a specified delay of 0 for engines that
            // can reliably accommodate that request. This will usually be snapped
            // to a 4 milisecond delay, but once we're flushing, there's no delay
            // between events.
            var timeoutHandle = setTimeout(handleTimer, 0);
            // However, since this timer gets frequently dropped in Firefox
            // workers, we enlist an interval handle that will try to fire
            // an event 20 times per second until it succeeds.
            var intervalHandle = setInterval(handleTimer, 50);

            function handleTimer() {
              // Whichever timer succeeds will cancel both timers and
              // execute the callback.
              clearTimeout(timeoutHandle);
              clearInterval(intervalHandle);
              callback();
            }
          };
        }

        // This is for `asap.js` only.
        // Its name will be periodically randomized to break any code that depends on
        // its existence.
        rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

        // ASAP was originally a nextTick shim included in Q. This was factored out
        // into this ASAP package. It was later adapted to RSVP which made further
        // amendments. These decisions, particularly to marginalize MessageChannel and
        // to capture the MutationObserver implementation in a closure, were integrated
        // back into ASAP proper.
        // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(22));

      /***/
    },
    /* 134 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = getNextUniqueId;
      var nextUniqueId = 0;

      function getNextUniqueId() {
        return nextUniqueId++;
      }

      /***/
    },
    /* 135 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DragSource = function () {
        function DragSource() {
          _classCallCheck(this, DragSource);
        }

        _createClass(DragSource, [{
          key: "canDrag",
          value: function canDrag() {
            return true;
          }
        }, {
          key: "isDragging",
          value: function isDragging(monitor, handle) {
            return handle === monitor.getSourceId();
          }
        }, {
          key: "endDrag",
          value: function endDrag() {}
        }]);

        return DragSource;
      }();

      exports.default = DragSource;

      /***/
    },
    /* 136 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DropTarget = function () {
        function DropTarget() {
          _classCallCheck(this, DropTarget);
        }

        _createClass(DropTarget, [{
          key: "canDrop",
          value: function canDrop() {
            return true;
          }
        }, {
          key: "hover",
          value: function hover() {}
        }, {
          key: "drop",
          value: function drop() {}
        }]);

        return DropTarget;
      }();

      exports.default = DropTarget;

      /***/
    },
    /* 137 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = createBackend;

      var _noop = __webpack_require__(45);

      var _noop2 = _interopRequireDefault(_noop);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var TestBackend = function () {
        function TestBackend(manager) {
          _classCallCheck(this, TestBackend);

          this.actions = manager.getActions();
        }

        _createClass(TestBackend, [{
          key: 'setup',
          value: function setup() {
            this.didCallSetup = true;
          }
        }, {
          key: 'teardown',
          value: function teardown() {
            this.didCallTeardown = true;
          }
        }, {
          key: 'connectDragSource',
          value: function connectDragSource() {
            return _noop2.default;
          }
        }, {
          key: 'connectDragPreview',
          value: function connectDragPreview() {
            return _noop2.default;
          }
        }, {
          key: 'connectDropTarget',
          value: function connectDropTarget() {
            return _noop2.default;
          }
        }, {
          key: 'simulateBeginDrag',
          value: function simulateBeginDrag(sourceIds, options) {
            this.actions.beginDrag(sourceIds, options);
          }
        }, {
          key: 'simulatePublishDragSource',
          value: function simulatePublishDragSource() {
            this.actions.publishDragSource();
          }
        }, {
          key: 'simulateHover',
          value: function simulateHover(targetIds, options) {
            this.actions.hover(targetIds, options);
          }
        }, {
          key: 'simulateDrop',
          value: function simulateDrop() {
            this.actions.drop();
          }
        }, {
          key: 'simulateEndDrag',
          value: function simulateEndDrag() {
            this.actions.endDrag();
          }
        }]);

        return TestBackend;
      }();

      function createBackend(manager) {
        return new TestBackend(manager);
      }

      /***/
    },
    /* 138 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = undefined;

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _class, _temp;

      var _react = __webpack_require__(0);

      var _propTypes = __webpack_require__(8);

      var _propTypes2 = _interopRequireDefault(_propTypes);

      var _DragDropContext = __webpack_require__(37);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      /**
       * This class is a React-Component based version of the DragDropContext.
       * This is an alternative to decorating an application component with an ES7 decorator.
       */
      var DragDropContextProvider = (_temp = _class = function (_Component) {
        _inherits(DragDropContextProvider, _Component);

        function DragDropContextProvider(props, context) {
          _classCallCheck(this, DragDropContextProvider);

          var _this = _possibleConstructorReturn(this, (DragDropContextProvider.__proto__ || Object.getPrototypeOf(DragDropContextProvider)).call(this, props, context));

          _this.backend = (0, _DragDropContext.unpackBackendForEs5Users)(props.backend);
          return _this;
        }

        _createClass(DragDropContextProvider, [{
          key: 'getChildContext',
          value: function getChildContext() {
            var _this2 = this;

            /**
             * This property determines which window global to use for creating the DragDropManager.
             * If a window has been injected explicitly via props, that is used first. If it is available
             * as a context value, then use that, otherwise use the browser global.
             */
            var getWindow = function getWindow() {
              if (_this2.props && _this2.props.window) {
                return _this2.props.window;
              } else if (_this2.context && _this2.context.window) {
                return _this2.context.window;
              } else if (typeof window !== 'undefined') {
                return window;
              }
              return undefined;
            };

            return (0, _DragDropContext.createChildContext)(this.backend, { window: getWindow() });
          }
        }, {
          key: 'render',
          value: function render() {
            return _react.Children.only(this.props.children);
          }
        }]);

        return DragDropContextProvider;
      }(_react.Component), _class.propTypes = {
        backend: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object]).isRequired,
        children: _propTypes2.default.element.isRequired,
        window: _propTypes2.default.object }, _class.defaultProps = {
        window: undefined
      }, _class.childContextTypes = _DragDropContext.CHILD_CONTEXT_TYPES, _class.displayName = 'DragDropContextProvider', _class.contextTypes = {
        window: _propTypes2.default.object
      }, _temp);
      exports.default = DragDropContextProvider;

      /***/
    },
    /* 139 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = DragSource;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _isPlainObject = __webpack_require__(2);

      var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

      var _checkDecoratorArguments = __webpack_require__(17);

      var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

      var _decorateHandler = __webpack_require__(49);

      var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

      var _registerSource = __webpack_require__(144);

      var _registerSource2 = _interopRequireDefault(_registerSource);

      var _createSourceFactory = __webpack_require__(145);

      var _createSourceFactory2 = _interopRequireDefault(_createSourceFactory);

      var _createSourceMonitor = __webpack_require__(146);

      var _createSourceMonitor2 = _interopRequireDefault(_createSourceMonitor);

      var _createSourceConnector = __webpack_require__(147);

      var _createSourceConnector2 = _interopRequireDefault(_createSourceConnector);

      var _isValidType = __webpack_require__(52);

      var _isValidType2 = _interopRequireDefault(_isValidType);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function DragSource(type, spec, collect) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        _checkDecoratorArguments2.default.apply(undefined, ['DragSource', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
        var getType = type;
        if (typeof type !== 'function') {
          (0, _invariant2.default)((0, _isValidType2.default)(type), 'Expected "type" provided as the first argument to DragSource to be ' + 'a string, or a function that returns a string given the current props. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', type);
          getType = function getType() {
            return type;
          };
        }
        (0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DragSource to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', spec);
        var createSource = (0, _createSourceFactory2.default)(spec);
        (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DragSource to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);
        (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DragSource to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);

        return function decorateSource(DecoratedComponent) {
          return (0, _decorateHandler2.default)({
            connectBackend: function connectBackend(backend, sourceId) {
              return backend.connectDragSource(sourceId);
            },
            containerDisplayName: 'DragSource',
            createHandler: createSource,
            registerHandler: _registerSource2.default,
            createMonitor: _createSourceMonitor2.default,
            createConnector: _createSourceConnector2.default,
            DecoratedComponent: DecoratedComponent,
            getType: getType,
            collect: collect,
            options: options
          });
        };
      }

      /***/
    },
    /* 140 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _interopRequireWildcard = function _interopRequireWildcard(obj) {
        return obj && obj.__esModule ? obj : { 'default': obj };
      };

      exports.__esModule = true;

      var _isDisposable2 = __webpack_require__(33);

      var _isDisposable3 = _interopRequireWildcard(_isDisposable2);

      exports.isDisposable = _isDisposable3['default'];

      var _Disposable2 = __webpack_require__(141);

      var _Disposable3 = _interopRequireWildcard(_Disposable2);

      exports.Disposable = _Disposable3['default'];

      var _CompositeDisposable2 = __webpack_require__(142);

      var _CompositeDisposable3 = _interopRequireWildcard(_CompositeDisposable2);

      exports.CompositeDisposable = _CompositeDisposable3['default'];

      var _SerialDisposable2 = __webpack_require__(143);

      var _SerialDisposable3 = _interopRequireWildcard(_SerialDisposable2);

      exports.SerialDisposable = _SerialDisposable3['default'];

      /***/
    },
    /* 141 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _classCallCheck = function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.__esModule = true;
      var noop = function noop() {};

      /**
       * The basic disposable.
       */

      var Disposable = function () {
        function Disposable(action) {
          _classCallCheck(this, Disposable);

          this.isDisposed = false;
          this.action = action || noop;
        }

        Disposable.prototype.dispose = function dispose() {
          if (!this.isDisposed) {
            this.action.call(null);
            this.isDisposed = true;
          }
        };

        _createClass(Disposable, null, [{
          key: "empty",
          enumerable: true,
          value: { dispose: noop }
        }]);

        return Disposable;
      }();

      exports["default"] = Disposable;
      module.exports = exports["default"];

      /***/
    },
    /* 142 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _interopRequireWildcard = function _interopRequireWildcard(obj) {
        return obj && obj.__esModule ? obj : { 'default': obj };
      };

      var _classCallCheck = function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      };

      exports.__esModule = true;

      var _isDisposable = __webpack_require__(33);

      var _isDisposable2 = _interopRequireWildcard(_isDisposable);

      /**
       * Represents a group of disposable resources that are disposed together.
       */

      var CompositeDisposable = function () {
        function CompositeDisposable() {
          for (var _len = arguments.length, disposables = Array(_len), _key = 0; _key < _len; _key++) {
            disposables[_key] = arguments[_key];
          }

          _classCallCheck(this, CompositeDisposable);

          if (Array.isArray(disposables[0]) && disposables.length === 1) {
            disposables = disposables[0];
          }

          for (var i = 0; i < disposables.length; i++) {
            if (!_isDisposable2['default'](disposables[i])) {
              throw new Error('Expected a disposable');
            }
          }

          this.disposables = disposables;
          this.isDisposed = false;
        }

        /**
         * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
         * @param {Disposable} item Disposable to add.
         */

        CompositeDisposable.prototype.add = function add(item) {
          if (this.isDisposed) {
            item.dispose();
          } else {
            this.disposables.push(item);
          }
        };

        /**
         * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
         * @param {Disposable} item Disposable to remove.
         * @returns {Boolean} true if found; false otherwise.
         */

        CompositeDisposable.prototype.remove = function remove(item) {
          if (this.isDisposed) {
            return false;
          }

          var index = this.disposables.indexOf(item);
          if (index === -1) {
            return false;
          }

          this.disposables.splice(index, 1);
          item.dispose();
          return true;
        };

        /**
         * Disposes all disposables in the group and removes them from the group.
         */

        CompositeDisposable.prototype.dispose = function dispose() {
          if (this.isDisposed) {
            return;
          }

          var len = this.disposables.length;
          var currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }

          this.isDisposed = true;
          this.disposables = [];
          this.length = 0;

          for (var i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        };

        return CompositeDisposable;
      }();

      exports['default'] = CompositeDisposable;
      module.exports = exports['default'];

      /***/
    },
    /* 143 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _interopRequireWildcard = function _interopRequireWildcard(obj) {
        return obj && obj.__esModule ? obj : { 'default': obj };
      };

      var _classCallCheck = function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      };

      exports.__esModule = true;

      var _isDisposable = __webpack_require__(33);

      var _isDisposable2 = _interopRequireWildcard(_isDisposable);

      var SerialDisposable = function () {
        function SerialDisposable() {
          _classCallCheck(this, SerialDisposable);

          this.isDisposed = false;
          this.current = null;
        }

        /**
         * Gets the underlying disposable.
         * @return The underlying disposable.
         */

        SerialDisposable.prototype.getDisposable = function getDisposable() {
          return this.current;
        };

        /**
         * Sets the underlying disposable.
         * @param {Disposable} value The new underlying disposable.
         */

        SerialDisposable.prototype.setDisposable = function setDisposable() {
          var value = arguments[0] === undefined ? null : arguments[0];

          if (value != null && !_isDisposable2['default'](value)) {
            throw new Error('Expected either an empty value or a valid disposable');
          }

          var isDisposed = this.isDisposed;
          var previous = undefined;

          if (!isDisposed) {
            previous = this.current;
            this.current = value;
          }

          if (previous) {
            previous.dispose();
          }

          if (isDisposed && value) {
            value.dispose();
          }
        };

        /**
         * Disposes the underlying disposable as well as all future replacements.
         */

        SerialDisposable.prototype.dispose = function dispose() {
          if (this.isDisposed) {
            return;
          }

          this.isDisposed = true;
          var previous = this.current;
          this.current = null;

          if (previous) {
            previous.dispose();
          }
        };

        return SerialDisposable;
      }();

      exports['default'] = SerialDisposable;
      module.exports = exports['default'];

      /***/
    },
    /* 144 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = registerSource;
      function registerSource(type, source, manager) {
        var registry = manager.getRegistry();
        var sourceId = registry.addSource(type, source);

        function unregisterSource() {
          registry.removeSource(sourceId);
        }

        return {
          handlerId: sourceId,
          unregister: unregisterSource
        };
      }

      /***/
    },
    /* 145 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        exports.default = createSourceFactory;

        var _invariant = __webpack_require__(1);

        var _invariant2 = _interopRequireDefault(_invariant);

        var _isPlainObject = __webpack_require__(2);

        var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var ALLOWED_SPEC_METHODS = ['canDrag', 'beginDrag', 'isDragging', 'endDrag'];
        var REQUIRED_SPEC_METHODS = ['beginDrag'];

        function createSourceFactory(spec) {
          Object.keys(spec).forEach(function (key) {
            (0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', ALLOWED_SPEC_METHODS.join(', '), key);
            (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
          });
          REQUIRED_SPEC_METHODS.forEach(function (key) {
            (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
          });

          var Source = function () {
            function Source(monitor) {
              _classCallCheck(this, Source);

              this.monitor = monitor;
              this.props = null;
              this.component = null;
            }

            _createClass(Source, [{
              key: 'receiveProps',
              value: function receiveProps(props) {
                this.props = props;
              }
            }, {
              key: 'receiveComponent',
              value: function receiveComponent(component) {
                this.component = component;
              }
            }, {
              key: 'canDrag',
              value: function canDrag() {
                if (!spec.canDrag) {
                  return true;
                }

                return spec.canDrag(this.props, this.monitor);
              }
            }, {
              key: 'isDragging',
              value: function isDragging(globalMonitor, sourceId) {
                if (!spec.isDragging) {
                  return sourceId === globalMonitor.getSourceId();
                }

                return spec.isDragging(this.props, this.monitor);
              }
            }, {
              key: 'beginDrag',
              value: function beginDrag() {
                var item = spec.beginDrag(this.props, this.monitor, this.component);
                if (process.env.NODE_ENV !== 'production') {
                  (0, _invariant2.default)((0, _isPlainObject2.default)(item), 'beginDrag() must return a plain object that represents the dragged item. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', item);
                }
                return item;
              }
            }, {
              key: 'endDrag',
              value: function endDrag() {
                if (!spec.endDrag) {
                  return;
                }

                spec.endDrag(this.props, this.monitor, this.component);
              }
            }]);

            return Source;
          }();

          return function createSource(monitor) {
            return new Source(monitor);
          };
        }
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 146 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = createSourceMonitor;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var isCallingCanDrag = false;
      var isCallingIsDragging = false;

      var SourceMonitor = function () {
        function SourceMonitor(manager) {
          _classCallCheck(this, SourceMonitor);

          this.internalMonitor = manager.getMonitor();
        }

        _createClass(SourceMonitor, [{
          key: 'receiveHandlerId',
          value: function receiveHandlerId(sourceId) {
            this.sourceId = sourceId;
          }
        }, {
          key: 'canDrag',
          value: function canDrag() {
            (0, _invariant2.default)(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

            try {
              isCallingCanDrag = true;
              return this.internalMonitor.canDragSource(this.sourceId);
            } finally {
              isCallingCanDrag = false;
            }
          }
        }, {
          key: 'isDragging',
          value: function isDragging() {
            (0, _invariant2.default)(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

            try {
              isCallingIsDragging = true;
              return this.internalMonitor.isDraggingSource(this.sourceId);
            } finally {
              isCallingIsDragging = false;
            }
          }
        }, {
          key: 'getItemType',
          value: function getItemType() {
            return this.internalMonitor.getItemType();
          }
        }, {
          key: 'getItem',
          value: function getItem() {
            return this.internalMonitor.getItem();
          }
        }, {
          key: 'getDropResult',
          value: function getDropResult() {
            return this.internalMonitor.getDropResult();
          }
        }, {
          key: 'didDrop',
          value: function didDrop() {
            return this.internalMonitor.didDrop();
          }
        }, {
          key: 'getInitialClientOffset',
          value: function getInitialClientOffset() {
            return this.internalMonitor.getInitialClientOffset();
          }
        }, {
          key: 'getInitialSourceClientOffset',
          value: function getInitialSourceClientOffset() {
            return this.internalMonitor.getInitialSourceClientOffset();
          }
        }, {
          key: 'getSourceClientOffset',
          value: function getSourceClientOffset() {
            return this.internalMonitor.getSourceClientOffset();
          }
        }, {
          key: 'getClientOffset',
          value: function getClientOffset() {
            return this.internalMonitor.getClientOffset();
          }
        }, {
          key: 'getDifferenceFromInitialOffset',
          value: function getDifferenceFromInitialOffset() {
            return this.internalMonitor.getDifferenceFromInitialOffset();
          }
        }]);

        return SourceMonitor;
      }();

      function createSourceMonitor(manager) {
        return new SourceMonitor(manager);
      }

      /***/
    },
    /* 147 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createSourceConnector;

      var _wrapConnectorHooks = __webpack_require__(50);

      var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

      var _areOptionsEqual = __webpack_require__(51);

      var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function createSourceConnector(backend) {
        var currentHandlerId = void 0;

        var currentDragSourceNode = void 0;
        var currentDragSourceOptions = void 0;
        var disconnectCurrentDragSource = void 0;

        var currentDragPreviewNode = void 0;
        var currentDragPreviewOptions = void 0;
        var disconnectCurrentDragPreview = void 0;

        function reconnectDragSource() {
          if (disconnectCurrentDragSource) {
            disconnectCurrentDragSource();
            disconnectCurrentDragSource = null;
          }

          if (currentHandlerId && currentDragSourceNode) {
            disconnectCurrentDragSource = backend.connectDragSource(currentHandlerId, currentDragSourceNode, currentDragSourceOptions);
          }
        }

        function reconnectDragPreview() {
          if (disconnectCurrentDragPreview) {
            disconnectCurrentDragPreview();
            disconnectCurrentDragPreview = null;
          }

          if (currentHandlerId && currentDragPreviewNode) {
            disconnectCurrentDragPreview = backend.connectDragPreview(currentHandlerId, currentDragPreviewNode, currentDragPreviewOptions);
          }
        }

        function receiveHandlerId(handlerId) {
          if (handlerId === currentHandlerId) {
            return;
          }

          currentHandlerId = handlerId;
          reconnectDragSource();
          reconnectDragPreview();
        }

        var hooks = (0, _wrapConnectorHooks2.default)({
          dragSource: function connectDragSource(node, options) {
            if (node === currentDragSourceNode && (0, _areOptionsEqual2.default)(options, currentDragSourceOptions)) {
              return;
            }

            currentDragSourceNode = node;
            currentDragSourceOptions = options;

            reconnectDragSource();
          },

          dragPreview: function connectDragPreview(node, options) {
            if (node === currentDragPreviewNode && (0, _areOptionsEqual2.default)(options, currentDragPreviewOptions)) {
              return;
            }

            currentDragPreviewNode = node;
            currentDragPreviewOptions = options;

            reconnectDragPreview();
          }
        });

        return {
          receiveHandlerId: receiveHandlerId,
          hooks: hooks
        };
      }

      /***/
    },
    /* 148 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneWithRef;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _react = __webpack_require__(0);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function cloneWithRef(element, newRef) {
        var previousRef = element.ref;
        (0, _invariant2.default)(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute');

        if (!previousRef) {
          // When there is no ref on the element, use the new ref directly
          return (0, _react.cloneElement)(element, {
            ref: newRef
          });
        }

        return (0, _react.cloneElement)(element, {
          ref: function ref(node) {
            newRef(node);

            if (previousRef) {
              previousRef(node);
            }
          }
        });
      }

      /***/
    },
    /* 149 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = DropTarget;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      var _isPlainObject = __webpack_require__(2);

      var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

      var _checkDecoratorArguments = __webpack_require__(17);

      var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

      var _decorateHandler = __webpack_require__(49);

      var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

      var _registerTarget = __webpack_require__(150);

      var _registerTarget2 = _interopRequireDefault(_registerTarget);

      var _createTargetFactory = __webpack_require__(151);

      var _createTargetFactory2 = _interopRequireDefault(_createTargetFactory);

      var _createTargetMonitor = __webpack_require__(152);

      var _createTargetMonitor2 = _interopRequireDefault(_createTargetMonitor);

      var _createTargetConnector = __webpack_require__(153);

      var _createTargetConnector2 = _interopRequireDefault(_createTargetConnector);

      var _isValidType = __webpack_require__(52);

      var _isValidType2 = _interopRequireDefault(_isValidType);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function DropTarget(type, spec, collect) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        _checkDecoratorArguments2.default.apply(undefined, ['DropTarget', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
        var getType = type;
        if (typeof type !== 'function') {
          (0, _invariant2.default)((0, _isValidType2.default)(type, true), 'Expected "type" provided as the first argument to DropTarget to be ' + 'a string, an array of strings, or a function that returns either given ' + 'the current props. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', type);
          getType = function getType() {
            return type;
          };
        }
        (0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DropTarget to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', spec);
        var createTarget = (0, _createTargetFactory2.default)(spec);
        (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DropTarget to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);
        (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DropTarget to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);

        return function decorateTarget(DecoratedComponent) {
          return (0, _decorateHandler2.default)({
            connectBackend: function connectBackend(backend, targetId) {
              return backend.connectDropTarget(targetId);
            },
            containerDisplayName: 'DropTarget',
            createHandler: createTarget,
            registerHandler: _registerTarget2.default,
            createMonitor: _createTargetMonitor2.default,
            createConnector: _createTargetConnector2.default,
            DecoratedComponent: DecoratedComponent,
            getType: getType,
            collect: collect,
            options: options
          });
        };
      }

      /***/
    },
    /* 150 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = registerTarget;
      function registerTarget(type, target, manager) {
        var registry = manager.getRegistry();
        var targetId = registry.addTarget(type, target);

        function unregisterTarget() {
          registry.removeTarget(targetId);
        }

        return {
          handlerId: targetId,
          unregister: unregisterTarget
        };
      }

      /***/
    },
    /* 151 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        exports.default = createTargetFactory;

        var _invariant = __webpack_require__(1);

        var _invariant2 = _interopRequireDefault(_invariant);

        var _isPlainObject = __webpack_require__(2);

        var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var ALLOWED_SPEC_METHODS = ['canDrop', 'hover', 'drop'];

        function createTargetFactory(spec) {
          Object.keys(spec).forEach(function (key) {
            (0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drop target specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', ALLOWED_SPEC_METHODS.join(', '), key);
            (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drop target specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', key, key, spec[key]);
          });

          var Target = function () {
            function Target(monitor) {
              _classCallCheck(this, Target);

              this.monitor = monitor;
              this.props = null;
              this.component = null;
            }

            _createClass(Target, [{
              key: 'receiveProps',
              value: function receiveProps(props) {
                this.props = props;
              }
            }, {
              key: 'receiveMonitor',
              value: function receiveMonitor(monitor) {
                this.monitor = monitor;
              }
            }, {
              key: 'receiveComponent',
              value: function receiveComponent(component) {
                this.component = component;
              }
            }, {
              key: 'canDrop',
              value: function canDrop() {
                if (!spec.canDrop) {
                  return true;
                }

                return spec.canDrop(this.props, this.monitor);
              }
            }, {
              key: 'hover',
              value: function hover() {
                if (!spec.hover) {
                  return;
                }

                spec.hover(this.props, this.monitor, this.component);
              }
            }, {
              key: 'drop',
              value: function drop() {
                if (!spec.drop) {
                  return undefined;
                }

                var dropResult = spec.drop(this.props, this.monitor, this.component);
                if (process.env.NODE_ENV !== 'production') {
                  (0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isPlainObject2.default)(dropResult), 'drop() must either return undefined, or an object that represents the drop result. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', dropResult);
                }
                return dropResult;
              }
            }]);

            return Target;
          }();

          return function createTarget(monitor) {
            return new Target(monitor);
          };
        }
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 152 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = createTargetMonitor;

      var _invariant = __webpack_require__(1);

      var _invariant2 = _interopRequireDefault(_invariant);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var isCallingCanDrop = false;

      var TargetMonitor = function () {
        function TargetMonitor(manager) {
          _classCallCheck(this, TargetMonitor);

          this.internalMonitor = manager.getMonitor();
        }

        _createClass(TargetMonitor, [{
          key: 'receiveHandlerId',
          value: function receiveHandlerId(targetId) {
            this.targetId = targetId;
          }
        }, {
          key: 'canDrop',
          value: function canDrop() {
            (0, _invariant2.default)(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html');

            try {
              isCallingCanDrop = true;
              return this.internalMonitor.canDropOnTarget(this.targetId);
            } finally {
              isCallingCanDrop = false;
            }
          }
        }, {
          key: 'isOver',
          value: function isOver(options) {
            return this.internalMonitor.isOverTarget(this.targetId, options);
          }
        }, {
          key: 'getItemType',
          value: function getItemType() {
            return this.internalMonitor.getItemType();
          }
        }, {
          key: 'getItem',
          value: function getItem() {
            return this.internalMonitor.getItem();
          }
        }, {
          key: 'getDropResult',
          value: function getDropResult() {
            return this.internalMonitor.getDropResult();
          }
        }, {
          key: 'didDrop',
          value: function didDrop() {
            return this.internalMonitor.didDrop();
          }
        }, {
          key: 'getInitialClientOffset',
          value: function getInitialClientOffset() {
            return this.internalMonitor.getInitialClientOffset();
          }
        }, {
          key: 'getInitialSourceClientOffset',
          value: function getInitialSourceClientOffset() {
            return this.internalMonitor.getInitialSourceClientOffset();
          }
        }, {
          key: 'getSourceClientOffset',
          value: function getSourceClientOffset() {
            return this.internalMonitor.getSourceClientOffset();
          }
        }, {
          key: 'getClientOffset',
          value: function getClientOffset() {
            return this.internalMonitor.getClientOffset();
          }
        }, {
          key: 'getDifferenceFromInitialOffset',
          value: function getDifferenceFromInitialOffset() {
            return this.internalMonitor.getDifferenceFromInitialOffset();
          }
        }]);

        return TargetMonitor;
      }();

      function createTargetMonitor(manager) {
        return new TargetMonitor(manager);
      }

      /***/
    },
    /* 153 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createTargetConnector;

      var _wrapConnectorHooks = __webpack_require__(50);

      var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

      var _areOptionsEqual = __webpack_require__(51);

      var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function createTargetConnector(backend) {
        var currentHandlerId = void 0;

        var currentDropTargetNode = void 0;
        var currentDropTargetOptions = void 0;
        var disconnectCurrentDropTarget = void 0;

        function reconnectDropTarget() {
          if (disconnectCurrentDropTarget) {
            disconnectCurrentDropTarget();
            disconnectCurrentDropTarget = null;
          }

          if (currentHandlerId && currentDropTargetNode) {
            disconnectCurrentDropTarget = backend.connectDropTarget(currentHandlerId, currentDropTargetNode, currentDropTargetOptions);
          }
        }

        function receiveHandlerId(handlerId) {
          if (handlerId === currentHandlerId) {
            return;
          }

          currentHandlerId = handlerId;
          reconnectDropTarget();
        }

        var hooks = (0, _wrapConnectorHooks2.default)({
          dropTarget: function connectDropTarget(node, options) {
            if (node === currentDropTargetNode && (0, _areOptionsEqual2.default)(options, currentDropTargetOptions)) {
              return;
            }

            currentDropTargetNode = node;
            currentDropTargetOptions = options;

            reconnectDropTarget();
          }
        });

        return {
          receiveHandlerId: receiveHandlerId,
          hooks: hooks
        };
      }

      /***/
    },
    /* 154 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /**
       * Copyright 2015, Yahoo Inc.
       * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
       */

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TouchBackend = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = createTouchBackend;

      var _invariant = __webpack_require__(155);

      var _invariant2 = _interopRequireDefault(_invariant);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function getEventClientTouchOffset(e) {
        if (e.targetTouches.length === 1) {
          return getEventClientOffset(e.targetTouches[0]);
        }
      }

      function getEventClientOffset(e) {
        if (e.targetTouches) {
          return getEventClientTouchOffset(e);
        } else {
          return {
            x: e.clientX,
            y: e.clientY
          };
        }
      }

      // Polyfill for document.elementsFromPoint
      var elementsFromPoint = (typeof document !== 'undefined' && document.elementsFromPoint || function (x, y) {

        if (document.msElementsFromPoint) {
          // msElementsFromPoint is much faster but returns a node-list, so convert it to an array
          return Array.prototype.slice.call(document.msElementsFromPoint(x, y), 0);
        }

        var elements = [],
            previousPointerEvents = [],
            current,
            i,
            d;

        // get all elements via elementFromPoint, and remove them from hit-testing in order
        while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null) {

          // push the element and its current style
          elements.push(current);
          previousPointerEvents.push({
            value: current.style.getPropertyValue('pointer-events'),
            priority: current.style.getPropertyPriority('pointer-events')
          });

          // add "pointer-events: none", to get to the underlying element
          current.style.setProperty('pointer-events', 'none', 'important');
        }

        // restore the previous pointer-events values
        for (i = previousPointerEvents.length; d = previousPointerEvents[--i];) {
          elements[i].style.setProperty('pointer-events', d.value ? d.value : '', d.priority);
        }

        // return our results
        return elements;
      }).bind(typeof document !== 'undefined' ? document : null);

      var supportsPassive = function () {
        // simular to jQuery's test
        var supported = false;
        try {
          addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get: function get() {
              supported = true;
            }
          }));
        } catch (e) {}
        return supported;
      }();

      var ELEMENT_NODE = 1;
      function getNodeClientOffset(node) {
        var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;

        if (!el) {
          return null;
        }

        var _el$getBoundingClient = el.getBoundingClientRect(),
            top = _el$getBoundingClient.top,
            left = _el$getBoundingClient.left;

        return { x: left, y: top };
      }

      var eventNames = {
        mouse: {
          start: 'mousedown',
          move: 'mousemove',
          end: 'mouseup',
          contextmenu: 'contextmenu'
        },
        touch: {
          start: 'touchstart',
          move: 'touchmove',
          end: 'touchend'
        },
        keyboard: {
          keydown: 'keydown'
        }
      };

      var TouchBackend = exports.TouchBackend = function () {
        function TouchBackend(manager) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck(this, TouchBackend);

          options.delayTouchStart = options.delayTouchStart || options.delay;

          options = _extends({
            enableTouchEvents: true,
            enableMouseEvents: false,
            enableKeyboardEvents: false,
            delayTouchStart: 0,
            delayMouseStart: 0
          }, options);

          this.actions = manager.getActions();
          this.monitor = manager.getMonitor();
          this.registry = manager.getRegistry();

          this.enableKeyboardEvents = options.enableKeyboardEvents;
          this.enableMouseEvents = options.enableMouseEvents;
          this.delayTouchStart = options.delayTouchStart;
          this.delayMouseStart = options.delayMouseStart;
          this.sourceNodes = {};
          this.sourceNodeOptions = {};
          this.sourcePreviewNodes = {};
          this.sourcePreviewNodeOptions = {};
          this.targetNodes = {};
          this.targetNodeOptions = {};
          this.listenerTypes = [];
          this._mouseClientOffset = {};

          if (options.enableMouseEvents) {
            this.listenerTypes.push('mouse');
          }

          if (options.enableTouchEvents) {
            this.listenerTypes.push('touch');
          }

          if (options.enableKeyboardEvents) {
            this.listenerTypes.push('keyboard');
          }

          this.getSourceClientOffset = this.getSourceClientOffset.bind(this);
          this.handleTopMoveStart = this.handleTopMoveStart.bind(this);
          this.handleTopMoveStartDelay = this.handleTopMoveStartDelay.bind(this);
          this.handleTopMoveStartCapture = this.handleTopMoveStartCapture.bind(this);
          this.handleTopMoveCapture = this.handleTopMoveCapture.bind(this);
          this.handleTopMove = this.handleTopMove.bind(this);
          this.handleTopMoveEndCapture = this.handleTopMoveEndCapture.bind(this);
          this.handleCancelOnEscape = this.handleCancelOnEscape.bind(this);
        }

        _createClass(TouchBackend, [{
          key: 'setup',
          value: function setup() {
            if (typeof window === 'undefined') {
              return;
            }

            (0, _invariant2.default)(!this.constructor.isSetUp, 'Cannot have two Touch backends at the same time.');
            this.constructor.isSetUp = true;

            this.addEventListener(window, 'start', this.getTopMoveStartHandler());
            this.addEventListener(window, 'start', this.handleTopMoveStartCapture, true);
            this.addEventListener(window, 'move', this.handleTopMove);
            this.addEventListener(window, 'move', this.handleTopMoveCapture, true);
            this.addEventListener(window, 'end', this.handleTopMoveEndCapture, true);

            if (this.enableMouseEvents) {
              this.addEventListener(window, 'contextmenu', this.handleTopMoveEndCapture);
            }

            if (this.enableKeyboardEvents) {
              this.addEventListener(window, 'keydown', this.handleCancelOnEscape, true);
            }
          }
        }, {
          key: 'teardown',
          value: function teardown() {
            if (typeof window === 'undefined') {
              return;
            }

            this.constructor.isSetUp = false;
            this._mouseClientOffset = {};

            this.removeEventListener(window, 'start', this.handleTopMoveStartCapture, true);
            this.removeEventListener(window, 'start', this.handleTopMoveStart);
            this.removeEventListener(window, 'move', this.handleTopMoveCapture, true);
            this.removeEventListener(window, 'move', this.handleTopMove);
            this.removeEventListener(window, 'end', this.handleTopMoveEndCapture, true);

            if (this.enableMouseEvents) {
              this.removeEventListener(window, 'contextmenu', this.handleTopMoveEndCapture);
            }

            if (this.enableKeyboardEvents) {
              this.removeEventListener(window, 'keydown', this.handleCancelOnEscape, true);
            }

            this.uninstallSourceNodeRemovalObserver();
          }
        }, {
          key: 'addEventListener',
          value: function addEventListener(subject, event, handler, capture) {
            var options = supportsPassive ? { capture: capture, passive: false } : capture;

            this.listenerTypes.forEach(function (listenerType) {
              subject.addEventListener(eventNames[listenerType][event], handler, options);
            });
          }
        }, {
          key: 'removeEventListener',
          value: function removeEventListener(subject, event, handler, capture) {
            var options = supportsPassive ? { capture: capture, passive: false } : capture;

            this.listenerTypes.forEach(function (listenerType) {
              subject.removeEventListener(eventNames[listenerType][event], handler, options);
            });
          }
        }, {
          key: 'connectDragSource',
          value: function connectDragSource(sourceId, node, options) {
            var _this = this;

            var handleMoveStart = this.handleMoveStart.bind(this, sourceId);
            this.sourceNodes[sourceId] = node;

            this.addEventListener(node, 'start', handleMoveStart);

            return function () {
              delete _this.sourceNodes[sourceId];
              _this.removeEventListener(node, 'start', handleMoveStart);
            };
          }
        }, {
          key: 'connectDragPreview',
          value: function connectDragPreview(sourceId, node, options) {
            var _this2 = this;

            this.sourcePreviewNodeOptions[sourceId] = options;
            this.sourcePreviewNodes[sourceId] = node;

            return function () {
              delete _this2.sourcePreviewNodes[sourceId];
              delete _this2.sourcePreviewNodeOptions[sourceId];
            };
          }
        }, {
          key: 'connectDropTarget',
          value: function connectDropTarget(targetId, node) {
            var _this3 = this;

            var handleMove = function handleMove(e) {
              var coords = void 0;

              /**
               * Grab the coordinates for the current mouse/touch position
               */
              switch (e.type) {
                case eventNames.mouse.move:
                  coords = { x: e.clientX, y: e.clientY };
                  break;

                case eventNames.touch.move:
                  coords = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                  break;
              }

              /**
               * Use the coordinates to grab the element the drag ended on.
               * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.
               */
              var droppedOn = document.elementFromPoint(coords.x, coords.y);
              var childMatch = node.contains(droppedOn);

              if (droppedOn === node || childMatch) {
                return _this3.handleMove(e, targetId);
              }
            };

            /**
             * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.
             */
            this.addEventListener(document.querySelector('body'), 'move', handleMove);
            this.targetNodes[targetId] = node;

            return function () {
              delete _this3.targetNodes[targetId];
              _this3.removeEventListener(document.querySelector('body'), 'move', handleMove);
            };
          }
        }, {
          key: 'getSourceClientOffset',
          value: function getSourceClientOffset(sourceId) {
            return getNodeClientOffset(this.sourceNodes[sourceId]);
          }
        }, {
          key: 'handleTopMoveStartCapture',
          value: function handleTopMoveStartCapture(e) {
            this.moveStartSourceIds = [];
          }
        }, {
          key: 'handleMoveStart',
          value: function handleMoveStart(sourceId) {
            this.moveStartSourceIds.unshift(sourceId);
          }
        }, {
          key: 'getTopMoveStartHandler',
          value: function getTopMoveStartHandler() {
            if (!this.delayTouchStart && !this.delayMouseStart) {
              return this.handleTopMoveStart;
            }

            return this.handleTopMoveStartDelay;
          }
        }, {
          key: 'handleTopMoveStart',
          value: function handleTopMoveStart(e) {
            // Don't prematurely preventDefault() here since it might:
            // 1. Mess up scrolling
            // 2. Mess up long tap (which brings up context menu)
            // 3. If there's an anchor link as a child, tap won't be triggered on link

            var clientOffset = getEventClientOffset(e);
            if (clientOffset) {
              this._mouseClientOffset = clientOffset;
            }
          }
        }, {
          key: 'handleTopMoveStartDelay',
          value: function handleTopMoveStartDelay(e) {
            var delay = e.type === eventNames.touch.start ? this.delayTouchStart : this.delayMouseStart;
            this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);
          }
        }, {
          key: 'handleTopMoveCapture',
          value: function handleTopMoveCapture(e) {
            this.dragOverTargetIds = [];
          }
        }, {
          key: 'handleMove',
          value: function handleMove(e, targetId) {
            this.dragOverTargetIds.unshift(targetId);
          }
        }, {
          key: 'handleTopMove',
          value: function handleTopMove(e) {
            var _this4 = this;

            clearTimeout(this.timeout);

            var moveStartSourceIds = this.moveStartSourceIds,
                dragOverTargetIds = this.dragOverTargetIds;

            var clientOffset = getEventClientOffset(e);

            if (!clientOffset) {
              return;
            }

            // If we're not dragging and we've moved a little, that counts as a drag start
            if (!this.monitor.isDragging() && this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && (this._mouseClientOffset.x !== clientOffset.x || this._mouseClientOffset.y !== clientOffset.y)) {
              this.moveStartSourceIds = null;
              this.actions.beginDrag(moveStartSourceIds, {
                clientOffset: this._mouseClientOffset,
                getSourceClientOffset: this.getSourceClientOffset,
                publishSource: false
              });
            }

            if (!this.monitor.isDragging()) {
              return;
            }

            var sourceNode = this.sourceNodes[this.monitor.getSourceId()];
            this.installSourceNodeRemovalObserver(sourceNode);
            this.actions.publishDragSource();

            e.preventDefault();

            // Get the node elements of the hovered DropTargets
            var dragOverTargetNodes = dragOverTargetIds.map(function (key) {
              return _this4.targetNodes[key];
            });
            // Get the a ordered list of nodes that are touched by
            var elementsAtPoint = elementsFromPoint(clientOffset.x, clientOffset.y);
            var orderedDragOverTargetIds = elementsAtPoint
            // Filter off nodes that arent a hovered DropTargets nodes
            .filter(function (node) {
              return dragOverTargetNodes.indexOf(node) > -1;
            })
            // Map back the nodes elements to targetIds
            .map(function (node) {
              for (var targetId in _this4.targetNodes) {
                if (node === _this4.targetNodes[targetId]) return targetId;
              }
              return null;
            })
            // Filter off possible null rows
            .filter(function (node) {
              return !!node;
            });

            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods
            orderedDragOverTargetIds.reverse();

            this.actions.hover(orderedDragOverTargetIds, {
              clientOffset: clientOffset
            });
          }
        }, {
          key: 'handleTopMoveEndCapture',
          value: function handleTopMoveEndCapture(e) {
            if (!this.monitor.isDragging() || this.monitor.didDrop()) {
              this.moveStartSourceIds = null;
              return;
            }

            e.preventDefault();

            this._mouseClientOffset = {};

            this.uninstallSourceNodeRemovalObserver();
            this.actions.drop();
            this.actions.endDrag();
          }
        }, {
          key: 'handleCancelOnEscape',
          value: function handleCancelOnEscape(e) {
            if (e.key === 'Escape') {
              this._mouseClientOffset = {};

              this.uninstallSourceNodeRemovalObserver();
              this.actions.endDrag();
            }
          }
        }, {
          key: 'handleOnContextMenu',
          value: function handleOnContextMenu() {
            this.moveStartSourceIds = null;
          }
        }, {
          key: 'installSourceNodeRemovalObserver',
          value: function installSourceNodeRemovalObserver(node) {
            var _this5 = this;

            this.uninstallSourceNodeRemovalObserver();

            this.draggedSourceNode = node;
            this.draggedSourceNodeRemovalObserver = new window.MutationObserver(function () {
              if (!node.parentElement) {
                _this5.resurrectSourceNode();
                _this5.uninstallSourceNodeRemovalObserver();
              }
            });

            if (!node || !node.parentElement) {
              return;
            }

            this.draggedSourceNodeRemovalObserver.observe(node.parentElement, { childList: true });
          }
        }, {
          key: 'resurrectSourceNode',
          value: function resurrectSourceNode() {
            this.draggedSourceNode.style.display = 'none';
            this.draggedSourceNode.removeAttribute('data-reactid');
            document.body.appendChild(this.draggedSourceNode);
          }
        }, {
          key: 'uninstallSourceNodeRemovalObserver',
          value: function uninstallSourceNodeRemovalObserver() {
            if (this.draggedSourceNodeRemovalObserver) {
              this.draggedSourceNodeRemovalObserver.disconnect();
            }

            this.draggedSourceNodeRemovalObserver = null;
            this.draggedSourceNode = null;
          }
        }]);

        return TouchBackend;
      }();

      function createTouchBackend() {
        var optionsOrManager = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var touchBackendFactory = function touchBackendFactory(manager) {
          return new TouchBackend(manager, optionsOrManager);
        };

        if (optionsOrManager.getMonitor) {
          return touchBackendFactory(optionsOrManager);
        } else {
          return touchBackendFactory;
        }
      }

      /***/
    },
    /* 155 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {
        /**
        * Copyright 2013-2015, Facebook, Inc.
        * All rights reserved.
        *
        * This source code is licensed under the BSD-style license found in the
        * LICENSE file in the root directory of this source tree. An additional grant
        * of patent rights can be found in the PATENTS file in the same directory.
        */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var invariant = function invariant(condition, format, a, b, c, d, e, f) {
          if (process.env.NODE_ENV !== 'production') {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          }

          if (!condition) {
            var error;
            if (format === undefined) {
              error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(format.replace(/%s/g, function () {
                return args[argIndex++];
              }));
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame
            throw error;
          }
        };

        module.exports = invariant;

        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(5));

      /***/
    },
    /* 156 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _DragLayer = __webpack_require__(47);

      var _DragLayer2 = _interopRequireDefault(_DragLayer);

      var _EventBase = __webpack_require__(53);

      var _EventBase2 = _interopRequireDefault(_EventBase);

      var _objectAssign = __webpack_require__(54);

      var _objectAssign2 = _interopRequireDefault(_objectAssign);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      function collect(monitor) {
        var props = {
          clientOffset: monitor.getDifferenceFromInitialOffset()
        };

        var item = monitor.getItem();
        if (item && item['draggingComponent']) {
          props['draggingComponent'] = item['draggingComponent'];
        }

        return props;
      }

      var EventPreview = function (_React$Component) {
        _inherits(EventPreview, _React$Component);

        function EventPreview() {
          _classCallCheck(this, EventPreview);

          return _possibleConstructorReturn(this, (EventPreview.__proto__ || Object.getPrototypeOf(EventPreview)).apply(this, arguments));
        }

        _createClass(EventPreview, [{
          key: 'getItemStyles',
          value: function getItemStyles() {
            if (!this.props.clientOffset) {
              return {
                display: 'none'
              };
            }

            var x = this.props.clientOffset.x;
            var y = this.props.clientOffset.y;
            var transform = 'translate(' + x + 'px, ' + y + 'px)';

            return (0, _objectAssign2.default)(this.props.draggingComponent.getDraggingStyle(), {
              position: 'absolute',
              transform: transform,
              WebkitTransform: transform
            });
          }
        }, {
          key: 'render',
          value: function render() {
            var draggingDisplay = '';
            if (this.props.draggingComponent && this.props.draggingComponent.state.draggingDisplay) {
              draggingDisplay = this.props.draggingComponent.state.draggingDisplay;
            }

            var display = [];
            if (this.props.draggingComponent && this.props.draggingComponent.state.display) {
              display = this.props.draggingComponent.state.display;
            }
            return _react2.default.createElement('div', { ref: 'preview', className: 'tlEventView tlDraggingEvent', style: this.getItemStyles() }, _react2.default.createElement(_EventBase2.default, {
              draggingDisplay: draggingDisplay,
              display: display,
              timeline: this.props.timeline
            }));
          }
        }]);

        return EventPreview;
      }(_react2.default.Component);

      exports.default = (0, _DragLayer2.default)(collect)(EventPreview);

      /***/
    },
    /* 157 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.closest = closest;
      function closest(elem, selector) {
        var matchesFn;

        // find vendor prefix
        ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
          if (typeof document.body[fn] == 'function') {
            matchesFn = fn;
            return true;
          }
          return false;
        });

        var parent;

        // traverse parents
        while (elem) {
          parent = elem.parentElement;
          if (parent && parent[matchesFn](selector)) {
            return parent;
          }
          elem = parent;
        }

        return null;
      }

      /***/
    },
    /* 158 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _react = __webpack_require__(0);

      var _react2 = _interopRequireDefault(_react);

      var _classnames = __webpack_require__(4);

      var _classnames2 = _interopRequireDefault(_classnames);

      var _TimeSpan = __webpack_require__(3);

      var _TimeSpan2 = _interopRequireDefault(_TimeSpan);

      var _reactDnd = __webpack_require__(36);

      var _EventBase = __webpack_require__(53);

      var _EventBase2 = _interopRequireDefault(_EventBase);

      var _Timeline = __webpack_require__(18);

      var _Timeline2 = _interopRequireDefault(_Timeline);

      var _objectAssign = __webpack_require__(54);

      var _objectAssign2 = _interopRequireDefault(_objectAssign);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var source = {
        beginDrag: function beginDrag(props, monitor, component) {
          return (0, _objectAssign2.default)({}, props, { draggingComponent: component });
        },
        canDrag: function canDrag(props, monitor, component) {
          var draggable = props.timeline.findEventById(props.id).state.draggable;
          return !!draggable;
        }
      };

      var collect = function collect(connect, monitor) {
        return {
          connectDragSource: connect.dragSource(),
          isDragging: monitor.isDragging()
        };
      };

      var Event = function (_React$Component) {
        _inherits(Event, _React$Component);

        function Event(props) {
          _classCallCheck(this, Event);

          var _this = _possibleConstructorReturn(this, (Event.__proto__ || Object.getPrototypeOf(Event)).call(this, props));

          _this.state = {
            top: props.float === undefined ? _this.props.timeline.timeToTop(_this.props.timeSpan.getStartTime()) : props.float.top,
            left: props.float === undefined ? _this.props.timeline.getLineLeft(_this.props.lineId) : props.float.left,
            color: _this.props.color,
            draggable: props.float === undefined ? false : true,
            resizable: false,
            draggingDisplay: '',
            display: props.display
          };

          _this.lineId = _this.props.lineId;
          _this.timeSpan = _this.props.timeSpan;
          _this.draggingPosition = null;
          _this.resizingTimeSpan = null;
          _this.resizing = false;
          _this.vars = _this.props.vars ? _this.props.vars : {};
          _this.element = null;

          if (_this.props.float) {
            // 高さを設定
            _this.state.height = _this.props.timeline.minuteToHeight(_this.props.float.minute);
            var time = _this.props.timeline.topToTime(_this.state.top);
            _this.draggingPosition = { time: time, lineId: undefined };
            _this.state.draggingDisplay = time.getDisplayTime();
            _this.timeSpan = new _TimeSpan2.default(time, time.addMin(_this.props.float.minute));
          } else {
            _this.state.height = _this.props.timeline.timeSpanToHeight(_this.timeSpan);
          }
          return _this;
        }

        _createClass(Event, [{
          key: 'toJson',
          value: function toJson() {
            return {
              id: this.props.id,
              lineId: this.lineId,
              timeSpan: this.timeSpan,
              vars: JSON.parse(JSON.stringify(this.vars)),
              color: this.state.color,
              display: this.props.display,
              position: {
                top: this.state.top,
                left: this.state.left
              }
            };
          }
        }, {
          key: 'update',
          value: function update(values) {
            var newState = {};
            if (values.timeSpan) {
              newState.height = this.props.timeline.timeSpanToHeight(values.timeSpan);
              newState.top = this.props.timeline.timeToTop(values.timeSpan.getStartTime());
              this.timeSpan = values.timeSpan;
            }

            if (values.color) {
              newState.color = values.color;
            }

            if (values.display) {
              newState.display = values.display;
            }

            if (values.vars) {
              this.vars = values.vars;
            }

            this.setState(newState);
          }
        }, {
          key: 'isFreePosition',

          /**
           * 他のEventと重なっていないかチェックする
           * @param  {object}  position {lineId: ***, timeSpan: ***}
           * @return {Boolean}
           */
          value: function isFreePosition(position) {
            for (var i = 0; i < this.props.timeline.eventComponents.length; i++) {
              var ev = this.props.timeline.eventComponents[i];
              if (ev === this) continue;
              if (ev.lineId != position.lineId) continue;
              if (ev.currentTimeSpan.overlaps(position.timeSpan)) {
                return false;
              }
            }

            return true;
          }
        }, {
          key: 'moveTo',
          value: function moveTo(top, left) {
            this.setState({ top: top, left: left });
          }
        }, {
          key: 'onClick',
          value: function onClick(e) {
            var _this2 = this;

            if (this.props.timeline.props.eventDidClick) {
              if (this.resizing) {
                return;
              }

              this.props.timeline.props.eventDidClick({
                position: {
                  scrollTop: this.props.timeline.frameComponent.refs.linesWrapper.scrollTop,
                  scrollLeft: this.props.timeline.frameComponent.element.scrollLeft,
                  top: e.clientY,
                  left: e.clientX
                },
                component: this,
                lineComponent: this.props.timeline.lineComponents.find(function (lineComponent) {
                  return lineComponent.props.id == _this2.lineId;
                }),
                event: e
              });
            }
          }
        }, {
          key: 'dragging',
          value: function dragging(time, lineId) {
            this.draggingPosition = { time: time, lineId: lineId };
            this.setState({ draggingDisplay: time.getDisplayTime() });
          }
        }, {
          key: 'resizeUp',
          value: function resizeUp(e) {
            this.props.timeline.frameComponent.resizeUp(this, e.clientY);
          }
        }, {
          key: 'resizeDown',
          value: function resizeDown(e) {
            this.props.timeline.frameComponent.resizeDown(this, e.clientY);
          }
        }, {
          key: 'endResizing',
          value: function endResizing(e) {
            var _this3 = this;

            if (this.resizingTimeSpan) {
              var newState = {
                draggingDisplay: null,
                draggingDisplayTop: null
              };

              if (this.resizingTimeSpan) {
                newState.top = this.props.timeline.timeToTop(this.resizingTimeSpan.getStartTime());
                newState.height = this.props.timeline.timeSpanToHeight(this.resizingTimeSpan);
              }

              this.setState(newState);
            } else {
              this.onClick();
            }

            //onClickよりendResizingの先に発生してしまう。
            setTimeout(function () {
              return _this3.resizing = false;
            }, 100);
          }
        }, {
          key: 'onContextMenu',
          value: function onContextMenu(e) {
            if (this.props.timeline.props.eventDidRightClick) {
              this.props.timeline.props.eventDidRightClick({
                event: e,
                component: this
              });
            }
          }
        }, {
          key: 'getDraggingStyle',
          value: function getDraggingStyle() {
            return {
              height: this.state.height,
              width: this.props.width,
              top: this.state.top,
              left: this.state.left,
              backgroundColor: this.state.color
            };
          }
        }, {
          key: 'getOffset',
          value: function getOffset() {
            return {
              top: this.state.top,
              left: this.state.left
            };
          }
        }, {
          key: 'setColor',
          value: function setColor(color) {
            this.setState({ color: color });
          }
        }, {
          key: 'setDisplay',
          value: function setDisplay(display) {
            this.setState({ display: display });
          }
        }, {
          key: 'resize',
          value: function resize() {
            this.setState({
              resizable: true
            });
          }
        }, {
          key: 'float',
          value: function float() {
            this.setState({
              draggable: true,
              draggingDisplay: this.timeSpan.getStartTime().getDisplayTime()
            });

            this.draggingPosition = { time: this.timeSpan.getStartTime(), lineId: this.lineId };
          }
        }, {
          key: 'isFixed',
          value: function isFixed() {
            return !this.state.draggable && !this.state.resizable;
          }
        }, {
          key: 'isFixable',
          value: function isFixable() {
            var newPosition = this.nextPosition;
            if (!newPosition) {
              return true;
            }

            return this.isFreePosition(newPosition);
          }
        }, {
          key: 'isCancelable',
          value: function isCancelable() {
            var newPosition = this.prevPosition;
            if (!newPosition) {
              return true;
            }

            return this.isFreePosition(newPosition);
          }
        }, {
          key: 'cancel',
          value: function cancel() {
            if (this.draggingPosition) {
              var left = this.props.timeline.getLineLeft(this.lineId);
              var top = this.props.timeline.timeToTop(this.timeSpan.getStartTime());
              this.draggingPosition = null;
              this.setState({
                draggable: false,
                draggingDisplay: '',
                top: top,
                left: left
              });
            } else if (this.resizingTimeSpan) {
              var _top = this.props.timeline.timeToTop(this.timeSpan.getStartTime());
              var height = this.props.timeline.timeSpanToHeight(this.timeSpan);
              this.resizingTimeSpan = null;
              this.setState({
                resizable: false,
                draggingDisplay: '',
                top: _top,
                height: height
              });
            } else {
              this.setState({
                draggable: false,
                resizable: false,
                draggingDisplay: ''
              });
            }

            this.props.timeline.clearDraggingOver();
          }
        }, {
          key: 'getMinute',
          value: function getMinute() {
            if (this.timeSpan) {
              return this.timeSpan.getDistance();
            } else if (this.props.float) {
              return parseInt(this.props.float.minute, 10);
            }
          }
        }, {
          key: 'fix',
          value: function fix() {
            if (this.draggingPosition) {
              var state = {
                top: this.props.timeline.timeToTop(this.draggingPosition.time),
                left: this.props.timeline.getLineLeft(this.draggingPosition.lineId),
                draggable: false,
                draggingDisplay: ''
              };
              var newTimeSpan = this.timeSpan.shiftStartTime(this.draggingPosition.time);
              if (this.props.timeline.props.eventWillFix) {
                this.props.timeline.props.eventWillFix({
                  component: this,
                  state: state,
                  lineId: this.draggingPosition.lineId,
                  timeSpan: newTimeSpan
                });
              }
              this.setState(state);
              this.lineId = this.draggingPosition.lineId;
              this.timeSpan = newTimeSpan;
              this.draggingPosition = null;
            } else if (this.resizingTimeSpan) {
              var _state = {
                resizable: false,
                draggingDisplay: ''
              };
              if (this.props.timeline.props.eventWillFix) {
                this.props.timeline.props.eventWillFix({
                  component: this,
                  state: _state,
                  lineId: this.lineId,
                  timeSpan: this.resizingTimeSpan
                });
              }
              this.setState(_state);
              this.timeSpan = this.resizingTimeSpan;
              this.resizingTimeSpan = null;
            } else {
              this.setState({
                draggable: false,
                resizable: false,
                draggingDisplay: ''
              });
            }

            this.props.timeline.clearDraggingOver();
            if (this.props.timeline.props.eventDidFix) {
              this.props.timeline.props.eventDidFix({
                component: this
              });
            }
          }
        }, {
          key: 'setVar',
          value: function setVar(key, value) {
            this.vars[key] = value;
          }
        }, {
          key: 'getVar',
          value: function getVar(key) {
            return this.vars[key];
          }
        }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
            this.props.timeline.eventComponents.push(this);
          }
        }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
            var _this4 = this;

            this.props.timeline.eventComponents = this.props.timeline.eventComponents.filter(function (ev) {
              return ev !== _this4;
            });
          }
        }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
            if (this.isFixed()) {
              if (nextProps.action == 'float') {
                this.float();
              } else if (nextProps.action == 'resize') {
                this.resize();
              }
            } else {
              if (nextProps.action == 'fix') {
                this.fix();
              } else if (nextProps.action == 'cancel') {
                this.cancel();
              }
            }
          }
        }, {
          key: 'correctPosition',
          value: function correctPosition() {
            if (this.state.draggable) {
              var newPos = {};
              // lineを特定する
              var line = this.props.timeline.findLineByLeft(this.state.left);
              // はみ出てたら移動
              if (!line) {
                line = this.props.timeline.lastLine;
                newPos.left = this.props.timeline.getLineLeft(line.props.id);
              }

              if (line) {
                this.draggingPosition.lineId = line.props.id;
              }

              // 高さがはみ出てないかチェック
              var bottom = this.props.timeline.timeToTop(this.props.timeline.timeSpan.getEndTime()) - this.state.height;
              if (this.state.top > bottom) {
                newPos.top = bottom;

                var time = this.props.timeline.topToTime(newPos.top);
                this.draggingPosition.time = time;
                newPos.draggingDisplay = time.getDisplayTime();
                this.timeSpan = new _TimeSpan2.default(time, time.addMin(this.timeSpan.getDistance()));
              }

              if (Object.keys(newPos).length) {
                this.setState(newPos);
              }
            }
          }
        }, {
          key: 'render',
          value: function render() {
            var _this5 = this;

            var style = {
              height: this.state.height,
              position: 'absolute',
              top: this.state.top + 'px',
              left: this.state.left + 'px',
              width: this.props.width + 'px',
              backgroundColor: this.state.color,
              display: this.props.isDragging ? 'none' : 'block'
            };

            return this.props.connectDragSource(_react2.default.createElement('div', { 'data-id': this.props.id, ref: function ref(elem) {
                return _this5.element = elem;
              }, onContextMenu: function onContextMenu(e) {
                return _this5.onContextMenu(e);
              }, className: (0, _classnames2.default)('tlEventView', { tlDraggingEvent: this.state.draggable, tlResizableEvent: this.state.resizable }), style: style, onClick: function onClick(e) {
                return _this5.onClick(e);
              } }, function () {
              if (_this5.state.resizable) {
                return _react2.default.createElement('div', { className: 'tlResizeHandle', onTouchStart: function onTouchStart(e) {
                    return _this5.resizeUp(e);
                  }, onMouseDown: function onMouseDown(e) {
                    return _this5.resizeUp(e);
                  } }, _react2.default.createElement('i', { className: 'fa fa-bars', 'aria-hidden': 'true' }));
              }
            }(), _react2.default.createElement(_EventBase2.default, {
              draggingDisplay: this.state.draggingDisplay,
              draggingDisplayTop: this.state.draggingDisplayTop,
              display: this.state.display,
              timeline: this.props.timeline
            }), function () {
              if (_this5.state.resizable) {
                return _react2.default.createElement('div', { className: 'tlResizeHandle tlBottom', onTouchStart: function onTouchStart(e) {
                    return _this5.resizeDown(e);
                  }, onMouseDown: function onMouseDown(e) {
                    return _this5.resizeDown(e);
                  } }, _react2.default.createElement('i', { className: 'fa fa-bars', 'aria-hidden': 'true' }));
              }
            }()));
          }
        }, {
          key: 'currentTimeSpan',
          get: function get() {
            return this.resizingTimeSpan || this.timeSpan;
          }
        }, {
          key: 'nextPosition',
          get: function get() {
            if (this.draggingPosition) {
              return {
                lineId: this.draggingPosition.lineId,
                timeSpan: this.timeSpan.shiftStartTime(this.draggingPosition.time)
              };
            } else if (this.resizingTimeSpan) {
              return {
                lineId: this.lineId,
                timeSpan: this.resizingTimeSpan
              };
            }

            return null;
          }
        }, {
          key: 'prevPosition',
          get: function get() {
            if (!this.draggingPosition && !this.resizingTimeSpan) {
              return null;
            } else {
              return {
                lineId: this.lineId,
                timeSpan: this.timeSpan
              };
            }
          }
        }]);

        return Event;
      }(_react2.default.Component);

      Event.defaultProps = {
        display: []
      };

      exports.default = (0, _reactDnd.DragSource)("Event", source, collect)(Event);

      /***/
    }]
    /******/)
  );
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)(module)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(4);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(10);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _index = __webpack_require__(7);

var _events = __webpack_require__(15);

var _events2 = _interopRequireDefault(_events);

var _reactContextMenu = __webpack_require__(16);

var _reactContextMenu2 = _interopRequireDefault(_reactContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_React$Component) {
  _inherits(App, _React$Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.$wrapper = $('#app');
    _this.eventMenu = null;
    _this.state = {
      lines: [{ label: 'label1', id: '__1' }, { label: 'label2', id: '__2' }, { label: 'label3', id: '__3' }, { label: 'label4', id: '__4' }, { label: 'label5', id: '__5' }, { label: 'label6', id: '__6' }, { label: 'label7', id: '__7' }, { label: 'label8', id: '__8' }, { label: 'label9', id: '__9' }, { label: 'label10', id: '__10' }, { label: 'label11', id: '__11' }, { label: 'label12', id: '__12' }, { label: 'label13', id: '__13' }, { label: 'label14', id: '__14' }, { label: 'label15', id: '__15' }, { label: 'label16', id: '__16' }, { label: 'label17', id: '__17' }, { label: 'label18', id: '__18' }],
      events: _events2.default,
      timeSpan: _index.TimeSpan.create([10, 0], [25, 0]),
      height: _this.calcHeight()
    };

    window.onresize = function () {
      _this.setState({ height: _this.calcHeight() });
    };

    _this.lastLineId = 18;
    return _this;
  }

  _createClass(App, [{
    key: 'calcHeight',
    value: function calcHeight() {
      var wrapperBounds = this.$wrapper.get(0).getBoundingClientRect();
      var windowSize = this.getWindowSize();
      return windowSize.height - wrapperBounds.top;
    }
  }, {
    key: 'getWindowSize',
    value: function getWindowSize() {
      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

      return { width: width, height: height };
    }
  }, {
    key: 'generateEventId',
    value: function generateEventId() {
      this.lastEventId = this.lastEventId || 0;
      this.lastEventId += 1;
      return 'new_' + this.lastEventId;
    }
  }, {
    key: 'addEvent',
    value: function addEvent(data) {
      this.setState({ events: [].concat(_toConsumableArray(this.state.events), [{
          id: this.generateEventId(),
          lineId: data.component.props.id,
          timeSpan: new _index.TimeSpan(data.time, data.time.addMin(60)),
          color: '#FFDCB6',
          display: [{ key: 'startTime', value: data.time.getDisplayTime() }]
        }]) });
    }
  }, {
    key: 'floatEvent',
    value: function floatEvent(context) {
      this.setActionToEvent(context.component.props.id, 'float');
    }
  }, {
    key: 'resizeEvent',
    value: function resizeEvent(context) {
      this.setActionToEvent(context.component.props.id, 'resize');
    }
  }, {
    key: 'cancelEvent',
    value: function cancelEvent(context) {
      this.setActionToEvent(context.component.props.id, 'cancel');
    }
  }, {
    key: 'fixEvent',
    value: function fixEvent(context) {
      this.setActionToEvent(context.component.props.id, 'fix');
    }
  }, {
    key: 'setActionToEvent',
    value: function setActionToEvent(eventId, action) {
      this.setState({ events: this.state.events.map(function (event) {
          if (event.id == eventId) {
            return Object.assign(event, { action: action });
          } else {
            return event;
          }
        }) });
    }
  }, {
    key: 'addLine',
    value: function addLine() {
      ++this.lastLineId;
      this.setState({ lines: [].concat(_toConsumableArray(this.state.lines), [{
          label: 'label' + this.lastLineId, id: '__' + this.lastLineId
        }]) });
    }
  }, {
    key: 'removeLine',
    value: function removeLine(id) {
      this.setState({ lines: this.state.lines.filter(function (line) {
          return line.id != id;
        }) });
    }
  }, {
    key: 'removeEvent',
    value: function removeEvent(id) {
      this.setState({ events: this.state.events.filter(function (event) {
          return event.id != id;
        }) });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'div',
          { style: { marginBottom: '20px' } },
          _react2.default.createElement(
            'button',
            { onClick: function onClick() {
                return _this2.addLine();
              } },
            'LINE\u3092\u8FFD\u52A0'
          )
        ),
        _react2.default.createElement(_reactContextMenu2.default, {
          ref: function ref(menu) {
            return _this2.eventMenu = menu;
          },
          items: [{
            name: function name(context) {
              return 'float';
            },
            onClick: function onClick(context) {
              return _this2.floatEvent(context);
            },
            show: function show(context) {
              return context.component.constructor.name == 'Event' && context.component.isFixed();
            }
          }, {
            name: function name(context) {
              return 'resize';
            },
            onClick: function onClick(context) {
              return _this2.resizeEvent(context);
            },
            show: function show(context) {
              return context.component.constructor.name == 'Event' && context.component.isFixed();
            }
          }, {
            name: function name(context) {
              return 'cancel';
            },
            onClick: function onClick(context) {
              return _this2.cancelEvent(context);
            },
            show: function show(context) {
              return context.component.constructor.name == 'Event' && !context.component.isFixed();
            }
          }, {
            name: function name(context) {
              return 'fix';
            },
            onClick: function onClick(context) {
              return _this2.fixEvent(context);
            },
            show: function show(context) {
              return context.component.constructor.name == 'Event' && !context.component.isFixed();
            }
          }, {
            name: function name(context) {
              return '-';
            },
            show: function show(context) {
              return context.component.constructor.name == 'Event';
            }
          }, {
            name: function name(context) {
              return 'remove';
            },
            onClick: function onClick(context) {
              var timeline = context.component.props.timeline;
              if (context.component.constructor.name == 'Line') {
                _this2.removeLine(context.component.props.id);
              } else {
                _this2.removeEvent(context.component.props.id);
              }
            },
            enable: function enable(context) {
              var timeline = context.component.props.timeline;
              if (context.component.constructor.name == 'Line') {
                return true;
                var events = timeline.getEventsOnLine(context.component.props.id);
                return events.length === 0;
              } else {
                return context.component.isFixed();
              }
            }
          }],
          zIndex: 1000
        }),
        _react2.default.createElement(_index.Timeline, {
          lineData: this.state.lines,
          timeSpan: this.state.timeSpan,
          events: this.state.events,
          lineWidth: 62,
          minHeight: 17,
          minInterval: 5,
          rulerInterval: 4,
          height: this.state.height,
          lineDidClick: function lineDidClick(data) {
            return _this2.addEvent(data);
          },
          lineDidRightClick: function lineDidRightClick(data) {
            data.event.preventDefault();
            _this2.eventMenu.show({ top: data.event.clientY, left: data.event.clientX }, data);
          },
          eventDidClick: function eventDidClick(data) {
            console.log('left', data);
          },
          eventDidRightClick: function eventDidRightClick(data) {
            data.event.preventDefault();
            _this2.eventMenu.show({ top: data.event.clientY, left: data.event.clientX }, data);
          },
          eventWillFix: function eventWillFix(data) {
            var display = data.component.state.display.filter(function (row) {
              return row.key != 'startTime';
            });
            display.push({ key: 'startTime', value: data.timeSpan.getStartTime().getDisplayTime() });
            data.state.display = display;
          },
          eventDidFix: function eventDidFix(data) {
            console.log(data);
          }
        })
      );
    }
  }]);

  return App;
}(_react2.default.Component);

$(function () {
  _reactDom2.default.render(_react2.default.createElement(App, null), document.getElementById('app'));
});

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(4);
var invariant = __webpack_require__(5);
var warning = __webpack_require__(8);

var ReactPropTypesSecret = __webpack_require__(6);
var checkPropTypes = __webpack_require__(13);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(5);
  var warning = __webpack_require__(8);
  var ReactPropTypesSecret = __webpack_require__(6);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(4);
var invariant = __webpack_require__(5);
var ReactPropTypesSecret = __webpack_require__(6);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(7);

exports.default = [{ id: '1231', lineId: '__1', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1241', lineId: '__1', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1251', lineId: '__1', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1261', lineId: '__1', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '1271', lineId: '__1', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '1281', lineId: '__1', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '1291', lineId: '__1', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '123', lineId: '__2', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '124', lineId: '__2', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '125', lineId: '__2', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1233', lineId: '__3', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1243', lineId: '__3', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1253', lineId: '__3', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1234', lineId: '__4', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1244', lineId: '__4', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1254', lineId: '__4', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12355', lineId: '__5', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12455', lineId: '__5', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12555', lineId: '__5', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1226', lineId: '__6', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '1236', lineId: '__6', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1246', lineId: '__6', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1256', lineId: '__6', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1266', lineId: '__6', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '1276', lineId: '__6', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '1286', lineId: '__6', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '1296', lineId: '__6', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '12377', lineId: '__7', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12477', lineId: '__7', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12577', lineId: '__7', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1228', lineId: '__8', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '1238', lineId: '__8', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1248', lineId: '__8', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1258', lineId: '__8', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '1268', lineId: '__8', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '1278', lineId: '__8', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '1288', lineId: '__8', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '1298', lineId: '__8', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '1239', lineId: '__9', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '1249', lineId: '__9', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '1259', lineId: '__9', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12210', lineId: '__10', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '12310', lineId: '__10', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12410', lineId: '__10', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12510', lineId: '__10', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12610', lineId: '__10', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '12710', lineId: '__10', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '12810', lineId: '__10', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '12910', lineId: '__10', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '12311', lineId: '__11', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12411', lineId: '__11', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12511', lineId: '__11', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12312', lineId: '__12', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12412', lineId: '__12', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12512', lineId: '__12', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12213', lineId: '__13', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '12313', lineId: '__13', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12413', lineId: '__13', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12513', lineId: '__13', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12613', lineId: '__13', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '12713', lineId: '__13', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '12813', lineId: '__13', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '12913', lineId: '__13', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '12314', lineId: '__14', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12414', lineId: '__14', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12514', lineId: '__14', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12315', lineId: '__15', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12415', lineId: '__15', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12515', lineId: '__15', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12216', lineId: '__16', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '12316', lineId: '__16', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12416', lineId: '__16', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12516', lineId: '__16', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12616', lineId: '__16', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '12716', lineId: '__16', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '12816', lineId: '__16', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '12916', lineId: '__16', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '12217', lineId: '__17', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '12317', lineId: '__17', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12417', lineId: '__17', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12517', lineId: '__17', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12617', lineId: '__17', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '12717', lineId: '__17', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '12817', lineId: '__17', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '12917', lineId: '__17', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, { id: '12218', lineId: '__18', timeSpan: _index.TimeSpan.create([11, 15], [12, 30]), color: '#FFDCB6' }, { id: '12318', lineId: '__18', timeSpan: _index.TimeSpan.create([12, 30], [13, 30]), color: '#FFDCB6' }, { id: '12418', lineId: '__18', timeSpan: _index.TimeSpan.create([14, 0], [16, 30]), color: '#FFDCB6' }, { id: '12518', lineId: '__18', timeSpan: _index.TimeSpan.create([17, 0], [18, 30]), color: '#FFDCB6' }, { id: '12618', lineId: '__18', timeSpan: _index.TimeSpan.create([18, 30], [19, 30]), color: '#FFDCB6' }, { id: '12718', lineId: '__18', timeSpan: _index.TimeSpan.create([19, 30], [20, 30]), color: '#FFDCB6' }, { id: '12818', lineId: '__18', timeSpan: _index.TimeSpan.create([20, 30], [21, 30]), color: '#FFDCB6' }, { id: '12918', lineId: '__18', timeSpan: _index.TimeSpan.create([22, 30], [23, 30]), color: '#FFDCB6' }, {
  id: 'float1',
  color: '#FFB6B6',
  float: { top: 10, left: 10, minute: 60 }
}, {
  id: 'float2',
  color: '#FFB6B6',
  float: { top: 10000, left: 10000, minute: 60 }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));
	else if(typeof define === 'function' && define.amd)
		define(["react", "classnames", "prop-types"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("classnames"), require("prop-types")) : factory(root["React"], root["classNames"], root["PropTypes"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextMenu = undefined;

var _ContextMenu = __webpack_require__(2);

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.ContextMenu = _ContextMenu2.default;
exports.default = _ContextMenu2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _objectAssign = __webpack_require__(3);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _ContextMenuItem = __webpack_require__(4);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

var _propTypes = __webpack_require__(6);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContextMenu = function (_React$Component) {
  _inherits(ContextMenu, _React$Component);

  _createClass(ContextMenu, null, [{
    key: 'getWindowSize',
    value: function getWindowSize() {
      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

      return { width: width, height: height };
    }
  }]);

  function ContextMenu(props) {
    _classCallCheck(this, ContextMenu);

    var _this = _possibleConstructorReturn(this, (ContextMenu.__proto__ || Object.getPrototypeOf(ContextMenu)).call(this, props));

    _this.state = {
      style: {
        position: 'absolute',
        display: 'none',
        zIndex: _this.props.zIndex
      }
    };

    _this.overlay = document.createElement('div');
    _this.overlay.setAttribute('class', 'rmMenuOverlay');
    _this.overlay.style["position"] = 'absolute';
    _this.overlay.style["top"] = '0';
    _this.overlay.style["left"] = '0';
    _this.overlay.style["display"] = 'none';
    _this.overlay.style["zIndex"] = _this.props.zIndex - 1;
    document.body.appendChild(_this.overlay);
    _this.overlay.addEventListener('click', function (e) {
      return _this.close();
    });
    _this.overlay.addEventListener('contextmenu', function (e) {
      e.preventDefault();
      _this.close();
    });
    return _this;
  }

  _createClass(ContextMenu, [{
    key: 'show',
    value: function show(pos, context) {
      var _this2 = this;

      this.setState({
        style: (0, _objectAssign2.default)({}, this.state.style, pos, { display: 'block' }),
        context: context
      }, function () {
        var windowSize = ContextMenu.getWindowSize();
        _this2.overlay.style["width"] = windowSize.width + 'px';
        _this2.overlay.style["height"] = windowSize.height + 'px';
        _this2.overlay.style['display'] = 'block';
      });
    }
  }, {
    key: 'onMouseOut',
    value: function onMouseOut() {
      console.log('out');
    }
  }, {
    key: 'onMouseOver',
    value: function onMouseOver() {
      console.log('over');
    }
  }, {
    key: 'close',
    value: function close() {
      var _this3 = this;

      this.setState({ style: (0, _objectAssign2.default)({}, this.state.style, { display: 'none' }) }, function () {
        _this3.overlay.style['display'] = 'none';
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      return _react2.default.createElement(
        'div',
        { ref: 'menu', className: 'rmMenu', style: this.state.style },
        _react2.default.createElement(
          'ul',
          { className: 'rmMenuItemList' },
          this.state.context ? this.props.items.map(function (item, key) {
            if (!item.show || item.show(_this4.state.context)) {
              return _react2.default.createElement(_ContextMenuItem2.default, {
                key: key,
                name: item.name(_this4.state.context),
                onClick: item.onClick,
                menu: _this4,
                enable: item.enable ? item.enable(_this4.state.context) : true
              });
            }
          }) : null
        )
      );
    }
  }]);

  return ContextMenu;
}(_react2.default.Component);

exports.default = ContextMenu;


ContextMenu.propTypes = {
  items: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    name: _propTypes2.default.func.isRequired,
    onClick: _propTypes2.default.func,
    show: _propTypes2.default.func,
    enable: _propTypes2.default.func
  })).isRequired,
  zIndex: _propTypes2.default.number
};

ContextMenu.defaultProps = {
  zIndex: 100
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContextMenuItem = function (_React$Component) {
  _inherits(ContextMenuItem, _React$Component);

  function ContextMenuItem(props) {
    _classCallCheck(this, ContextMenuItem);

    var _this = _possibleConstructorReturn(this, (ContextMenuItem.__proto__ || Object.getPrototypeOf(ContextMenuItem)).call(this, props));

    _this.state = {
      mouseOver: false
    };
    return _this;
  }

  _createClass(ContextMenuItem, [{
    key: 'onMouseOut',
    value: function onMouseOut() {
      if (this.props.enable) {
        this.setState({ mouseOver: false });
      }
    }
  }, {
    key: 'onMouseOver',
    value: function onMouseOver() {
      if (this.props.enable) {
        this.setState({ mouseOver: true });
      }
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      if (this.props.enable) {
        this.props.onClick(this.props.menu.state.context);
        this.props.menu.close();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement('li', {
        className: (0, _classnames2.default)("rmMenuItem", { rmMouseOver: this.state.mouseOver, rmDisabled: !this.props.enable, rmSeparator: this.props.name == '-' }),
        onMouseOver: function onMouseOver(e) {
          return _this2.onMouseOver(e);
        },
        onMouseOut: function onMouseOut(e) {
          return _this2.onMouseOut(e);
        },
        onClick: function onClick(e) {
          return _this2.onClick(e);
        },
        dangerouslySetInnerHTML: { __html: this.props.name == '-' ? null : this.props.name }
      });
    }
  }]);

  return ContextMenuItem;
}(_react2.default.Component);

exports.default = ContextMenuItem;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA1NzM4M2FjZmFmY2MyZWNkMmY3MCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguZXM2Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0NvbnRleHRNZW51LmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Db250ZXh0TWVudUl0ZW0uanN4Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJjbGFzc05hbWVzXCIsXCJjb21tb25qczJcIjpcImNsYXNzbmFtZXNcIixcImNvbW1vbmpzXCI6XCJjbGFzc25hbWVzXCIsXCJhbWRcIjpcImNsYXNzbmFtZXNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlByb3BUeXBlc1wiLFwiY29tbW9uanMyXCI6XCJwcm9wLXR5cGVzXCIsXCJjb21tb25qc1wiOlwicHJvcC10eXBlc1wiLFwiYW1kXCI6XCJwcm9wLXR5cGVzXCJ9Il0sIm5hbWVzIjpbIkNvbnRleHRNZW51Iiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImJvZHkiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInByb3BzIiwic3RhdGUiLCJzdHlsZSIsInBvc2l0aW9uIiwiZGlzcGxheSIsInpJbmRleCIsIm92ZXJsYXkiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xvc2UiLCJlIiwicHJldmVudERlZmF1bHQiLCJwb3MiLCJjb250ZXh0Iiwic2V0U3RhdGUiLCJ3aW5kb3dTaXplIiwiZ2V0V2luZG93U2l6ZSIsImNvbnNvbGUiLCJsb2ciLCJpdGVtcyIsIm1hcCIsIml0ZW0iLCJrZXkiLCJzaG93IiwibmFtZSIsIm9uQ2xpY2siLCJlbmFibGUiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJhcnJheU9mIiwic2hhcGUiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIm51bWJlciIsImRlZmF1bHRQcm9wcyIsIkNvbnRleHRNZW51SXRlbSIsIm1vdXNlT3ZlciIsIm1lbnUiLCJybU1vdXNlT3ZlciIsInJtRGlzYWJsZWQiLCJybVNlcGFyYXRvciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZU91dCIsIl9faHRtbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQSwrQzs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7O1FBQ1FBLFc7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEUjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxXOzs7Oztv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V3VDLElBQVgsQ0FBZ0I1QixLQUFoQjtBQUNEO0FBQ0Y7Ozs2QkFFTztBQUFBOztBQUNOLGFBQ0U7QUFDRSxtQkFBVywwQkFBVyxZQUFYLEVBQXlCLEVBQUM2QixhQUFhLEtBQUt2QyxLQUFMLENBQVdxQyxTQUF6QixFQUFvQ0csWUFBWSxDQUFDLEtBQUt6QyxLQUFMLENBQVc0QixNQUE1RCxFQUFvRWMsYUFBYSxLQUFLMUMsS0FBTCxDQUFXMEIsSUFBWCxJQUFtQixHQUFwRyxFQUF6QixDQURiO0FBRUUscUJBQWE7QUFBQSxpQkFBSyxPQUFLaUIsV0FBTCxDQUFpQi9CLENBQWpCLENBQUw7QUFBQSxTQUZmO0FBR0Usb0JBQVk7QUFBQSxpQkFBSyxPQUFLZ0MsVUFBTCxDQUFnQmhDLENBQWhCLENBQUw7QUFBQSxTQUhkO0FBSUUsaUJBQVM7QUFBQSxpQkFBSyxPQUFLZSxPQUFMLENBQWFmLENBQWIsQ0FBTDtBQUFBLFNBSlg7QUFLRSxpQ0FBeUIsRUFBQ2lDLFFBQVEsS0FBSzdDLEtBQUwsQ0FBVzBCLElBQVgsSUFBbUIsR0FBbkIsR0FBeUIsSUFBekIsR0FBZ0MsS0FBSzFCLEtBQUwsQ0FBVzBCLElBQXBEO0FBTDNCLFFBREY7QUFVRDs7OztFQXZDMEMsZ0JBQU1HLFM7O2tCQUE5QlEsZTs7Ozs7O0FDSHJCLCtDOzs7Ozs7QUNBQSwrQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSwgcmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIiwgXCJjbGFzc25hbWVzXCIsIFwicHJvcC10eXBlc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpLCByZXF1aXJlKFwicHJvcC10eXBlc1wiKSkgOiBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcImNsYXNzTmFtZXNcIl0sIHJvb3RbXCJQcm9wVHlwZXNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA1NzM4M2FjZmFmY2MyZWNkMmY3MCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnLi9qcy9jb21wb25lbnRzL0NvbnRleHRNZW51JztcbmV4cG9ydCB7Q29udGV4dE1lbnV9XG5leHBvcnQgZGVmYXVsdCBDb250ZXh0TWVudVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmVzNiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9Db250ZXh0TWVudUl0ZW0nXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHRNZW51IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG57XG4gIHN0YXRpYyBnZXRXaW5kb3dTaXplKCl7XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG5cbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG5cbiAgICByZXR1cm4ge3dpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHR9O1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICAgIHpJbmRleDogdGhpcy5wcm9wcy56SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncm1NZW51T3ZlcmxheScpO1xuICAgIHRoaXMub3ZlcmxheS5zdHlsZVtcInBvc2l0aW9uXCJdID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLm92ZXJsYXkuc3R5bGVbXCJ0b3BcIl0gPSAnMCc7XG4gICAgdGhpcy5vdmVybGF5LnN0eWxlW1wibGVmdFwiXSA9ICcwJztcbiAgICB0aGlzLm92ZXJsYXkuc3R5bGVbXCJkaXNwbGF5XCJdID0gJ25vbmUnO1xuICAgIHRoaXMub3ZlcmxheS5zdHlsZVtcInpJbmRleFwiXSA9IHRoaXMucHJvcHMuekluZGV4IC0gMTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheSk7XG4gICAgdGhpcy5vdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNsb3NlKCkpO1xuICAgIHRoaXMub3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgc2hvdyhwb3MsIGNvbnRleHQpe1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3R5bGU6IGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zdHlsZSwgcG9zLCB7ZGlzcGxheTogJ2Jsb2NrJ30pLFxuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0sICgpID0+IHtcbiAgICAgIGxldCB3aW5kb3dTaXplID0gQ29udGV4dE1lbnUuZ2V0V2luZG93U2l6ZSgpO1xuICAgICAgdGhpcy5vdmVybGF5LnN0eWxlW1wid2lkdGhcIl0gPSB3aW5kb3dTaXplLndpZHRoICsgJ3B4JztcbiAgICAgIHRoaXMub3ZlcmxheS5zdHlsZVtcImhlaWdodFwiXSA9IHdpbmRvd1NpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMub3ZlcmxheS5zdHlsZVsnZGlzcGxheSddID0gJ2Jsb2NrJztcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VPdXQoKXtcbiAgICBjb25zb2xlLmxvZygnb3V0Jyk7XG4gIH1cblxuICBvbk1vdXNlT3Zlcigpe1xuICAgIGNvbnNvbGUubG9nKCdvdmVyJyk7XG4gIH1cblxuICBjbG9zZSgpe1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICB7c3R5bGU6IGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zdHlsZSwge2Rpc3BsYXk6ICdub25lJ30pfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlWydkaXNwbGF5J10gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj1cIm1lbnVcIiBjbGFzc05hbWU9XCJybU1lbnVcIiBzdHlsZT17dGhpcy5zdGF0ZS5zdHlsZX0+XG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJybU1lbnVJdGVtTGlzdFwiPlxuICAgICAgICAgIHt0aGlzLnN0YXRlLmNvbnRleHQgPyB0aGlzLnByb3BzLml0ZW1zLm1hcCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZighaXRlbS5zaG93IHx8IGl0ZW0uc2hvdyh0aGlzLnN0YXRlLmNvbnRleHQpKXtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8TWVudUl0ZW1cbiAgICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgICAgbmFtZT17aXRlbS5uYW1lKHRoaXMuc3RhdGUuY29udGV4dCl9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtpdGVtLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICBtZW51PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgZW5hYmxlPXtpdGVtLmVuYWJsZSA/IGl0ZW0uZW5hYmxlKHRoaXMuc3RhdGUuY29udGV4dCkgOiB0cnVlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSA6IG51bGx9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkNvbnRleHRNZW51LnByb3BUeXBlcyA9IHtcbiAgaXRlbXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbmFtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaG93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBlbmFibGU6IFByb3BUeXBlcy5mdW5jXG4gIH0pKS5pc1JlcXVpcmVkLFxuICB6SW5kZXg6IFByb3BUeXBlcy5udW1iZXJcbn1cblxuQ29udGV4dE1lbnUuZGVmYXVsdFByb3BzID0ge1xuICB6SW5kZXg6IDEwMFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2NvbXBvbmVudHMvQ29udGV4dE1lbnUuanN4IiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHRNZW51SXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxue1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbW91c2VPdmVyOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBvbk1vdXNlT3V0KCl7XG4gICAgaWYodGhpcy5wcm9wcy5lbmFibGUpe1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW91c2VPdmVyOiBmYWxzZX0pO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VPdmVyKCl7XG4gICAgaWYodGhpcy5wcm9wcy5lbmFibGUpe1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW91c2VPdmVyOiB0cnVlfSk7XG4gICAgfVxuICB9XG5cbiAgb25DbGljayhlKXtcbiAgICBpZih0aGlzLnByb3BzLmVuYWJsZSl7XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2sodGhpcy5wcm9wcy5tZW51LnN0YXRlLmNvbnRleHQpO1xuICAgICAgdGhpcy5wcm9wcy5tZW51LmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgcmV0dXJuIChcbiAgICAgIDxsaVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJybU1lbnVJdGVtXCIsIHtybU1vdXNlT3ZlcjogdGhpcy5zdGF0ZS5tb3VzZU92ZXIsIHJtRGlzYWJsZWQ6ICF0aGlzLnByb3BzLmVuYWJsZSwgcm1TZXBhcmF0b3I6IHRoaXMucHJvcHMubmFtZSA9PSAnLSd9KX1cbiAgICAgICAgb25Nb3VzZU92ZXI9e2UgPT4gdGhpcy5vbk1vdXNlT3ZlcihlKX1cbiAgICAgICAgb25Nb3VzZU91dD17ZSA9PiB0aGlzLm9uTW91c2VPdXQoZSl9XG4gICAgICAgIG9uQ2xpY2s9e2UgPT4gdGhpcy5vbkNsaWNrKGUpfVxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogdGhpcy5wcm9wcy5uYW1lID09ICctJyA/IG51bGwgOiB0aGlzLnByb3BzLm5hbWV9fVxuICAgICAgPlxuICAgICAgPC9saT5cbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvY29tcG9uZW50cy9Db250ZXh0TWVudUl0ZW0uanN4IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJjbGFzc05hbWVzXCIsXCJjb21tb25qczJcIjpcImNsYXNzbmFtZXNcIixcImNvbW1vbmpzXCI6XCJjbGFzc25hbWVzXCIsXCJhbWRcIjpcImNsYXNzbmFtZXNcIn1cbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJQcm9wVHlwZXNcIixcImNvbW1vbmpzMlwiOlwicHJvcC10eXBlc1wiLFwiY29tbW9uanNcIjpcInByb3AtdHlwZXNcIixcImFtZFwiOlwicHJvcC10eXBlc1wifVxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDM3MjE0YTY4YzZhYmI3NDUxYmQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly8vd2VicGFjazovd2VicGFjay9ib290c3RyYXAgZjAwZGIxMDUyYmExMjY5MzFlNTIiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6L2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY2xhc3Nlcy9UaW1lU3Bhbi5lczYiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6L2V4dGVybmFsIHtcInJvb3RcIjpcImNsYXNzTmFtZXNcIixcImNvbW1vbmpzMlwiOlwiY2xhc3NuYW1lc1wiLFwiY29tbW9uanNcIjpcImNsYXNzbmFtZXNcIixcImFtZFwiOlwiY2xhc3NuYW1lc1wifSIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29tcG9uZW50cy9SdWxlci5qc3giLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6L2V4dGVybmFsIHtcInJvb3RcIjpcIlByb3BUeXBlc1wiLFwiY29tbW9uanMyXCI6XCJwcm9wLXR5cGVzXCIsXCJjb21tb25qc1wiOlwicHJvcC10eXBlc1wiLFwiYW1kXCI6XCJwcm9wLXR5cGVzXCJ9Iiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9hY3Rpb25zL2RyYWdEcm9wLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9hY3Rpb25zL3JlZ2lzdHJ5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1RpbWVsaW5lLmpzeCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY2xhc3Nlcy9UaW1lLmVzNiIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9pc0Rpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTGluZS5qc3giLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTGluZUxhYmVsLmpzeCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9EcmFnRHJvcENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9yZWR1Y2Vycy9kcmFnT2Zmc2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvdXRpbHMvbWF0Y2hlc1R5cGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvZGlydHlIYW5kbGVySWRzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdMYXllci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi91dGlscy9zaGFsbG93RXF1YWxTY2FsYXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvZGVjb3JhdGVIYW5kbGVyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3dyYXBDb25uZWN0b3JIb29rcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9hcmVPcHRpb25zRXF1YWwuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvdXRpbHMvaXNWYWxpZFR5cGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvRXZlbnRCYXNlLmpzeCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvaW5kZXguZXM2Iiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0ZyYW1lLmpzeCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29tcG9uZW50cy9Ib3VyLmpzeCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvRHJhZ0Ryb3BNYW5hZ2VyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL2RyYWdPcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC93aXRob3V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL3JlZkNvdW50LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gveG9yLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VYb3IuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuaXEuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9yZWR1Y2Vycy9zdGF0ZUlkLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvRHJhZ0Ryb3BNb25pdG9yLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvSGFuZGxlclJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvYXNhcC9icm93c2VyLXJhdy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3V0aWxzL2dldE5leHRVbmlxdWVJZC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0RyYWdTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9Ecm9wVGFyZ2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvYmFja2VuZHMvY3JlYXRlVGVzdEJhY2tlbmQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvRHJhZ1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kaXNwb3NhYmxlcy9tb2R1bGVzL0NvbXBvc2l0ZURpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Rpc3Bvc2FibGVzL21vZHVsZXMvU2VyaWFsRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9yZWdpc3RlclNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVTb3VyY2VGYWN0b3J5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVNvdXJjZU1vbml0b3IuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlQ29ubmVjdG9yLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL2Nsb25lV2l0aFJlZi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9Ecm9wVGFyZ2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3JlZ2lzdGVyVGFyZ2V0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVRhcmdldEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlVGFyZ2V0TW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVUYXJnZXRDb25uZWN0b3IuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC10b3VjaC1iYWNrZW5kL2Rpc3QvVG91Y2guanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC10b3VjaC1iYWNrZW5kL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29tcG9uZW50cy9FdmVudFByZXZpZXcuanN4Iiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy91dGlscy5lczYiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvRXZlbnQuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL2V4YW1wbGUvYXBwLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdERPTVwiIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL2V4YW1wbGUvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZ29tby9yZWFjdC1jb250ZXh0LW1lbnUvaW5kZXguanMiXSwibmFtZXMiOlsiVGltZVNwYW4iLCJzdGFydCIsImVuZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJ0aW1lIiwiaG91ciIsIm1pbiIsIm1pbnV0ZSIsInRpbWVTcGFuIiwiY2FsbGJhY2siLCJrZXkiLCJtaW51dGVJbnRlcnZhbCIsIlJ1bGVyIiwiaG91cnMiLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwiQ29tcG9uZW50IiwiVGltZWxpbmUiLCJwcm9wcyIsImxlZnQiLCJsaW5lQ29tcG9uZW50IiwiaGFzUnVsZXIiLCJpbmRleCIsInZhbCIsImV2ZW50SWQiLCJldiIsImxpbmUiLCJsaW5lSWQiLCJpIiwibGluZURhdGEiLCJ0b3AiLCJyZXN0IiwiZXZlbnRDb21wb25lbnQiLCJhIiwiYiIsInByZXZFdmVudCIsImJvdHRvbVRpbWUiLCJuZXh0RXZlbnQiLCJuZXh0VGltZSIsImV2ZW50cyIsIm5leHRQcm9wcyIsImNoaWxkV2lkdGgiLCJsaW5lcyIsImlkIiwiZWxlbSIsIm1pbkludGVydmFsIiwiVGltZSIsImNvdW50IiwiZGlzcGxheU1pbiIsInBhcnNlSW50IiwidGFyZ2V0VGltZSIsInRhcmdldEhvdXIiLCJob3VyRGlzdGFuY2UiLCJMaW5lIiwiZHJhZ2dpbmdPdmVyIiwibWluSGVpZ2h0IiwiZSIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnRSZWN0IiwiY29tcG9uZW50IiwiZnJlZU1pbnV0ZSIsInBvc2l0aW9uIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImNsaWVudFgiLCJldmVudCIsInRsRXZlbiIsInRsT2RkIiwidGxPdmVyIiwiTGluZUxhYmVsIiwicHJldlJ1bGVyIiwiaXNMYXN0IiwibWFyZ2luTGVmdCIsInRsTGFiZWwiLCJ0bEhhc1J1bGVyIiwidGxQcmV2UnVsZXIiLCJ0bExhc3QiLCJsYWJlbCIsIkV2ZW50QmFzZSIsInJvdyIsImNsYXNzTmFtZSIsIkFycmF5IiwidmFsdWUiLCJkaXNwbGF5UG9zaXRpb24iLCJwcmV2aWV3UmVjdCIsInByZXZpZXdSaWdodFNpZGUiLCJkcmFnZ2luZ0Rpc3BsYXkiLCJkaXNwbGF5IiwidGFyZ2V0IiwiaXRlbSIsIm1vbml0b3IiLCJkZWx0YSIsImluaXRhbE9mZnNldCIsIk1hdGgiLCJjbGllbnRPZmZzZXQiLCJsaW5lV3JhcHBlckJvdW5kcyIsImNvbm5lY3REcm9wVGFyZ2V0IiwiY29ubmVjdCIsIkZyYW1lIiwicnVsZXJJbnRlcnZhbCIsIm1pbldpZHRoIiwiY2xpY2tlZFRvcCIsImluaXRpYWxIZWlnaHQiLCJwcmV2Qm90dG9tIiwibW91c2VNb3ZlRXZlbnQiLCJ0YXJnZXRIZWlnaHQiLCJtb3ZlRXZlbnQiLCJ0YXJnZXRUb3AiLCJzdG9wTW92ZUV2ZW50IiwibmV4dFRvcCIsInRhcmdldEJvdHRvbSIsImRyYWdnaW5nRGlzcGxheVRvcCIsIm5ld1N0YXRlIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3ciLCJkYXRhIiwib3ZlcmZsb3dZIiwiYWN0aW9uIiwiY2hpbGRyZW4iLCJlbmFibGVNb3VzZUV2ZW50cyIsIkhvdXIiLCJtaW51dGVzIiwibWluU3R5bGUiLCJFdmVudFByZXZpZXciLCJ4IiwieSIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRpbWVsaW5lIiwiY2xvc2VzdCIsImRvY3VtZW50IiwibWF0Y2hlc0ZuIiwicGFyZW50Iiwic291cmNlIiwiYmVnaW5EcmFnIiwiZHJhZ2dpbmdDb21wb25lbnQiLCJjYW5EcmFnIiwiZHJhZ2dhYmxlIiwiY29sbGVjdCIsImNvbm5lY3REcmFnU291cmNlIiwiaXNEcmFnZ2luZyIsIkV2ZW50IiwiY29sb3IiLCJyZXNpemFibGUiLCJ2YXJzIiwiSlNPTiIsInZhbHVlcyIsInNldFRpbWVvdXQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJuZXdQb3NpdGlvbiIsInN0YXRlIiwibmV3VGltZVNwYW4iLCJyZXNpemluZ1RpbWVTcGFuIiwibmV3UG9zIiwiYm90dG9tIiwiT2JqZWN0IiwidGxEcmFnZ2luZ0V2ZW50IiwidGxSZXNpemFibGVFdmVudCIsIkFwcCIsIiR3cmFwcGVyIiwiJCIsImV2ZW50TWVudSIsImNyZWF0ZSIsImNhbGNIZWlnaHQiLCJ3aW5kb3ciLCJvbnJlc2l6ZSIsInNldFN0YXRlIiwibGFzdExpbmVJZCIsIndyYXBwZXJCb3VuZHMiLCJnZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3dTaXplIiwiZ2V0V2luZG93U2l6ZSIsImlubmVyV2lkdGgiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImJvZHkiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImxhc3RFdmVudElkIiwiZ2VuZXJhdGVFdmVudElkIiwiYWRkTWluIiwiZ2V0RGlzcGxheVRpbWUiLCJjb250ZXh0Iiwic2V0QWN0aW9uVG9FdmVudCIsIm1hcCIsImFzc2lnbiIsImZpbHRlciIsIm1hcmdpbkJvdHRvbSIsImFkZExpbmUiLCJtZW51IiwibmFtZSIsIm9uQ2xpY2siLCJmbG9hdEV2ZW50Iiwic2hvdyIsImNvbnN0cnVjdG9yIiwiaXNGaXhlZCIsInJlc2l6ZUV2ZW50IiwiY2FuY2VsRXZlbnQiLCJmaXhFdmVudCIsInJlbW92ZUxpbmUiLCJyZW1vdmVFdmVudCIsImVuYWJsZSIsImdldEV2ZW50c09uTGluZSIsImxlbmd0aCIsImFkZEV2ZW50IiwicHJldmVudERlZmF1bHQiLCJjbGllbnRZIiwiY29uc29sZSIsImxvZyIsInB1c2giLCJnZXRTdGFydFRpbWUiLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsImZsb2F0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBZ0UsZ0JBQWhFLEVBQWtGLE1BQWxGLEVBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDLFNBOUJELE1BOEJDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQTRCLG1CQUE1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBSEE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBdEMsRUFBMkVwQixPQUFPLFNBQWxGLEVBMUNhLEVBMkNiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBdEMsRUFBMkVwQixPQUFPLFNBQWxGLEVBM0NhLEVBNENiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBdEMsRUFBMkVwQixPQUFPLFNBQWxGLEVBNUNhLEVBNkNiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBdEMsRUFBMkVwQixPQUFPLFNBQWxGLEVBN0NhLEVBK0NiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBdEMsRUFBMkVwQixPQUFPLFNBQWxGLEVBL0NhLEVBZ0RiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWhCLEVBQXlCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBekIsQ0FBdEMsRUFBMEVwQixPQUFPLFNBQWpGLEVBaERhLEVBaURiLEVBQUNuRyxJQUFJLE1BQUwsRUFBYWhCLFFBQVEsS0FBckIsRUFBNEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWhCLEVBQXlCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBekIsQ0FBdEMsRUFBMEVwQixPQUFPLFNBQWpGLEVBakRhLEVBbURiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBbkRhLEVBb0RiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBcERhLEVBcURiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWhCLEVBQXlCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBekIsQ0FBeEMsRUFBNEVwQixPQUFPLFNBQW5GLEVBckRhLEVBc0RiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWhCLEVBQXlCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBekIsQ0FBeEMsRUFBNEVwQixPQUFPLFNBQW5GLEVBdERhLEVBdURiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBdkRhLEVBd0RiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBeERhLEVBeURiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBekRhLEVBMERiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBMURhLEVBNERiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBNURhLEVBNkRiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWhCLEVBQXlCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBekIsQ0FBeEMsRUFBNEVwQixPQUFP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RUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBekZhLEVBMEZiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBMUZhLEVBMkZiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBM0ZhLEVBNEZiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBNUZhLEVBOEZiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUIsQ0FBeEMsRUFBNkVwQixPQUFPLFNBQXBGLEVBOUZhLEVBK0ZiLEVBQUNuRyxJQUFJLE9BQUwsRUFBY2hCLFFBQVEsTUFBdEIsRUFBOEJwQixVQUFVLGdCQUFTMkosTUFBVCxDQUFnQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWhCLEVBQTBCLENBQUMsRUFB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QUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDLGNBQWMsbW9xQiIsImZpbGUiOiJ0aW1lbGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDQzNzIxNGE2OGM2YWJiNzQ1MWJkIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiUmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcImNsYXNzbmFtZXNcIiksIHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwiY2xhc3NuYW1lc1wiLCBcInByb3AtdHlwZXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSwgcmVxdWlyZShcInByb3AtdHlwZXNcIikpIDogZmFjdG9yeShyb290W1wiUmVhY3RcIl0sIHJvb3RbXCJjbGFzc05hbWVzXCJdLCByb290W1wiUHJvcFR5cGVzXCJdKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGYwMGRiMTA1MmJhMTI2OTMxZTUyXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIGYwMGRiMTA1MmJhMTI2OTMxZTUyIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9XG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiaW1wb3J0IFRpbWUgZnJvbSAnLi9UaW1lJ1xuLyoqXG4gKiDkuIDluqbnlJ/miJDjgZfjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjga/lpInmm7TjgZfjgb7jgZvjgpPjgIJcbiAqIOWkieabtOODoeOCveODg+ODieOBr+aWsOOBl+OBhOOCquODluOCuOOCp+OCr+ODiOOCkuW4sOOBl+OBvuOBmeOAglxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lU3Bhblxue1xuICBzdGF0aWMgY3JlYXRlKHN0YXJ0LCBlbmQpe1xuICAgICAgcmV0dXJuIG5ldyBUaW1lU3BhbihuZXcgVGltZShzdGFydFswXSwgc3RhcnRbMV0pLCBuZXcgVGltZShlbmRbMF0sIGVuZFsxXSkpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc3RhcnRUaW1lLCBlbmRUaW1lKXtcbiAgICBpZihzdGFydFRpbWUgPT09IHVuZGVmaW5lZCl7XG4gICAgICBzdGFydFRpbWUgPSBuZXcgVGltZSgpO1xuICAgIH1cbiAgICBpZihlbmRUaW1lID09PSB1bmRlZmluZWQpe1xuICAgICAgZW5kVGltZSA9IG5ldyBUaW1lKCk7XG4gICAgfVxuICAgIHdoaWxlKHN0YXJ0VGltZS5jb21wYXJlKGVuZFRpbWUpID49IDApe1xuICAgICAgICBlbmRUaW1lID0gZW5kVGltZS5hZGRNaW4oMjQgKiA2MCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHRoaXMuX2VuZFRpbWUgPSBlbmRUaW1lO1xuICB9XG5cbiAgY2xvbmUoKXtcbiAgICAgIHJldHVybiBuZXcgVGltZVNwYW4odGhpcy5nZXRTdGFydFRpbWUoKS5jbG9uZSgpLCB0aGlzLmdldEVuZFRpbWUoKS5jbG9uZSgpKTtcbiAgfVxuXG4gIGdldERpc3RhbmNlKCl7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lLmdldERpc3RhbmNlKHRoaXMuX2VuZFRpbWUpO1xuICB9XG5cbiAgZ2V0U3RhcnRUaW1lKCl7IHJldHVybiB0aGlzLl9zdGFydFRpbWU7IH1cbiAgZ2V0RW5kVGltZSgpeyByZXR1cm4gdGhpcy5fZW5kVGltZTsgfVxuXG4gIHNoaWZ0RW5kVGltZSh0aW1lKXtcbiAgICAgIHJldHVybiBuZXcgVGltZVNwYW4odGltZS5hZGRNaW4oLXRoaXMuZ2V0RGlzdGFuY2UoKSksIHRpbWUpO1xuICB9XG5cbiAgc2hpZnRTdGFydEhvdXIoaG91cil7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRTdGFydFRpbWUobmV3IFRpbWUoaG91ciwgdGhpcy5fc3RhcnRUaW1lLmdldE1pbigpKSk7XG4gIH1cblxuICBzaGlmdFN0YXJ0TWluKG1pbil7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRTdGFydFRpbWUobmV3IFRpbWUodGhpcy5fc3RhcnRUaW1lLmdldEhvdXIoKSwgbWluKSk7XG4gIH1cblxuICBzaGlmdFN0YXJ0VGltZSh0aW1lKXtcbiAgICAgIHJldHVybiBuZXcgVGltZVNwYW4odGltZSwgdGltZS5hZGRNaW4odGhpcy5nZXREaXN0YW5jZSgpKSk7XG4gIH1cblxuICBhZGRNaW4obWludXRlKXtcbiAgICByZXR1cm4gbmV3IFRpbWVTcGFuKHRoaXMuZ2V0U3RhcnRUaW1lKCksIHRoaXMuZ2V0RW5kVGltZSgpLmFkZE1pbihtaW51dGUpKTtcbiAgfVxuXG4gIGVxdWFscyh0aW1lU3Bhbil7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGFydFRpbWUoKS5lcXVhbHModGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpICYmIHRoaXMuZ2V0RW5kVGltZSgpLmVxdWFscyh0aW1lU3Bhbi5nZXRFbmRUaW1lKCkpO1xuICB9XG5cbiAgY29udGFpbnModGltZVNwYW4pe1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRUaW1lKCkuY29tcGFyZSh0aW1lU3Bhbi5nZXRTdGFydFRpbWUoKSkgPCAwICYmIHRoaXMuZ2V0RW5kVGltZSgpLmNvbXBhcmUodGltZVNwYW4uZ2V0RW5kVGltZSgpKSA+IDA7XG4gIH1cblxuICBjb250YWluc1RpbWUodGltZSl7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGFydFRpbWUoKS5jb21wYXJlKHRpbWUpIDwgMCAmJiB0aGlzLmdldEVuZFRpbWUoKS5jb21wYXJlKHRpbWUpID4gMDtcbiAgfVxuXG4gIG92ZXJsYXBzKHRpbWVTcGFuKXtcbiAgICAgIGlmKHRpbWVTcGFuLmNvbnRhaW5zKHRoaXMpKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5jb250YWluc1RpbWUodGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5jb250YWluc1RpbWUodGltZVNwYW4uZ2V0RW5kVGltZSgpKSl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGVhY2hIb3VyKGNhbGxiYWNrKXtcbiAgICAgIHZhciBob3VyID0gdGhpcy5nZXRTdGFydFRpbWUoKS5nZXRIb3VyKCk7XG4gICAgICB2YXIgZW5kID0gdGhpcy5nZXRFbmRUaW1lKCkuZ2V0SG91cigpO1xuICAgICAgdmFyIGtleSA9IDA7XG5cbiAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgIGlmKGhvdXIgPT09IGVuZCl7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoaG91ciwga2V5LCBob3VyLCB0aGlzLmdldEVuZFRpbWUoKS5nZXRNaW4oKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoaG91ciwga2V5LCBob3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob3VyICs9IDE7XG4gICAgICAgICAgKytrZXk7XG4gICAgICB9XG4gIH1cblxuICBlYWNoVGltZShjYWxsYmFjaywgbWludXRlSW50ZXJ2YWwpe1xuICAgICAgdmFyIGtleSA9IDA7XG4gICAgICBtaW51dGVJbnRlcnZhbCA9IG1pbnV0ZUludGVydmFsID8gbWludXRlSW50ZXJ2YWwgOiA2MDtcblxuICAgICAgdmFyIHRpbWUgPSB0aGlzLmdldFN0YXJ0VGltZSgpO1xuICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgaWYodGltZS5jb21wYXJlKHRoaXMuZ2V0RW5kVGltZSgpKSA+IDApe1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRpbWUsIGtleSwgdGltZSk7XG5cbiAgICAgICAgICB0aW1lID0gdGltZS5hZGRNaW4obWludXRlSW50ZXJ2YWwpO1xuICAgICAgICAgICsra2V5O1xuICAgICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWUgKyAnficgKyB0aGlzLl9lbmRUaW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2xhc3Nlcy9UaW1lU3Bhbi5lczZcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9zcmMvY2xhc3Nlcy9UaW1lU3Bhbi5lczYiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcImNsYXNzTmFtZXNcIixcImNvbW1vbmpzMlwiOlwiY2xhc3NuYW1lc1wiLFwiY29tbW9uanNcIjpcImNsYXNzbmFtZXNcIixcImFtZFwiOlwiY2xhc3NuYW1lc1wifVxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovZXh0ZXJuYWwge1wicm9vdFwiOlwiY2xhc3NOYW1lc1wiLFwiY29tbW9uanMyXCI6XCJjbGFzc25hbWVzXCIsXCJjb21tb25qc1wiOlwiY2xhc3NuYW1lc1wiLFwiYW1kXCI6XCJjbGFzc25hbWVzXCJ9IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGltZVNwYW4gZnJvbSAnLi4vY2xhc3Nlcy9UaW1lU3Bhbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG57XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBob3VyczogW11cbiAgICB9XG4gICAgdGhpcy5wcm9wcy50aW1lU3Bhbi5lYWNoVGltZSgoa2V5LCB0aW1lKSA9PiB7XG4gICAgICBpZighdGltZS5lcXVhbHModGhpcy5wcm9wcy50aW1lU3Bhbi5nZXRFbmRUaW1lKCkpKXtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgLy9ib3JkZXIxcHjjgpLotrPjgZlcbiAgICAgICAgICBoZWlnaHQ6ICh0aGlzLnByb3BzLm1pbkhlaWdodCArIDEpICogNFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuaG91cnMucHVzaChcbiAgICAgICAgICA8ZGl2IGtleT17dGltZS5nZXRIb3VyKCl9IHN0eWxlPXtzdHlsZX0+e3RpbWUuZ2V0RGlzcGxheUhvdXIoKX08L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRsUnVsZXJWaWV3XCIgc3R5bGU9e3t3aWR0aDogUnVsZXIud2lkdGggKyAncHgnfX0+e3RoaXMuc3RhdGUuaG91cnN9PC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG4vLyBSdWxlci5wcm9wVHlwZXMgPSB7XG4vLyAgIG1pbkhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuLy8gICB0aW1lU3BhbjogUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoVGltZVNwYW4pLmlzUmVxdWlyZWRcbi8vIH1cblxuUnVsZXIud2lkdGggPSAzMDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL1J1bGVyLmpzeFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1J1bGVyLmpzeCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUHJvcFR5cGVzXCIsXCJjb21tb25qczJcIjpcInByb3AtdHlwZXNcIixcImNvbW1vbmpzXCI6XCJwcm9wLXR5cGVzXCIsXCJhbWRcIjpcInByb3AtdHlwZXNcIn1cbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6L2V4dGVybmFsIHtcInJvb3RcIjpcIlByb3BUeXBlc1wiLFwiY29tbW9uanMyXCI6XCJwcm9wLXR5cGVzXCIsXCJjb21tb25qc1wiOlwicHJvcC10eXBlc1wiLFwiYW1kXCI6XCJwcm9wLXR5cGVzXCJ9IiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRU5EX0RSQUcgPSBleHBvcnRzLkRST1AgPSBleHBvcnRzLkhPVkVSID0gZXhwb3J0cy5QVUJMSVNIX0RSQUdfU09VUkNFID0gZXhwb3J0cy5CRUdJTl9EUkFHID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmJlZ2luRHJhZyA9IGJlZ2luRHJhZztcbmV4cG9ydHMucHVibGlzaERyYWdTb3VyY2UgPSBwdWJsaXNoRHJhZ1NvdXJjZTtcbmV4cG9ydHMuaG92ZXIgPSBob3ZlcjtcbmV4cG9ydHMuZHJvcCA9IGRyb3A7XG5leHBvcnRzLmVuZERyYWcgPSBlbmREcmFnO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheScpO1xuXG52YXIgX2lzQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheSk7XG5cbnZhciBfaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxudmFyIF9pc09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc09iamVjdCk7XG5cbnZhciBfbWF0Y2hlc1R5cGUgPSByZXF1aXJlKCcuLi91dGlscy9tYXRjaGVzVHlwZScpO1xuXG52YXIgX21hdGNoZXNUeXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoZXNUeXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEJFR0lOX0RSQUcgPSBleHBvcnRzLkJFR0lOX0RSQUcgPSAnZG5kLWNvcmUvQkVHSU5fRFJBRyc7XG52YXIgUFVCTElTSF9EUkFHX1NPVVJDRSA9IGV4cG9ydHMuUFVCTElTSF9EUkFHX1NPVVJDRSA9ICdkbmQtY29yZS9QVUJMSVNIX0RSQUdfU09VUkNFJztcbnZhciBIT1ZFUiA9IGV4cG9ydHMuSE9WRVIgPSAnZG5kLWNvcmUvSE9WRVInO1xudmFyIERST1AgPSBleHBvcnRzLkRST1AgPSAnZG5kLWNvcmUvRFJPUCc7XG52YXIgRU5EX0RSQUcgPSBleHBvcnRzLkVORF9EUkFHID0gJ2RuZC1jb3JlL0VORF9EUkFHJztcblxuZnVuY3Rpb24gYmVnaW5EcmFnKHNvdXJjZUlkcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyBwdWJsaXNoU291cmNlOiB0cnVlLCBjbGllbnRPZmZzZXQ6IG51bGwgfTtcbiAgdmFyIHB1Ymxpc2hTb3VyY2UgPSBvcHRpb25zLnB1Ymxpc2hTb3VyY2UsXG4gICAgICBjbGllbnRPZmZzZXQgPSBvcHRpb25zLmNsaWVudE9mZnNldCxcbiAgICAgIGdldFNvdXJjZUNsaWVudE9mZnNldCA9IG9wdGlvbnMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzQXJyYXkyLmRlZmF1bHQpKHNvdXJjZUlkcyksICdFeHBlY3RlZCBzb3VyY2VJZHMgdG8gYmUgYW4gYXJyYXkuJyk7XG5cbiAgdmFyIG1vbml0b3IgPSB0aGlzLmdldE1vbml0b3IoKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5nZXRSZWdpc3RyeSgpO1xuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoIW1vbml0b3IuaXNEcmFnZ2luZygpLCAnQ2Fubm90IGNhbGwgYmVnaW5EcmFnIHdoaWxlIGRyYWdnaW5nLicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZHNbaV0pLCAnRXhwZWN0ZWQgc291cmNlSWRzIHRvIGJlIHJlZ2lzdGVyZWQuJyk7XG4gIH1cblxuICB2YXIgc291cmNlSWQgPSBudWxsO1xuICBmb3IgKHZhciBfaSA9IHNvdXJjZUlkcy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgaWYgKG1vbml0b3IuY2FuRHJhZ1NvdXJjZShzb3VyY2VJZHNbX2ldKSkge1xuICAgICAgc291cmNlSWQgPSBzb3VyY2VJZHNbX2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VJZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzb3VyY2VDbGllbnRPZmZzZXQgPSBudWxsO1xuICBpZiAoY2xpZW50T2Zmc2V0KSB7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBnZXRTb3VyY2VDbGllbnRPZmZzZXQgPT09ICdmdW5jdGlvbicsICdXaGVuIGNsaWVudE9mZnNldCBpcyBwcm92aWRlZCwgZ2V0U291cmNlQ2xpZW50T2Zmc2V0IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBzb3VyY2VDbGllbnRPZmZzZXQgPSBnZXRTb3VyY2VDbGllbnRPZmZzZXQoc291cmNlSWQpO1xuICB9XG5cbiAgdmFyIHNvdXJjZSA9IHJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZCk7XG4gIHZhciBpdGVtID0gc291cmNlLmJlZ2luRHJhZyhtb25pdG9yLCBzb3VyY2VJZCk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzT2JqZWN0Mi5kZWZhdWx0KShpdGVtKSwgJ0l0ZW0gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG5cbiAgcmVnaXN0cnkucGluU291cmNlKHNvdXJjZUlkKTtcblxuICB2YXIgaXRlbVR5cGUgPSByZWdpc3RyeS5nZXRTb3VyY2VUeXBlKHNvdXJjZUlkKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBCRUdJTl9EUkFHLFxuICAgIGl0ZW1UeXBlOiBpdGVtVHlwZSxcbiAgICBpdGVtOiBpdGVtLFxuICAgIHNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldCxcbiAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCxcbiAgICBpc1NvdXJjZVB1YmxpYzogcHVibGlzaFNvdXJjZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwdWJsaXNoRHJhZ1NvdXJjZSgpIHtcbiAgdmFyIG1vbml0b3IgPSB0aGlzLmdldE1vbml0b3IoKTtcbiAgaWYgKCFtb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IFBVQkxJU0hfRFJBR19TT1VSQ0UgfTtcbn1cblxuZnVuY3Rpb24gaG92ZXIodGFyZ2V0SWRzQXJnKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkY2xpZW50T2Zmc2V0ID0gX3JlZi5jbGllbnRPZmZzZXQsXG4gICAgICBjbGllbnRPZmZzZXQgPSBfcmVmJGNsaWVudE9mZnNldCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkY2xpZW50T2Zmc2V0O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzQXJyYXkyLmRlZmF1bHQpKHRhcmdldElkc0FyZyksICdFeHBlY3RlZCB0YXJnZXRJZHMgdG8gYmUgYW4gYXJyYXkuJyk7XG4gIHZhciB0YXJnZXRJZHMgPSB0YXJnZXRJZHNBcmcuc2xpY2UoMCk7XG5cbiAgdmFyIG1vbml0b3IgPSB0aGlzLmdldE1vbml0b3IoKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5nZXRSZWdpc3RyeSgpO1xuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBob3ZlciB3aGlsZSBub3QgZHJhZ2dpbmcuJyk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSghbW9uaXRvci5kaWREcm9wKCksICdDYW5ub3QgY2FsbCBob3ZlciBhZnRlciBkcm9wLicpO1xuXG4gIC8vIEZpcnN0IGNoZWNrIGludmFyaWFudHMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRhcmdldElkID0gdGFyZ2V0SWRzW2ldO1xuICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0YXJnZXRJZHMubGFzdEluZGV4T2YodGFyZ2V0SWQpID09PSBpLCAnRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIHVuaXF1ZSBpbiB0aGUgcGFzc2VkIGFycmF5LicpO1xuXG4gICAgdmFyIHRhcmdldCA9IHJlZ2lzdHJ5LmdldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRhcmdldCwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSByZWdpc3RlcmVkLicpO1xuICB9XG5cbiAgdmFyIGRyYWdnZWRJdGVtVHlwZSA9IG1vbml0b3IuZ2V0SXRlbVR5cGUoKTtcblxuICAvLyBSZW1vdmUgdGhvc2UgdGFyZ2V0SWRzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIHRhcmdldFR5cGUuICBUaGlzXG4gIC8vIGZpeGVzIHNoYWxsb3cgaXNPdmVyIHdoaWNoIHdvdWxkIG9ubHkgYmUgbm9uLXNoYWxsb3cgYmVjYXVzZSBvZlxuICAvLyBub24tbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgZm9yICh2YXIgX2kyID0gdGFyZ2V0SWRzLmxlbmd0aCAtIDE7IF9pMiA+PSAwOyBfaTItLSkge1xuICAgIHZhciBfdGFyZ2V0SWQgPSB0YXJnZXRJZHNbX2kyXTtcbiAgICB2YXIgdGFyZ2V0VHlwZSA9IHJlZ2lzdHJ5LmdldFRhcmdldFR5cGUoX3RhcmdldElkKTtcbiAgICBpZiAoISgwLCBfbWF0Y2hlc1R5cGUyLmRlZmF1bHQpKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgIHRhcmdldElkcy5zcGxpY2UoX2kyLCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5hbGx5IGNhbGwgaG92ZXIgb24gYWxsIG1hdGNoaW5nIHRhcmdldHMuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHRhcmdldElkcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF90YXJnZXRJZDIgPSB0YXJnZXRJZHNbX2kzXTtcbiAgICB2YXIgX3RhcmdldCA9IHJlZ2lzdHJ5LmdldFRhcmdldChfdGFyZ2V0SWQyKTtcbiAgICBfdGFyZ2V0LmhvdmVyKG1vbml0b3IsIF90YXJnZXRJZDIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBIT1ZFUixcbiAgICB0YXJnZXRJZHM6IHRhcmdldElkcyxcbiAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBkcm9wKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgbW9uaXRvciA9IHRoaXMuZ2V0TW9uaXRvcigpO1xuICB2YXIgcmVnaXN0cnkgPSB0aGlzLmdldFJlZ2lzdHJ5KCk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShtb25pdG9yLmlzRHJhZ2dpbmcoKSwgJ0Nhbm5vdCBjYWxsIGRyb3Agd2hpbGUgbm90IGRyYWdnaW5nLicpO1xuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoIW1vbml0b3IuZGlkRHJvcCgpLCAnQ2Fubm90IGNhbGwgZHJvcCB0d2ljZSBkdXJpbmcgb25lIGRyYWcgb3BlcmF0aW9uLicpO1xuXG4gIHZhciB0YXJnZXRJZHMgPSBtb25pdG9yLmdldFRhcmdldElkcygpLmZpbHRlcihtb25pdG9yLmNhbkRyb3BPblRhcmdldCwgbW9uaXRvcik7XG5cbiAgdGFyZ2V0SWRzLnJldmVyc2UoKTtcbiAgdGFyZ2V0SWRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldElkLCBpbmRleCkge1xuICAgIHZhciB0YXJnZXQgPSByZWdpc3RyeS5nZXRUYXJnZXQodGFyZ2V0SWQpO1xuXG4gICAgdmFyIGRyb3BSZXN1bHQgPSB0YXJnZXQuZHJvcChtb25pdG9yLCB0YXJnZXRJZCk7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBkcm9wUmVzdWx0ID09PSAndW5kZWZpbmVkJyB8fCAoMCwgX2lzT2JqZWN0Mi5kZWZhdWx0KShkcm9wUmVzdWx0KSwgJ0Ryb3AgcmVzdWx0IG11c3QgZWl0aGVyIGJlIGFuIG9iamVjdCBvciB1bmRlZmluZWQuJyk7XG4gICAgaWYgKHR5cGVvZiBkcm9wUmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZHJvcFJlc3VsdCA9IGluZGV4ID09PSAwID8ge30gOiBtb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG5cbiAgICBfdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBEUk9QLFxuICAgICAgZHJvcFJlc3VsdDogX2V4dGVuZHMoe30sIG9wdGlvbnMsIGRyb3BSZXN1bHQpXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmREcmFnKCkge1xuICB2YXIgbW9uaXRvciA9IHRoaXMuZ2V0TW9uaXRvcigpO1xuICB2YXIgcmVnaXN0cnkgPSB0aGlzLmdldFJlZ2lzdHJ5KCk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShtb25pdG9yLmlzRHJhZ2dpbmcoKSwgJ0Nhbm5vdCBjYWxsIGVuZERyYWcgd2hpbGUgbm90IGRyYWdnaW5nLicpO1xuXG4gIHZhciBzb3VyY2VJZCA9IG1vbml0b3IuZ2V0U291cmNlSWQoKTtcbiAgdmFyIHNvdXJjZSA9IHJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZCwgdHJ1ZSk7XG4gIHNvdXJjZS5lbmREcmFnKG1vbml0b3IsIHNvdXJjZUlkKTtcblxuICByZWdpc3RyeS51bnBpblNvdXJjZSgpO1xuXG4gIHJldHVybiB7IHR5cGU6IEVORF9EUkFHIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL2FjdGlvbnMvZHJhZ0Ryb3AuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvYWN0aW9ucy9kcmFnRHJvcC5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRTb3VyY2UgPSBhZGRTb3VyY2U7XG5leHBvcnRzLmFkZFRhcmdldCA9IGFkZFRhcmdldDtcbmV4cG9ydHMucmVtb3ZlU291cmNlID0gcmVtb3ZlU291cmNlO1xuZXhwb3J0cy5yZW1vdmVUYXJnZXQgPSByZW1vdmVUYXJnZXQ7XG52YXIgQUREX1NPVVJDRSA9IGV4cG9ydHMuQUREX1NPVVJDRSA9ICdkbmQtY29yZS9BRERfU09VUkNFJztcbnZhciBBRERfVEFSR0VUID0gZXhwb3J0cy5BRERfVEFSR0VUID0gJ2RuZC1jb3JlL0FERF9UQVJHRVQnO1xudmFyIFJFTU9WRV9TT1VSQ0UgPSBleHBvcnRzLlJFTU9WRV9TT1VSQ0UgPSAnZG5kLWNvcmUvUkVNT1ZFX1NPVVJDRSc7XG52YXIgUkVNT1ZFX1RBUkdFVCA9IGV4cG9ydHMuUkVNT1ZFX1RBUkdFVCA9ICdkbmQtY29yZS9SRU1PVkVfVEFSR0VUJztcblxuZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICBzb3VyY2VJZDogc291cmNlSWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkVGFyZ2V0KHRhcmdldElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1RBUkdFVCxcbiAgICB0YXJnZXRJZDogdGFyZ2V0SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKHNvdXJjZUlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX1NPVVJDRSxcbiAgICBzb3VyY2VJZDogc291cmNlSWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX1RBUkdFVCxcbiAgICB0YXJnZXRJZDogdGFyZ2V0SWRcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvYWN0aW9ucy9yZWdpc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9hY3Rpb25zL3JlZ2lzdHJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tEZWNvcmF0b3JBcmd1bWVudHM7XG5mdW5jdGlvbiBjaGVja0RlY29yYXRvckFyZ3VtZW50cyhmdW5jdGlvbk5hbWUsIHNpZ25hdHVyZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMik7IGkgKz0gMSkge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDJdO1xuICAgICAgaWYgKGFyZyAmJiBhcmcucHJvdG90eXBlICYmIGFyZy5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAnWW91IHNlZW0gdG8gYmUgYXBwbHlpbmcgdGhlIGFyZ3VtZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIuICcgKyAoJ0l0IHNob3VsZCBiZSAnICsgZnVuY3Rpb25OYW1lICsgJygnICsgc2lnbmF0dXJlICsgJykoQ29tcG9uZW50KSwgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLiAnKSArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLXRyb3VibGVzaG9vdGluZy5odG1sI3lvdS1zZWVtLXRvLWJlLWFwcGx5aW5nLXRoZS1hcmd1bWVudHMtaW4tdGhlLXdyb25nLW9yZGVyJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi91dGlscy9jaGVja0RlY29yYXRvckFyZ3VtZW50cy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGltZVNwYW4gZnJvbSAnLi4vY2xhc3Nlcy9UaW1lU3Bhbic7XG5pbXBvcnQgRnJhbWUgZnJvbSAnLi9GcmFtZSc7XG5pbXBvcnQgUnVsZXIgZnJvbSAnLi9SdWxlcic7XG5pbXBvcnQgTGluZSBmcm9tICcuL0xpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxue1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuXG4gICAgdGhpcy50aW1lU3BhbiA9IHRoaXMucHJvcHMudGltZVNwYW47XG5cbiAgICAvL21pblZpZXfjgYzjgYTjgY/jgaTjgYLjgovjgYvjgqvjgqbjg7Pjg4jjgIJtaW5WaWV344GvMTXliIbjgYrjgY3jgILjgZ3jgozjgpLlhYPjgavpq5jjgZXjgpLoqIjnrpfjgIJib3JkZXLliIYxcHjotrPjgZlcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAodGhpcy50aW1lU3Bhbi5nZXREaXN0YW5jZSgpIC8gMTUpICogKHRoaXMucHJvcHMubWluSGVpZ2h0ICsgMSk7XG5cbiAgICAvLzHliIbjgYLjgZ/jgorjga7pq5jjgZXjgpLnrpflh7pcbiAgICB0aGlzLnBlck1pbkhlaWdodCA9IHRoaXMubGluZUhlaWdodCAvIHRoaXMudGltZVNwYW4uZ2V0RGlzdGFuY2UoKTtcblxuICAgIHRoaXMubGluZVdpZHRoID0gcHJvcHMubGluZVdpZHRoO1xuXG4gICAgdGhpcy5jcmVhdGVkRXZlbnRJZCA9IDA7XG4gICAgdGhpcy5kcmFnZ2luZ092ZXJMaW5lQ29tcG9uZW50ID0gbnVsbDtcblxuICAgIHRoaXMuZnJhbWVDb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ldmVudENvbXBvbmVudHMgPSBbXVxuICB9XG5cbiAgZ2V0IGxpbmVDb21wb25lbnRzKCl7XG4gICAgLy8gcmVmc+OBr+OCquODluOCuOOCp+OCr+ODiOOBquOBruOBp+mghueVquOBruS/neiovOOBjOOBquOBhOOBn+OCgURPTeOBi+OCieOBqOOCiuOBvuOBmeOAglxuICAgIGNvbnN0IGxpbmVzID0gdGhpcy5mcmFtZUNvbXBvbmVudC5yZWZzLmxpbmVzV3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCcudGxMaW5lV3JhcHBlcicpO1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaW5lcykubWFwKGVsZW0gPT4ge1xuICAgICAgY29uc3QgaWQgPSBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpXG4gICAgICByZXR1cm4gdGhpcy5mcmFtZUNvbXBvbmVudC5yZWZzWydsaW5lQCcgKyBpZF1cbiAgICB9KVxuICB9XG5cbiAgZ2V0IGxhc3RMaW5lKCl7XG4gICAgdmFyIGxpbmVzID0gdGhpcy5saW5lQ29tcG9uZW50c1xuICAgIHJldHVybiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXVxuICB9XG5cbiAgZHJhZ2dpbmdPdmVyKGxlZnQpe1xuXG4gICAgY29uc3QgbGluZUNvbXBvbmVudCA9IHRoaXMuZmluZExpbmVCeUxlZnQobGVmdCk7XG4gICAgaWYobGluZUNvbXBvbmVudCl7XG4gICAgICBpZih0aGlzLmRyYWdnaW5nT3ZlckxpbmVDb21wb25lbnQgIT09IGxpbmVDb21wb25lbnQpe1xuICAgICAgICBpZih0aGlzLmRyYWdnaW5nT3ZlckxpbmVDb21wb25lbnQpe1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmdPdmVyTGluZUNvbXBvbmVudC5jbGVhckRyYWdnaW5nT3ZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdPdmVyTGluZUNvbXBvbmVudCA9IGxpbmVDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdPdmVyTGluZUNvbXBvbmVudC5kcmFnZ2luZ092ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGhpcy5kcmFnZ2luZ092ZXJMaW5lQ29tcG9uZW50KXtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ092ZXJMaW5lQ29tcG9uZW50LmNsZWFyRHJhZ2dpbmdPdmVyKCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdPdmVyTGluZUNvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVDb21wb25lbnQ7XG4gIH1cblxuICBjbGVhckRyYWdnaW5nT3Zlcigpe1xuICAgIGlmKHRoaXMuZHJhZ2dpbmdPdmVyTGluZUNvbXBvbmVudCl7XG4gICAgICB0aGlzLmRyYWdnaW5nT3ZlckxpbmVDb21wb25lbnQuY2xlYXJEcmFnZ2luZ092ZXIoKTtcbiAgICB9XG4gIH1cblxuICBnZXRUb3RhbFdpZHRoKCl7XG4gICAgaWYodGhpcy50b3RhbFdpZHRoQ2FjaGUgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnRvdGFsV2lkdGhDYWNoZSA9IHRoaXMucHJvcHMubGluZURhdGEucmVkdWNlKCh2YWwsIGRhdGEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1J1bGVyID0gaW5kZXggJSB0aGlzLnByb3BzLnJ1bGVySW50ZXJ2YWwgPT09IDA7XG4gICAgICAgIHJldHVybiB2YWwgKyAoaGFzUnVsZXIgPyB0aGlzLmxpbmVXaWR0aCArIFJ1bGVyLndpZHRoIDogdGhpcy5saW5lV2lkdGgpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG90YWxXaWR0aENhY2hlXG4gIH1cblxuICBmaW5kRXZlbnRCeUlkKGV2ZW50SWQpe1xuICAgIHJldHVybiB0aGlzLmV2ZW50Q29tcG9uZW50cy5maW5kKGV2ID0+IGV2LnByb3BzLmlkID09IGV2ZW50SWQpO1xuICB9XG5cbiAgZmluZExpbmVCeUxlZnQobGVmdCl7XG4gICAgdmFyIHdpZHRoID0gMDtcbiAgICByZXR1cm4gdGhpcy5saW5lQ29tcG9uZW50cy5maW5kKGxpbmUgPT4ge1xuICAgICAgd2lkdGggKz0gbGluZS5wcm9wcy5oYXNSdWxlciA/IHRoaXMucHJvcHMubGluZVdpZHRoICsgUnVsZXIud2lkdGggOiB0aGlzLnByb3BzLmxpbmVXaWR0aDtcbiAgICAgIGlmKGxlZnQgPCB3aWR0aCl7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0TGluZUxlZnQobGluZUlkKXtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxpbmVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lRGF0YSA9IHRoaXMucHJvcHMubGluZURhdGFbaV07XG4gICAgICBjb25zdCBoYXNSdWxlciA9IGkgJSB0aGlzLnByb3BzLnJ1bGVySW50ZXJ2YWwgPT09IDA7XG4gICAgICBpZihoYXNSdWxlcil7XG4gICAgICAgIGxlZnQgKz0gUnVsZXIud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmKGxpbmVEYXRhLmlkID09IGxpbmVJZCl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZWZ0ICs9IHRoaXMucHJvcHMubGluZVdpZHRoO1xuICAgIH1cblxuICAgIGxlZnQgKz0gTGluZS5zaWRlUGFkZGluZztcblxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgZ2V0VGltZVNwYW4odG9wLCBoZWlnaHQpe1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMudG9wVG9UaW1lKHRvcCk7XG5cbiAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lLmFkZE1pbihoZWlnaHQgLyB0aGlzLnBlck1pbkhlaWdodCk7XG4gICAgcmV0dXJuIG5ldyBUaW1lU3BhbihzdGFydFRpbWUsIGVuZFRpbWUpO1xuICB9XG5cbiAgbWludXRlVG9IZWlnaHQobWludXRlKXtcbiAgICByZXR1cm4gKG1pbnV0ZSAqIHRoaXMucGVyTWluSGVpZ2h0KSAtIDE7XG4gIH1cblxuICB0aW1lU3BhblRvSGVpZ2h0KHRpbWVTcGFuKXtcbiAgICByZXR1cm4gdGhpcy5taW51dGVUb0hlaWdodCh0aW1lU3Bhbi5nZXREaXN0YW5jZSgpKTtcbiAgfVxuXG4gIHRpbWVUb1RvcCh0aW1lKXtcbiAgICByZXR1cm4gdGhpcy50aW1lU3Bhbi5nZXRTdGFydFRpbWUoKS5nZXREaXN0YW5jZSh0aW1lKSAqIHRoaXMucGVyTWluSGVpZ2h0IC0gMTtcbiAgfVxuXG4gIHRvcFRvVGltZSh0b3Ape1xuICAgIGlmKHRvcCA8PSAwKXtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVTcGFuLmdldFN0YXJ0VGltZSgpO1xuICAgIH1cbiAgICBsZXQgbWludXRlID0gdG9wIC8gdGhpcy5wZXJNaW5IZWlnaHQ7XG4gICAgY29uc3QgcmVzdCA9IG1pbnV0ZSAlIHRoaXMucHJvcHMubWluSW50ZXJ2YWw7XG4gICAgaWYocmVzdCAhPT0gMCl7XG4gICAgICBpZihyZXN0ID4gdGhpcy5wcm9wcy5taW5JbnRlcnZhbCAvIDIpe1xuICAgICAgICBtaW51dGUgKz0gdGhpcy5wcm9wcy5taW5JbnRlcnZhbCAtIHJlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW51dGUgLT0gcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkuYWRkTWluKG1pbnV0ZSk7XG4gIH1cblxuICBmaW5kUHJldkV2ZW50KGV2ZW50Q29tcG9uZW50KXtcbiAgICByZXR1cm4gdGhpcy5ldmVudENvbXBvbmVudHNcbiAgICAgIC5maWx0ZXIoZXYgPT4gIWV2LnN0YXRlLmRyYWdnYWJsZSAmJiBldi5saW5lSWQgPT0gZXZlbnRDb21wb25lbnQubGluZUlkKS8v5ZCM44GY5YiX44Gu44KC44Gu44Gg44GR44Gr57We44KLXG4gICAgICAuc29ydCgoYSwgYikgPT4gLShhLmN1cnJlbnRUaW1lU3Bhbi5nZXRTdGFydFRpbWUoKS5jb21wYXJlKGIuY3VycmVudFRpbWVTcGFuLmdldFN0YXJ0VGltZSgpKSkpLy/mmYLplpPjga7pmY3poIbjgafkuKbjgbPmm7/jgYhcbiAgICAgIC5maW5kKGV2ID0+IGV2LmN1cnJlbnRUaW1lU3Bhbi5nZXRFbmRUaW1lKCkuY29tcGFyZShldmVudENvbXBvbmVudC5jdXJyZW50VGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpIDw9IDApLy/pmY3poIbjgarjga7jgaflr77osaHjgojjgormnIDliJ3jgavplovlp4vmmYLplpPjgYzoi6XjgYTjgoLjga7jgYxwcmV2XG4gICAgICA7XG4gIH1cblxuICBnZXRQcmV2Qm90dG9tKGV2ZW50Q29tcG9uZW50KXtcbiAgICBjb25zdCBwcmV2RXZlbnQgPSB0aGlzLmZpbmRQcmV2RXZlbnQoZXZlbnRDb21wb25lbnQpO1xuICAgIGxldCBib3R0b21UaW1lO1xuICAgIGlmKHByZXZFdmVudCl7XG4gICAgICBib3R0b21UaW1lID0gcHJldkV2ZW50LmN1cnJlbnRUaW1lU3Bhbi5nZXRFbmRUaW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdHRvbVRpbWUgPSB0aGlzLnRpbWVTcGFuLmdldFN0YXJ0VGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpbWVUb1RvcChib3R0b21UaW1lKTtcbiAgfVxuXG4gIGZpbmROZXh0RXZlbnQoZXZlbnRDb21wb25lbnQpe1xuICAgIHJldHVybiB0aGlzLmZpbmROZXh0RXZlbnRCeVRpbWUoZXZlbnRDb21wb25lbnQubGluZUlkLCBldmVudENvbXBvbmVudC5jdXJyZW50VGltZVNwYW4uZ2V0RW5kVGltZSgpKTtcbiAgfVxuXG4gIGZpbmROZXh0RXZlbnRCeVRpbWUobGluZUlkLCB0aW1lKXtcbiAgICByZXR1cm4gdGhpcy5ldmVudENvbXBvbmVudHNcbiAgICAgIC5maWx0ZXIoZXYgPT4gICFldi5zdGF0ZS5kcmFnZ2FibGUgJiYgZXYubGluZUlkID09IGxpbmVJZCkvL+WQjOOBmOWIl+OBruOCguOBruOBoOOBkeOBq+e1nuOCi1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuY3VycmVudFRpbWVTcGFuLmdldFN0YXJ0VGltZSgpLmNvbXBhcmUoYi5jdXJyZW50VGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpKS8v5pmC6ZaT44Gu5piH6aCG44Gn5Lim44Gz5pu/44GIXG4gICAgICAuZmluZChldiA9PiBldi5jdXJyZW50VGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkuY29tcGFyZSh0aW1lKSA+PSAwKS8v5piH6aCG44Gq44Gu44Gn5a++6LGh44KI44KK5pyA5Yid44Gr6ZaL5aeL5pmC6ZaT44GM6YGF44GE44KC44Gu44GMbmV4dFxuICAgICAgO1xuICB9XG5cbiAgZ2V0RXZlbnRzT25MaW5lKGxpbmVJZCl7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRDb21wb25lbnRzLmZpbHRlcihldiA9PiAgIWV2LnN0YXRlLmRyYWdnYWJsZSAmJiBldi5saW5lSWQgPT0gbGluZUlkKVxuICB9XG5cbiAgZ2V0TmV4dFRpbWUobGluZUlkLCB0aW1lKXtcbiAgICBjb25zdCBuZXh0RXZlbnQgPSB0aGlzLmZpbmROZXh0RXZlbnRCeVRpbWUobGluZUlkLCB0aW1lKTtcbiAgICBsZXQgbmV4dFRpbWU7XG4gICAgaWYobmV4dEV2ZW50KXtcbiAgICAgIG5leHRUaW1lID0gbmV4dEV2ZW50LmN1cnJlbnRUaW1lU3Bhbi5nZXRTdGFydFRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRpbWUgPSB0aGlzLnRpbWVTcGFuLmdldEVuZFRpbWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRpbWU7XG4gIH1cblxuICBnZXRGcmVlTWludXRlKGxpbmVJZCwgdGltZSl7XG4gICAgY29uc3QgbmV4dFRpbWUgPSB0aGlzLmdldE5leHRUaW1lKGxpbmVJZCwgdGltZSk7XG4gICAgcmV0dXJuIHRpbWUuZ2V0RGlzdGFuY2UobmV4dFRpbWUpO1xuICB9XG5cbiAgZ2V0TmV4dFRvcChldmVudENvbXBvbmVudCl7XG4gICAgcmV0dXJuIHRoaXMudGltZVRvVG9wKHRoaXMuZ2V0TmV4dFRpbWUoZXZlbnRDb21wb25lbnQubGluZUlkLCBldmVudENvbXBvbmVudC5jdXJyZW50VGltZVNwYW4uZ2V0RW5kVGltZSgpKSk7XG4gIH1cbiAgYWRkRXZlbnRzKGV2ZW50cyl7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVDb21wb25lbnQuYWRkRXZlbnRzKGV2ZW50cyk7XG4gIH1cblxuICBzZXRIZWlnaHQoaGVpZ2h0KXtcbiAgICB0aGlzLmZyYW1lQ29tcG9uZW50LnNldEhlaWdodChoZWlnaHQpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpe1xuICAgIGlmKG5leHRQcm9wcy5saW5lRGF0YSAhPT0gdGhpcy5wcm9wcy5saW5lRGF0YSl7XG4gICAgICB0aGlzLnRvdGFsV2lkdGhDYWNoZSA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiAoXG4gICAgICA8RnJhbWVcbiAgICAgICAgcmVmPVwiZnJhbWVcIlxuICAgICAgICBsaW5lRGF0YT17dGhpcy5wcm9wcy5saW5lRGF0YX1cbiAgICAgICAgdGltZVNwYW49e3RoaXMucHJvcHMudGltZVNwYW59XG4gICAgICAgIGxpbmVXaWR0aD17dGhpcy5wcm9wcy5saW5lV2lkdGh9XG4gICAgICAgIG1pbkhlaWdodD17dGhpcy5wcm9wcy5taW5IZWlnaHR9XG4gICAgICAgIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLndpZHRofVxuICAgICAgICBsaW5lSGVpZ2h0PXt0aGlzLmxpbmVIZWlnaHR9XG4gICAgICAgIHRpbWVsaW5lPXt0aGlzfVxuICAgICAgICBydWxlckludGVydmFsPXt0aGlzLnByb3BzLnJ1bGVySW50ZXJ2YWx9XG4gICAgICAgIGV2ZW50cz17dGhpcy5wcm9wcy5ldmVudHN9XG4gICAgICAgIGNoaWxkcmVuPXt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICBjaGlsZFdpZHRoPXt0aGlzLnByb3BzLmNoaWxkV2lkdGh9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cblxuLy8gVGltZWxpbmUucHJvcFR5cGVzID0ge1xuLy8gICB0aW1lU3BhbjogUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoVGltZVNwYW4pLmlzUmVxdWlyZWQsXG4vLyAgIGxpbmVEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuLy8gICAgIGlkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4vLyAgICAgbGFiZWw6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuLy8gICB9KSkuaXNSZXF1aXJlZCxcbi8vICAgbGluZVdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4vLyAgIG1pbkhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuLy8gICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbi8vICAgcnVsZXJJbnRlcnZhbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuLy8gICBtaW5JbnRlcnZhbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbi8vICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbi8vIH1cblxuVGltZWxpbmUuZGVmYXVsdFByb3BzID0ge1xuICBtaW5JbnRlcnZhbDogMSxcbiAgY2hpbGRXaWR0aDogMFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvVGltZWxpbmUuanN4XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvVGltZWxpbmUuanN4IiwiLyoqXG4gKiDkuIDluqbnlJ/miJDjgZfjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjga/lpInmm7TjgZfjgb7jgZvjgpPjgIJcbiAqIOWkieabtOODoeOCveODg+ODieOBr+aWsOOBl+OBhOOCquODluOCuOOCp+OCr+ODiOOCkuW4sOOBl+OBvuOBmeOAglxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lXG57XG4gIHN0YXRpYyBlYWNoTWluKGNhbGxiYWNrLCBtaW51dGVJbnRlcnZhbCl7XG4gICAgICB2YXIgY291bnQgPSA2MCAvIG1pbnV0ZUludGVydmFsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1pbiA9IGkgKiBtaW51dGVJbnRlcnZhbDtcbiAgICAgICAgICBpZihtaW4gPCA2MCl7XG4gICAgICAgICAgICAgIHZhciBkaXNwbGF5TWluID0gbWluIDwgMTAgPyAnMCcgKyBtaW4gOiBtaW4gKyAnJztcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChtaW4sIGksIG1pbiwgZGlzcGxheU1pbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfTtcblxuICAvKipcbiAgICog6YWN5YiX44GL44KJVGltZeOCkueUn+aIkFxuICAgKiBAcGFyYW0gIHthcnJheX0gdGltZSBbaG91ciwgbWluXeOBrumFjeWIl1xuICAgKiBAcmV0dXJuIHtUaW1lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSh0aW1lKXtcbiAgICAgIHJldHVybiBuZXcgVGltZSh0aW1lWzBdLCB0aW1lWzFdKTtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihob3VyLCBtaW4pe1xuICAgIHRoaXMuX2hvdXIgPSBob3VyID09PSB1bmRlZmluZWQgPyAwIDogcGFyc2VJbnQoaG91ciwgMTApO1xuICAgIHRoaXMuX21pbiA9IG1pbiA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcnNlSW50KG1pbiwgMTApO1xuICAgIHdoaWxlKHRoaXMuX21pbiA8IDApe1xuICAgICAgICAtLXRoaXMuX2hvdXI7XG4gICAgICAgIHRoaXMuX21pbiA9IDYwICsgdGhpcy5fbWluO1xuICAgIH1cblxuICAgIHdoaWxlKHRoaXMuX21pbiA+IDU5KXtcbiAgICAgICAgKyt0aGlzLl9ob3VyO1xuICAgICAgICB0aGlzLl9taW4gPSB0aGlzLl9taW4gLSA2MDtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9ob3VyIDwgMClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkrJyBpcyBub3QgdmFsaWQgdGltZS4nKTtcbiAgICB9XG4gIH1cblxuICBnZXRIb3VyKCl7IHJldHVybiB0aGlzLl9ob3VyOyB9O1xuICBnZXRNaW4oKXsgcmV0dXJuIHRoaXMuX21pbjsgfTtcblxuICBjbG9uZSgpe1xuICAgICAgcmV0dXJuIG5ldyBUaW1lKHRoaXMuZ2V0SG91cigpLCB0aGlzLmdldE1pbigpKTtcbiAgfTtcblxuICBhZGRNaW4obWluKXtcbiAgICAgIHJldHVybiBuZXcgVGltZSh0aGlzLmdldEhvdXIoKSwgdGhpcy5nZXRNaW4oKSArIHBhcnNlSW50KG1pbiwgMTApKTtcbiAgfTtcblxuICBlcXVhbHModGltZSl7XG4gICAgICByZXR1cm4gdGhpcy5nZXRIb3VyKCkgPT09IHRpbWUuZ2V0SG91cigpICYmIHRoaXMuZ2V0TWluKCkgPT09IHRpbWUuZ2V0TWluKCk7XG4gIH07XG5cbiAgY29tcGFyZSh0aW1lKXtcbiAgICAgIGlmKHRoaXMuZ2V0SG91cigpID4gdGltZS5nZXRIb3VyKCkpXG4gICAgICB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHRoaXMuZ2V0SG91cigpIDwgdGltZS5nZXRIb3VyKCkpXG4gICAgICB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICAgIGlmKHRoaXMuZ2V0TWluKCkgPiB0aW1lLmdldE1pbigpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYodGhpcy5nZXRNaW4oKSA8IHRpbWUuZ2V0TWluKCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgfTtcblxuICBnZXREaXN0YW5jZSh0YXJnZXRUaW1lKXtcbiAgICAgIHZhciB0YXJnZXRIb3VyID0gdGFyZ2V0VGltZS5nZXRIb3VyKCk7XG4gICAgICB2YXIgaG91ckRpc3RhbmNlID0gdGFyZ2V0SG91ciAtIHRoaXMuX2hvdXI7XG4gICAgICByZXR1cm4gKGhvdXJEaXN0YW5jZSAqIDYwKSArICh0YXJnZXRUaW1lLmdldE1pbigpIC0gdGhpcy5fbWluKTtcbiAgfTtcblxuICB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheVRpbWUoKTtcbiAgfTtcblxuICBnZXREaXNwbGF5SG91cigpe1xuICAgICAgcmV0dXJuIHRoaXMuX2hvdXIgPCAyNCA/IHRoaXMuX2hvdXIgOiB0aGlzLl9ob3VyIC0gMjQ7XG4gIH07XG5cbiAgZ2V0RGlzcGxheU1pbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX21pbiA8IDEwID8gJzAnK3RoaXMuX21pbiA6IHRoaXMuX21pbjtcbiAgfTtcblxuICBnZXREaXNwbGF5VGltZSgpe1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheUhvdXIoKSArJzonKyB0aGlzLmdldERpc3BsYXlNaW4oKTtcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbGFzc2VzL1RpbWUuZXM2XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vc3JjL2NsYXNzZXMvVGltZS5lczYiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzaGFsbG93RXF1YWw7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbEEgPSBvYmpBW2tleXNBW2ldXTtcbiAgICB2YXIgdmFsQiA9IG9iakJba2V5c0FbaV1dO1xuXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL3NoYWxsb3dFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gaXNEaXNwb3NhYmxlO1xuXG5mdW5jdGlvbiBpc0Rpc3Bvc2FibGUob2JqKSB7XG4gIHJldHVybiBCb29sZWFuKG9iaiAmJiB0eXBlb2Ygb2JqLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kaXNwb3NhYmxlcy9tb2R1bGVzL2lzRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Rpc3Bvc2FibGVzL21vZHVsZXMvaXNEaXNwb3NhYmxlLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUaW1lU3BhbiBmcm9tICcuLi9jbGFzc2VzL1RpbWVTcGFuJztcbmltcG9ydCBIb3VyIGZyb20gJy4vSG91cic7XG5pbXBvcnQgUnVsZXIgZnJvbSAnLi9SdWxlcic7XG5pbXBvcnQgTGluZUxhYmVsIGZyb20gJy4vTGluZUxhYmVsJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vVGltZWxpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG57XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhvdXJzOiBbXSxcbiAgICAgIGV2ZW50czogW10sXG4gICAgICBkcmFnZ2luZ092ZXI6IGZhbHNlXG4gICAgfVxuICAgIHRoaXMucHJvcHMudGltZVNwYW4uZWFjaFRpbWUoKGtleSwgdGltZSkgPT4ge1xuICAgICAgaWYoIXRpbWUuZXF1YWxzKHRoaXMucHJvcHMudGltZVNwYW4uZ2V0RW5kVGltZSgpKSl7XG4gICAgICAgIHRoaXMuc3RhdGUuaG91cnMucHVzaChcbiAgICAgICAgICA8SG91clxuICAgICAgICAgICAga2V5PXt0aW1lLmdldEhvdXIoKX1cbiAgICAgICAgICAgIHRpbWU9e3RpbWV9XG4gICAgICAgICAgICBtaW5IZWlnaHQ9e3RoaXMucHJvcHMubWluSGVpZ2h0fVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnZhcnMgPSB0aGlzLnByb3BzLnZhcnMgfHwge307XG4gIH1cblxuICBnZXRSZWxhdGl2ZVRvcChlKXtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gdGhpcy5wcm9wcy5mcmFtZS5yZWZzLmxpbmVzV3JhcHBlcjtcbiAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZS5jbGllbnRZIC0gcGFyZW50UmVjdC50b3AgKyBwYXJlbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIG9uQ2xpY2soZSl7XG4gICAgaWYodGhpcy5wcm9wcy50aW1lbGluZS5wcm9wcy5saW5lRGlkQ2xpY2spe1xuICAgICAgY29uc3QgdGltZSA9IHRoaXMucHJvcHMudGltZWxpbmUudG9wVG9UaW1lKHRoaXMuZ2V0UmVsYXRpdmVUb3AoZSkpO1xuICAgICAgdGhpcy5wcm9wcy50aW1lbGluZS5wcm9wcy5saW5lRGlkQ2xpY2soe1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIGZyZWVNaW51dGU6IHRoaXMucHJvcHMudGltZWxpbmUuZ2V0RnJlZU1pbnV0ZSh0aGlzLnByb3BzLmlkLCB0aW1lKSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMucHJvcHMudGltZWxpbmUuZnJhbWVDb21wb25lbnQucmVmcy5saW5lc1dyYXBwZXIuc2Nyb2xsVG9wLFxuICAgICAgICAgIHNjcm9sbExlZnQ6IHRoaXMucHJvcHMudGltZWxpbmUuZnJhbWVDb21wb25lbnQuZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogZS5jbGllbnRZLFxuICAgICAgICAgIGxlZnQ6IGUuY2xpZW50WCxcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnQ6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uQ29udGV4dE1lbnUoZSl7XG4gICAgaWYodGhpcy5wcm9wcy50aW1lbGluZS5wcm9wcy5saW5lRGlkUmlnaHRDbGljayl7XG4gICAgICB0aGlzLnByb3BzLnRpbWVsaW5lLnByb3BzLmxpbmVEaWRSaWdodENsaWNrKHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhZ2dpbmdPdmVyKCl7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZHJhZ2dpbmdPdmVyOiB0cnVlfSk7XG4gIH1cblxuICBjbGVhckRyYWdnaW5nT3Zlcigpe1xuICAgIHRoaXMuc2V0U3RhdGUoe2RyYWdnaW5nT3ZlcjogZmFsc2V9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgaWYodGhpcy5wcm9wcy50aW1lbGluZS5kcmFnZ2luZ092ZXJMaW5lQ29tcG9uZW50ID09IHRoaXMpe1xuICAgICAgdGhpcy5wcm9wcy50aW1lbGluZS5kcmFnZ2luZ092ZXJMaW5lQ29tcG9uZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGxMaW5lV3JhcHBlclwiIGRhdGEtaWQ9e3RoaXMucHJvcHMuaWR9IG9uQ29udGV4dE1lbnU9e2UgPT4gdGhpcy5vbkNvbnRleHRNZW51KGUpfT5cbiAgICAgICAgeygoKSA9PiB7XG4gICAgICAgICAgaWYodGhpcy5wcm9wcy5oYXNSdWxlcil7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8UnVsZXJcbiAgICAgICAgICAgICAgICBrZXk9eydydWxlcl8nICsgdGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ9e3RoaXMucHJvcHMubWluSGVpZ2h0fVxuICAgICAgICAgICAgICAgIHRpbWVTcGFuPXt0aGlzLnByb3BzLnRpbWVTcGFufVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX1cbiAgICAgICAgPGRpdiBvbkNsaWNrPXtlID0+IHRoaXMub25DbGljayhlKX0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKCd0bExpbmVWaWV3Jywge3RsRXZlbjogdGhpcy5wcm9wcy5ldmVuLCB0bE9kZDogIXRoaXMucHJvcHMuZXZlbn0sIHt0bE92ZXI6IHRoaXMuc3RhdGUuZHJhZ2dpbmdPdmVyfSl9IHN0eWxlPXt7d2lkdGg6IHRoaXMucHJvcHMud2lkdGggKyAncHgnfX0+XG4gICAgICAgICAge3RoaXMuc3RhdGUuaG91cnN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5MaW5lLnNpZGVQYWRkaW5nID0gMTtcblxuLy8gTGluZS5wcm9wVHlwZXMgPSB7XG4vLyAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4vLyAgIG1pbkhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuLy8gICB0aW1lU3BhbjogUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoVGltZVNwYW4pLmlzUmVxdWlyZWQsXG4vLyAgIGlkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4vLyAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuLy8gICBldmVuOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuLy8gICAvL1RPRE8g5b6q55Kw5Y+C54Wn44Gr44Gq44KL44Gu44GnaW1wb3J044Gn44GN44Ga44CC44Go44KK44GC44GI44GaYW5544Gn44GU44G+44GL44GX44Gm44G+44GZ44CCXG4vLyAgIHRpbWVsaW5lOiBSZWFjdC5Qcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4vLyAgIGhhc1J1bGVyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG4vLyB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9MaW5lLmpzeFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0xpbmUuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSdWxlciBmcm9tICcuL1J1bGVyJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lTGFiZWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc1J1bGVyOiB0aGlzLnByb3BzLmhhc1J1bGVyLFxuICAgICAgcHJldlJ1bGVyOiB0aGlzLnByb3BzLnByZXZSdWxlcixcbiAgICAgIGlzTGFzdDogdGhpcy5wcm9wcy5pc0xhc3RcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT17e3dpZHRoOiB0aGlzLnByb3BzLndpZHRoLCBtYXJnaW5MZWZ0OiB0aGlzLnN0YXRlLmhhc1J1bGVyID8gUnVsZXIud2lkdGggKyAncHgnIDogMH19XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyh7dGxMYWJlbDogdHJ1ZSwgdGxIYXNSdWxlcjogdGhpcy5zdGF0ZS5oYXNSdWxlciwgdGxQcmV2UnVsZXI6IHRoaXMuc3RhdGUucHJldlJ1bGVyLCB0bExhc3Q6IHRoaXMuc3RhdGUuaXNMYXN0fSl9XG4gICAgICA+XG4gICAgICAgIHt0aGlzLnByb3BzLmxhYmVsfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5MaW5lTGFiZWwuaGVpZ2h0ID0gMTY7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9MaW5lTGFiZWwuanN4XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTGluZUxhYmVsLmpzeCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9EcmFnRHJvcENvbnRleHQgPSByZXF1aXJlKCcuL0RyYWdEcm9wQ29udGV4dCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RyYWdEcm9wQ29udGV4dCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdEcm9wQ29udGV4dCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXIgPSByZXF1aXJlKCcuL0RyYWdEcm9wQ29udGV4dFByb3ZpZGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnRHJvcENvbnRleHRQcm92aWRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRHJhZ0xheWVyID0gcmVxdWlyZSgnLi9EcmFnTGF5ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnTGF5ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnTGF5ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0RyYWdTb3VyY2UgPSByZXF1aXJlKCcuL0RyYWdTb3VyY2UnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU291cmNlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NvdXJjZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRHJvcFRhcmdldCA9IHJlcXVpcmUoJy4vRHJvcFRhcmdldCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Ryb3BUYXJnZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wVGFyZ2V0KS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudW5wYWNrQmFja2VuZEZvckVzNVVzZXJzID0gZXhwb3J0cy5jcmVhdGVDaGlsZENvbnRleHQgPSBleHBvcnRzLkNISUxEX0NPTlRFWFRfVFlQRVMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ0Ryb3BDb250ZXh0O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2RuZENvcmUgPSByZXF1aXJlKCdkbmQtY29yZScpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzJyk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDSElMRF9DT05URVhUX1RZUEVTID0gZXhwb3J0cy5DSElMRF9DT05URVhUX1RZUEVTID0ge1xuICBkcmFnRHJvcE1hbmFnZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cbnZhciBjcmVhdGVDaGlsZENvbnRleHQgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ29udGV4dChiYWNrZW5kLCBjb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgZHJhZ0Ryb3BNYW5hZ2VyOiBuZXcgX2RuZENvcmUuRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmQsIGNvbnRleHQpXG4gIH07XG59O1xuXG52YXIgdW5wYWNrQmFja2VuZEZvckVzNVVzZXJzID0gZXhwb3J0cy51bnBhY2tCYWNrZW5kRm9yRXM1VXNlcnMgPSBmdW5jdGlvbiB1bnBhY2tCYWNrZW5kRm9yRXM1VXNlcnMoYmFja2VuZE9yTW9kdWxlKSB7XG4gIC8vIEF1dG8tZGV0ZWN0IEVTNiBkZWZhdWx0IGV4cG9ydCBmb3IgcGVvcGxlIHN0aWxsIHVzaW5nIEVTNVxuICB2YXIgYmFja2VuZCA9IGJhY2tlbmRPck1vZHVsZTtcbiAgaWYgKCh0eXBlb2YgYmFja2VuZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYmFja2VuZCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYmFja2VuZC5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYmFja2VuZCA9IGJhY2tlbmQuZGVmYXVsdDtcbiAgfVxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIGJhY2tlbmQgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCB0aGUgYmFja2VuZCB0byBiZSBhIGZ1bmN0aW9uIG9yIGFuIEVTNiBtb2R1bGUgZXhwb3J0aW5nIGEgZGVmYXVsdCBmdW5jdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctZHJvcC1jb250ZXh0Lmh0bWwnKTtcbiAgcmV0dXJuIGJhY2tlbmQ7XG59O1xuXG5mdW5jdGlvbiBEcmFnRHJvcENvbnRleHQoYmFja2VuZE9yTW9kdWxlKSB7XG4gIF9jaGVja0RlY29yYXRvckFyZ3VtZW50czIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFsnRHJhZ0Ryb3BDb250ZXh0JywgJ2JhY2tlbmQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuXG4gIHZhciBiYWNrZW5kID0gdW5wYWNrQmFja2VuZEZvckVzNVVzZXJzKGJhY2tlbmRPck1vZHVsZSk7XG4gIHZhciBjaGlsZENvbnRleHQgPSBjcmVhdGVDaGlsZENvbnRleHQoYmFja2VuZCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRlQ29udGV4dChEZWNvcmF0ZWRDb21wb25lbnQpIHtcbiAgICB2YXIgX2NsYXNzLCBfdGVtcDtcblxuICAgIHZhciBkaXNwbGF5TmFtZSA9IERlY29yYXRlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBEZWNvcmF0ZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIHZhciBEcmFnRHJvcENvbnRleHRDb250YWluZXIgPSAoX3RlbXAgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKERyYWdEcm9wQ29udGV4dENvbnRhaW5lciwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dENvbnRhaW5lcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdEcm9wQ29udGV4dENvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcmFnRHJvcENvbnRleHRDb250YWluZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcmFnRHJvcENvbnRleHRDb250YWluZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKERyYWdEcm9wQ29udGV4dENvbnRhaW5lciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UoKSB7XG4gICAgICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuY2hpbGQsICdJbiBvcmRlciB0byBhY2Nlc3MgYW4gaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZCBjb21wb25lbnQgaXQgY2FuICcgKyAnbm90IGJlIGEgc3RhdGVsZXNzIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNYW5hZ2VyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hbmFnZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkQ29udGV4dC5kcmFnRHJvcE1hbmFnZXI7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Q2hpbGRDb250ZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoY2hpbGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gRHJhZ0Ryb3BDb250ZXh0Q29udGFpbmVyO1xuICAgIH0oX3JlYWN0LkNvbXBvbmVudCksIF9jbGFzcy5EZWNvcmF0ZWRDb21wb25lbnQgPSBEZWNvcmF0ZWRDb21wb25lbnQsIF9jbGFzcy5kaXNwbGF5TmFtZSA9ICdEcmFnRHJvcENvbnRleHQoJyArIGRpc3BsYXlOYW1lICsgJyknLCBfY2xhc3MuY2hpbGRDb250ZXh0VHlwZXMgPSBDSElMRF9DT05URVhUX1RZUEVTLCBfdGVtcCk7XG5cblxuICAgIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShEcmFnRHJvcENvbnRleHRDb250YWluZXIsIERlY29yYXRlZENvbXBvbmVudCk7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9EcmFnRHJvcENvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdEcm9wQ29udGV4dC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZ09mZnNldDtcbmV4cG9ydHMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gZ2V0U291cmNlQ2xpZW50T2Zmc2V0O1xuZXhwb3J0cy5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQgPSBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQ7XG5cbnZhciBfZHJhZ0Ryb3AgPSByZXF1aXJlKCcuLi9hY3Rpb25zL2RyYWdEcm9wJyk7XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQ6IG51bGwsXG4gIGluaXRpYWxDbGllbnRPZmZzZXQ6IG51bGwsXG4gIGNsaWVudE9mZnNldDogbnVsbFxufTtcblxuZnVuY3Rpb24gYXJlT2Zmc2V0c0VxdWFsKG9mZnNldEEsIG9mZnNldEIpIHtcbiAgaWYgKG9mZnNldEEgPT09IG9mZnNldEIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0QSAmJiBvZmZzZXRCICYmIG9mZnNldEEueCA9PT0gb2Zmc2V0Qi54ICYmIG9mZnNldEEueSA9PT0gb2Zmc2V0Qi55O1xufVxuXG5mdW5jdGlvbiBkcmFnT2Zmc2V0KCkge1xuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuQkVHSU5fRFJBRzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQ6IGFjdGlvbi5zb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgIGluaXRpYWxDbGllbnRPZmZzZXQ6IGFjdGlvbi5jbGllbnRPZmZzZXQsXG4gICAgICAgIGNsaWVudE9mZnNldDogYWN0aW9uLmNsaWVudE9mZnNldFxuICAgICAgfTtcbiAgICBjYXNlIF9kcmFnRHJvcC5IT1ZFUjpcbiAgICAgIGlmIChhcmVPZmZzZXRzRXF1YWwoc3RhdGUuY2xpZW50T2Zmc2V0LCBhY3Rpb24uY2xpZW50T2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNsaWVudE9mZnNldDogYWN0aW9uLmNsaWVudE9mZnNldFxuICAgICAgfSk7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuRU5EX0RSQUc6XG4gICAgY2FzZSBfZHJhZ0Ryb3AuRFJPUDpcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoc3RhdGUpIHtcbiAgdmFyIGNsaWVudE9mZnNldCA9IHN0YXRlLmNsaWVudE9mZnNldCxcbiAgICAgIGluaXRpYWxDbGllbnRPZmZzZXQgPSBzdGF0ZS5pbml0aWFsQ2xpZW50T2Zmc2V0LFxuICAgICAgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCA9IHN0YXRlLmluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQ7XG5cbiAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIWluaXRpYWxDbGllbnRPZmZzZXQgfHwgIWluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGNsaWVudE9mZnNldC54ICsgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldC54IC0gaW5pdGlhbENsaWVudE9mZnNldC54LFxuICAgIHk6IGNsaWVudE9mZnNldC55ICsgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldC55IC0gaW5pdGlhbENsaWVudE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldChzdGF0ZSkge1xuICB2YXIgY2xpZW50T2Zmc2V0ID0gc3RhdGUuY2xpZW50T2Zmc2V0LFxuICAgICAgaW5pdGlhbENsaWVudE9mZnNldCA9IHN0YXRlLmluaXRpYWxDbGllbnRPZmZzZXQ7XG5cbiAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIWluaXRpYWxDbGllbnRPZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGNsaWVudE9mZnNldC54IC0gaW5pdGlhbENsaWVudE9mZnNldC54LFxuICAgIHk6IGNsaWVudE9mZnNldC55IC0gaW5pdGlhbENsaWVudE9mZnNldC55XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL2RyYWdPZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvZHJhZ09mZnNldC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXNUeXBlO1xuXG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheScpO1xuXG52YXIgX2lzQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkge1xuICBpZiAoKDAsIF9pc0FycmF5Mi5kZWZhdWx0KSh0YXJnZXRUeXBlKSkge1xuICAgIHJldHVybiB0YXJnZXRUeXBlLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ID09PSBkcmFnZ2VkSXRlbVR5cGU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRhcmdldFR5cGUgPT09IGRyYWdnZWRJdGVtVHlwZTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi91dGlscy9tYXRjaGVzVHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi91dGlscy9tYXRjaGVzVHlwZS5qcyIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaXRlcmF0ZWUpIHtcbiAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZURpZmZlcmVuY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VEaWZmZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRGlmZmVyZW5jZS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGlydHlIYW5kbGVySWRzO1xuZXhwb3J0cy5hcmVEaXJ0eSA9IGFyZURpcnR5O1xuXG52YXIgX3hvciA9IHJlcXVpcmUoJ2xvZGFzaC94b3InKTtcblxudmFyIF94b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfeG9yKTtcblxudmFyIF9pbnRlcnNlY3Rpb24gPSByZXF1aXJlKCdsb2Rhc2gvaW50ZXJzZWN0aW9uJyk7XG5cbnZhciBfaW50ZXJzZWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludGVyc2VjdGlvbik7XG5cbnZhciBfZHJhZ0Ryb3AgPSByZXF1aXJlKCcuLi9hY3Rpb25zL2RyYWdEcm9wJyk7XG5cbnZhciBfcmVnaXN0cnkgPSByZXF1aXJlKCcuLi9hY3Rpb25zL3JlZ2lzdHJ5Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBOT05FID0gW107XG52YXIgQUxMID0gW107XG5cbmZ1bmN0aW9uIGRpcnR5SGFuZGxlcklkcygpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBOT05FO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZHJhZ09wZXJhdGlvbiA9IGFyZ3VtZW50c1syXTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuSE9WRVI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIF9yZWdpc3RyeS5BRERfU09VUkNFOlxuICAgIGNhc2UgX3JlZ2lzdHJ5LkFERF9UQVJHRVQ6XG4gICAgY2FzZSBfcmVnaXN0cnkuUkVNT1ZFX1RBUkdFVDpcbiAgICBjYXNlIF9yZWdpc3RyeS5SRU1PVkVfU09VUkNFOlxuICAgICAgcmV0dXJuIE5PTkU7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuQkVHSU5fRFJBRzpcbiAgICBjYXNlIF9kcmFnRHJvcC5QVUJMSVNIX0RSQUdfU09VUkNFOlxuICAgIGNhc2UgX2RyYWdEcm9wLkVORF9EUkFHOlxuICAgIGNhc2UgX2RyYWdEcm9wLkRST1A6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBBTEw7XG4gIH1cblxuICB2YXIgdGFyZ2V0SWRzID0gYWN0aW9uLnRhcmdldElkcztcbiAgdmFyIHByZXZUYXJnZXRJZHMgPSBkcmFnT3BlcmF0aW9uLnRhcmdldElkcztcblxuICB2YXIgcmVzdWx0ID0gKDAsIF94b3IyLmRlZmF1bHQpKHRhcmdldElkcywgcHJldlRhcmdldElkcyk7XG5cbiAgdmFyIGRpZENoYW5nZSA9IGZhbHNlO1xuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0SWRzW2ldICE9PSBwcmV2VGFyZ2V0SWRzW2ldKSB7XG4gICAgICAgIGRpZENoYW5nZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaWRDaGFuZ2UgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFkaWRDaGFuZ2UpIHtcbiAgICByZXR1cm4gTk9ORTtcbiAgfVxuXG4gIHZhciBwcmV2SW5uZXJtb3N0VGFyZ2V0SWQgPSBwcmV2VGFyZ2V0SWRzW3ByZXZUYXJnZXRJZHMubGVuZ3RoIC0gMV07XG4gIHZhciBpbm5lcm1vc3RUYXJnZXRJZCA9IHRhcmdldElkc1t0YXJnZXRJZHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHByZXZJbm5lcm1vc3RUYXJnZXRJZCAhPT0gaW5uZXJtb3N0VGFyZ2V0SWQpIHtcbiAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkKSB7XG4gICAgICByZXN1bHQucHVzaChwcmV2SW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpZiAoaW5uZXJtb3N0VGFyZ2V0SWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlubmVybW9zdFRhcmdldElkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcmVEaXJ0eShzdGF0ZSwgaGFuZGxlcklkcykge1xuICBpZiAoc3RhdGUgPT09IE5PTkUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUgPT09IEFMTCB8fCB0eXBlb2YgaGFuZGxlcklkcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2ludGVyc2VjdGlvbjIuZGVmYXVsdCkoaGFuZGxlcklkcywgc3RhdGUpLmxlbmd0aCA+IDA7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL2RpcnR5SGFuZGxlcklkcy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9yZWR1Y2Vycy9kaXJ0eUhhbmRsZXJJZHMuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdMYXllcjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi91dGlscy9zaGFsbG93RXF1YWwnKTtcblxudmFyIF9zaGFsbG93RXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhbGxvd0VxdWFsKTtcblxudmFyIF9zaGFsbG93RXF1YWxTY2FsYXIgPSByZXF1aXJlKCcuL3V0aWxzL3NoYWxsb3dFcXVhbFNjYWxhcicpO1xuXG52YXIgX3NoYWxsb3dFcXVhbFNjYWxhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFsbG93RXF1YWxTY2FsYXIpO1xuXG52YXIgX2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzID0gcmVxdWlyZSgnLi91dGlscy9jaGVja0RlY29yYXRvckFyZ3VtZW50cycpO1xuXG52YXIgX2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBEcmFnTGF5ZXIoY29sbGVjdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgX2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzMi5kZWZhdWx0LmFwcGx5KHVuZGVmaW5lZCwgWydEcmFnTGF5ZXInLCAnY29sbGVjdFssIG9wdGlvbnNdJ10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBjb2xsZWN0ID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgXCJjb2xsZWN0XCIgcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIERyYWdMYXllciAnICsgJ3RvIGJlIGEgZnVuY3Rpb24gdGhhdCBjb2xsZWN0cyBwcm9wcyB0byBpbmplY3QgaW50byB0aGUgY29tcG9uZW50LiAnLCAnSW5zdGVhZCwgcmVjZWl2ZWQgJXMuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLWxheWVyLmh0bWwnLCBjb2xsZWN0KTtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKCgwLCBfaXNQbGFpbk9iamVjdDIuZGVmYXVsdCkob3B0aW9ucyksICdFeHBlY3RlZCBcIm9wdGlvbnNcIiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIERyYWdMYXllciB0byBiZSAnICsgJ2EgcGxhaW4gb2JqZWN0IHdoZW4gc3BlY2lmaWVkLiAnICsgJ0luc3RlYWQsIHJlY2VpdmVkICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1sYXllci5odG1sJywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRlTGF5ZXIoRGVjb3JhdGVkQ29tcG9uZW50KSB7XG4gICAgdmFyIF9jbGFzcywgX3RlbXA7XG5cbiAgICB2YXIgX29wdGlvbnMkYXJlUHJvcHNFcXVhID0gb3B0aW9ucy5hcmVQcm9wc0VxdWFsLFxuICAgICAgICBhcmVQcm9wc0VxdWFsID0gX29wdGlvbnMkYXJlUHJvcHNFcXVhID09PSB1bmRlZmluZWQgPyBfc2hhbGxvd0VxdWFsU2NhbGFyMi5kZWZhdWx0IDogX29wdGlvbnMkYXJlUHJvcHNFcXVhO1xuXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gRGVjb3JhdGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IERlY29yYXRlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgdmFyIERyYWdMYXllckNvbnRhaW5lciA9IChfdGVtcCA9IF9jbGFzcyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoRHJhZ0xheWVyQ29udGFpbmVyLCBfQ29tcG9uZW50KTtcblxuICAgICAgX2NyZWF0ZUNsYXNzKERyYWdMYXllckNvbnRhaW5lciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UoKSB7XG4gICAgICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuY2hpbGQsICdJbiBvcmRlciB0byBhY2Nlc3MgYW4gaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZCBjb21wb25lbnQgaXQgY2FuICcgKyAnbm90IGJlIGEgc3RhdGVsZXNzIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzaG91bGRDb21wb25lbnRVcGRhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuICFhcmVQcm9wc0VxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHwgISgwLCBfc2hhbGxvd0VxdWFsMi5kZWZhdWx0KShuZXh0U3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIGZ1bmN0aW9uIERyYWdMYXllckNvbnRhaW5lcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ0xheWVyQ29udGFpbmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRHJhZ0xheWVyQ29udGFpbmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJhZ0xheWVyQ29udGFpbmVyKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLmhhbmRsZUNoYW5nZSA9IF90aGlzLmhhbmRsZUNoYW5nZS5iaW5kKF90aGlzKTtcblxuICAgICAgICBfdGhpcy5tYW5hZ2VyID0gY29udGV4dC5kcmFnRHJvcE1hbmFnZXI7XG4gICAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfdHlwZW9mKF90aGlzLm1hbmFnZXIpID09PSAnb2JqZWN0JywgJ0NvdWxkIG5vdCBmaW5kIHRoZSBkcmFnIGFuZCBkcm9wIG1hbmFnZXIgaW4gdGhlIGNvbnRleHQgb2YgJXMuICcgKyAnTWFrZSBzdXJlIHRvIHdyYXAgdGhlIHRvcC1sZXZlbCBjb21wb25lbnQgb2YgeW91ciBhcHAgd2l0aCBEcmFnRHJvcENvbnRleHQuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy10cm91Ymxlc2hvb3RpbmcuaHRtbCNjb3VsZC1ub3QtZmluZC10aGUtZHJhZy1hbmQtZHJvcC1tYW5hZ2VyLWluLXRoZS1jb250ZXh0JywgZGlzcGxheU5hbWUsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhEcmFnTGF5ZXJDb250YWluZXIsIFt7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlNb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBtb25pdG9yID0gdGhpcy5tYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU9mZnNldENoYW5nZSA9IG1vbml0b3Iuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UodGhpcy5oYW5kbGVDaGFuZ2UpO1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tU3RhdGVDaGFuZ2UgPSBtb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodGhpcy5oYW5kbGVDaGFuZ2UpO1xuXG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5TW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21PZmZzZXRDaGFuZ2UoKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbVN0YXRlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50bHlNb3VudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCEoMCwgX3NoYWxsb3dFcXVhbDIuZGVmYXVsdCkobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRDdXJyZW50U3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFN0YXRlKCkge1xuICAgICAgICAgIHZhciBtb25pdG9yID0gdGhpcy5tYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdChtb25pdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERlY29yYXRlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHRoaXMuc3RhdGUsIHtcbiAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGNoaWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIERyYWdMYXllckNvbnRhaW5lcjtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpLCBfY2xhc3MuRGVjb3JhdGVkQ29tcG9uZW50ID0gRGVjb3JhdGVkQ29tcG9uZW50LCBfY2xhc3MuZGlzcGxheU5hbWUgPSAnRHJhZ0xheWVyKCcgKyBkaXNwbGF5TmFtZSArICcpJywgX2NsYXNzLmNvbnRleHRUeXBlcyA9IHtcbiAgICAgIGRyYWdEcm9wTWFuYWdlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZFxuICAgIH0sIF90ZW1wKTtcblxuXG4gICAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKERyYWdMYXllckNvbnRhaW5lciwgRGVjb3JhdGVkQ29tcG9uZW50KTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdMYXllci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvRHJhZ0xheWVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbFNjYWxhcjtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbFNjYWxhcihvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBvYmpBID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmpBKSkgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgKHR5cGVvZiBvYmpCID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmpCKSkgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWxBID0gb2JqQVtrZXlzQVtpXV07XG4gICAgdmFyIHZhbEIgPSBvYmpCW2tleXNBW2ldXTtcblxuICAgIGlmICh2YWxBICE9PSB2YWxCIHx8ICh0eXBlb2YgdmFsQSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsQSkpID09PSAnb2JqZWN0JyB8fCAodHlwZW9mIHZhbEIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbEIpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL3NoYWxsb3dFcXVhbFNjYWxhci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsU2NhbGFyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlY29yYXRlSGFuZGxlcjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9kaXNwb3NhYmxlcyA9IHJlcXVpcmUoJ2Rpc3Bvc2FibGVzJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJy4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfc2hhbGxvd0VxdWFsU2NhbGFyID0gcmVxdWlyZSgnLi91dGlscy9zaGFsbG93RXF1YWxTY2FsYXInKTtcblxudmFyIF9zaGFsbG93RXF1YWxTY2FsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhbGxvd0VxdWFsU2NhbGFyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBkZWNvcmF0ZUhhbmRsZXIoX3JlZikge1xuICB2YXIgX2NsYXNzLCBfdGVtcDtcblxuICB2YXIgRGVjb3JhdGVkQ29tcG9uZW50ID0gX3JlZi5EZWNvcmF0ZWRDb21wb25lbnQsXG4gICAgICBjcmVhdGVIYW5kbGVyID0gX3JlZi5jcmVhdGVIYW5kbGVyLFxuICAgICAgY3JlYXRlTW9uaXRvciA9IF9yZWYuY3JlYXRlTW9uaXRvcixcbiAgICAgIGNyZWF0ZUNvbm5lY3RvciA9IF9yZWYuY3JlYXRlQ29ubmVjdG9yLFxuICAgICAgcmVnaXN0ZXJIYW5kbGVyID0gX3JlZi5yZWdpc3RlckhhbmRsZXIsXG4gICAgICBjb250YWluZXJEaXNwbGF5TmFtZSA9IF9yZWYuY29udGFpbmVyRGlzcGxheU5hbWUsXG4gICAgICBnZXRUeXBlID0gX3JlZi5nZXRUeXBlLFxuICAgICAgY29sbGVjdCA9IF9yZWYuY29sbGVjdCxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRhcmVQcm9wc0VxdWEgPSBvcHRpb25zLmFyZVByb3BzRXF1YWwsXG4gICAgICBhcmVQcm9wc0VxdWFsID0gX29wdGlvbnMkYXJlUHJvcHNFcXVhID09PSB1bmRlZmluZWQgPyBfc2hhbGxvd0VxdWFsU2NhbGFyMi5kZWZhdWx0IDogX29wdGlvbnMkYXJlUHJvcHNFcXVhO1xuXG4gIHZhciBkaXNwbGF5TmFtZSA9IERlY29yYXRlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBEZWNvcmF0ZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICB2YXIgRHJhZ0Ryb3BDb250YWluZXIgPSAoX3RlbXAgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhEcmFnRHJvcENvbnRhaW5lciwgX0NvbXBvbmVudCk7XG5cbiAgICBfY3JlYXRlQ2xhc3MoRHJhZ0Ryb3BDb250YWluZXIsIFt7XG4gICAgICBrZXk6ICdnZXRIYW5kbGVySWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhhbmRsZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcklkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldERlY29yYXRlZENvbXBvbmVudEluc3RhbmNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWNvcmF0ZWRDb21wb25lbnRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuICFhcmVQcm9wc0VxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHwgISgwLCBfc2hhbGxvd0VxdWFsMi5kZWZhdWx0KShuZXh0U3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIGZ1bmN0aW9uIERyYWdEcm9wQ29udGFpbmVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ0Ryb3BDb250YWluZXIpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRHJhZ0Ryb3BDb250YWluZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcmFnRHJvcENvbnRhaW5lcikpLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gX3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQoX3RoaXMpO1xuICAgICAgX3RoaXMuaGFuZGxlQ2hpbGRSZWYgPSBfdGhpcy5oYW5kbGVDaGlsZFJlZi5iaW5kKF90aGlzKTtcblxuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF90eXBlb2YoX3RoaXMuY29udGV4dC5kcmFnRHJvcE1hbmFnZXIpID09PSAnb2JqZWN0JywgJ0NvdWxkIG5vdCBmaW5kIHRoZSBkcmFnIGFuZCBkcm9wIG1hbmFnZXIgaW4gdGhlIGNvbnRleHQgb2YgJXMuICcgKyAnTWFrZSBzdXJlIHRvIHdyYXAgdGhlIHRvcC1sZXZlbCBjb21wb25lbnQgb2YgeW91ciBhcHAgd2l0aCBEcmFnRHJvcENvbnRleHQuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy10cm91Ymxlc2hvb3RpbmcuaHRtbCNjb3VsZC1ub3QtZmluZC10aGUtZHJhZy1hbmQtZHJvcC1tYW5hZ2VyLWluLXRoZS1jb250ZXh0JywgZGlzcGxheU5hbWUsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgX3RoaXMubWFuYWdlciA9IF90aGlzLmNvbnRleHQuZHJhZ0Ryb3BNYW5hZ2VyO1xuICAgICAgX3RoaXMuaGFuZGxlck1vbml0b3IgPSBjcmVhdGVNb25pdG9yKF90aGlzLm1hbmFnZXIpO1xuICAgICAgX3RoaXMuaGFuZGxlckNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3RvcihfdGhpcy5tYW5hZ2VyLmdldEJhY2tlbmQoKSk7XG4gICAgICBfdGhpcy5oYW5kbGVyID0gY3JlYXRlSGFuZGxlcihfdGhpcy5oYW5kbGVyTW9uaXRvcik7XG5cbiAgICAgIF90aGlzLmRpc3Bvc2FibGUgPSBuZXcgX2Rpc3Bvc2FibGVzLlNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIF90aGlzLnJlY2VpdmVQcm9wcyhwcm9wcyk7XG4gICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgX3RoaXMuZGlzcG9zZSgpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEcmFnRHJvcENvbnRhaW5lciwgW3tcbiAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseU1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUgPSBuZXcgX2Rpc3Bvc2FibGVzLlNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZVByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICghYXJlUHJvcHNFcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlUHJvcHMobmV4dFByb3BzKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseU1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWNlaXZlUHJvcHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLmhhbmRsZXIucmVjZWl2ZVByb3BzKHByb3BzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlVHlwZShnZXRUeXBlKHByb3BzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVjZWl2ZVR5cGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHRoaXMuY3VycmVudFR5cGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRUeXBlID0gdHlwZTtcblxuICAgICAgICB2YXIgX3JlZ2lzdGVySGFuZGxlciA9IHJlZ2lzdGVySGFuZGxlcih0eXBlLCB0aGlzLmhhbmRsZXIsIHRoaXMubWFuYWdlciksXG4gICAgICAgICAgICBoYW5kbGVySWQgPSBfcmVnaXN0ZXJIYW5kbGVyLmhhbmRsZXJJZCxcbiAgICAgICAgICAgIHVucmVnaXN0ZXIgPSBfcmVnaXN0ZXJIYW5kbGVyLnVucmVnaXN0ZXI7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBoYW5kbGVySWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlck1vbml0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJDb25uZWN0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuXG4gICAgICAgIHZhciBnbG9iYWxNb25pdG9yID0gdGhpcy5tYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2xvYmFsTW9uaXRvci5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlKHRoaXMuaGFuZGxlQ2hhbmdlLCB7IGhhbmRsZXJJZHM6IFtoYW5kbGVySWRdIH0pO1xuXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKG5ldyBfZGlzcG9zYWJsZXMuQ29tcG9zaXRlRGlzcG9zYWJsZShuZXcgX2Rpc3Bvc2FibGVzLkRpc3Bvc2FibGUodW5zdWJzY3JpYmUpLCBuZXcgX2Rpc3Bvc2FibGVzLkRpc3Bvc2FibGUodW5yZWdpc3RlcikpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYW5kbGVDaGFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5TW91bnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLmdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgICBpZiAoISgwLCBfc2hhbGxvd0VxdWFsMi5kZWZhdWx0KShuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzcG9zZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyQ29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQobnVsbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaGFuZGxlQ2hpbGRSZWYnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoaWxkUmVmKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmRlY29yYXRlZENvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmhhbmRsZXIucmVjZWl2ZUNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEN1cnJlbnRTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFN0YXRlKCkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gY29sbGVjdCh0aGlzLmhhbmRsZXJDb25uZWN0b3IuaG9va3MsIHRoaXMuaGFuZGxlck1vbml0b3IpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKCgwLCBfaXNQbGFpbk9iamVjdDIuZGVmYXVsdCkobmV4dFN0YXRlKSwgJ0V4cGVjdGVkIGBjb2xsZWN0YCBzcGVjaWZpZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byAnICsgJyVzIGZvciAlcyB0byByZXR1cm4gYSBwbGFpbiBvYmplY3Qgb2YgcHJvcHMgdG8gaW5qZWN0LiAnICsgJ0luc3RlYWQsIHJlY2VpdmVkICVzLicsIGNvbnRhaW5lckRpc3BsYXlOYW1lLCBkaXNwbGF5TmFtZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChEZWNvcmF0ZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB0aGlzLnN0YXRlLCB7XG4gICAgICAgICAgcmVmOiB0aGlzLmhhbmRsZUNoaWxkUmVmXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRHJhZ0Ryb3BDb250YWluZXI7XG4gIH0oX3JlYWN0LkNvbXBvbmVudCksIF9jbGFzcy5EZWNvcmF0ZWRDb21wb25lbnQgPSBEZWNvcmF0ZWRDb21wb25lbnQsIF9jbGFzcy5kaXNwbGF5TmFtZSA9IGNvbnRhaW5lckRpc3BsYXlOYW1lICsgJygnICsgZGlzcGxheU5hbWUgKyAnKScsIF9jbGFzcy5jb250ZXh0VHlwZXMgPSB7XG4gICAgZHJhZ0Ryb3BNYW5hZ2VyOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkXG4gIH0sIF90ZW1wKTtcblxuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShEcmFnRHJvcENvbnRhaW5lciwgRGVjb3JhdGVkQ29tcG9uZW50KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2RlY29yYXRlSGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvZGVjb3JhdGVIYW5kbGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gd3JhcENvbm5lY3Rvckhvb2tzO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9jbG9uZVdpdGhSZWYgPSByZXF1aXJlKCcuL3V0aWxzL2Nsb25lV2l0aFJlZicpO1xuXG52YXIgX2Nsb25lV2l0aFJlZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZVdpdGhSZWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0aHJvd0lmQ29tcG9zaXRlQ29tcG9uZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vIEN1c3RvbSBjb21wb25lbnRzIGNhbiBubyBsb25nZXIgYmUgd3JhcHBlZCBkaXJlY3RseSBpbiBSZWFjdCBEbkQgMi4wXG4gIC8vIHNvIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBkZXBlbmQgb24gZmluZERPTU5vZGUoKSBmcm9tIHJlYWN0LWRvbS5cbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICd0aGUgY29tcG9uZW50JztcblxuICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbmF0aXZlIGVsZW1lbnQgbm9kZXMgY2FuIG5vdyBiZSBwYXNzZWQgdG8gUmVhY3QgRG5EIGNvbm5lY3RvcnMuJyArICgnWW91IGNhbiBlaXRoZXIgd3JhcCAnICsgZGlzcGxheU5hbWUgKyAnIGludG8gYSA8ZGl2Piwgb3IgdHVybiBpdCBpbnRvIGEgJykgKyAnZHJhZyBzb3VyY2Ugb3IgYSBkcm9wIHRhcmdldCBpdHNlbGYuJyk7XG59XG5cbmZ1bmN0aW9uIHdyYXBIb29rVG9SZWNvZ25pemVFbGVtZW50KGhvb2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudE9yTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgIC8vIFdoZW4gcGFzc2VkIGEgbm9kZSwgY2FsbCB0aGUgaG9vayBzdHJhaWdodCBhd2F5LlxuICAgIGlmICghKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoZWxlbWVudE9yTm9kZSkpIHtcbiAgICAgIHZhciBub2RlID0gZWxlbWVudE9yTm9kZTtcbiAgICAgIGhvb2sobm9kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIFJlYWN0RWxlbWVudCwgY2xvbmUgaXQgYW5kIGF0dGFjaCB0aGlzIGZ1bmN0aW9uIGFzIGEgcmVmLlxuICAgIC8vIFRoaXMgaGVscHMgdXMgYWNoaWV2ZSBhIG5lYXQgQVBJIHdoZXJlIHVzZXIgZG9lc24ndCBldmVuIGtub3cgdGhhdCByZWZzXG4gICAgLy8gYXJlIGJlaW5nIHVzZWQgdW5kZXIgdGhlIGhvb2QuXG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50T3JOb2RlO1xuICAgIHRocm93SWZDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gV2hlbiBubyBvcHRpb25zIGFyZSBwYXNzZWQsIHVzZSB0aGUgaG9vayBkaXJlY3RseVxuICAgIHZhciByZWYgPSBvcHRpb25zID8gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBob29rKG5vZGUsIG9wdGlvbnMpO1xuICAgIH0gOiBob29rO1xuXG4gICAgcmV0dXJuICgwLCBfY2xvbmVXaXRoUmVmMi5kZWZhdWx0KShlbGVtZW50LCByZWYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ29ubmVjdG9ySG9va3MoaG9va3MpIHtcbiAgdmFyIHdyYXBwZWRIb29rcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKGhvb2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2tleV07XG4gICAgdmFyIHdyYXBwZWRIb29rID0gd3JhcEhvb2tUb1JlY29nbml6ZUVsZW1lbnQoaG9vayk7XG4gICAgd3JhcHBlZEhvb2tzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHdyYXBwZWRIb29rcztcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3dyYXBDb25uZWN0b3JIb29rcy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvd3JhcENvbm5lY3Rvckhvb2tzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXJlT3B0aW9uc0VxdWFsO1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJy4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFyZU9wdGlvbnNFcXVhbChuZXh0T3B0aW9ucywgY3VycmVudE9wdGlvbnMpIHtcbiAgaWYgKGN1cnJlbnRPcHRpb25zID09PSBuZXh0T3B0aW9ucykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRPcHRpb25zICE9PSBudWxsICYmIG5leHRPcHRpb25zICE9PSBudWxsICYmICgwLCBfc2hhbGxvd0VxdWFsMi5kZWZhdWx0KShjdXJyZW50T3B0aW9ucywgbmV4dE9wdGlvbnMpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvYXJlT3B0aW9uc0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9hcmVPcHRpb25zRXF1YWwuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhbGlkVHlwZTtcblxudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIF9pc0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh0eXBlLCBhbGxvd0FycmF5KSB7XG4gICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGUpKSA9PT0gJ3N5bWJvbCcgfHwgYWxsb3dBcnJheSAmJiAoMCwgX2lzQXJyYXkyLmRlZmF1bHQpKHR5cGUpICYmIHR5cGUuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRUeXBlKHQsIGZhbHNlKTtcbiAgICAgICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL2lzVmFsaWRUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi91dGlscy9pc1ZhbGlkVHlwZS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7Y2xvc2VzdH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudEJhc2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcbiAgcmVuZGVyRGlzcGxheShyb3cpe1xuICAgIGlmKCFyb3cudmFsdWUpe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lcygndGxFdmVudERpc3BsYXlSb3cnLCByb3cua2V5KTtcbiAgICBpZihBcnJheS5pc0FycmF5KHJvdy52YWx1ZSkpe1xuICAgICAgaWYocm93LnZhbHVlLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBrZXk9e3Jvdy5rZXl9PlxuICAgICAgICAgIHtyb3cudmFsdWUubWFwKCh2YWwsIGtleSkgPT4gPGRpdiBrZXk9e2tleX0gY2xhc3NOYW1lPVwiaXRlbVwiPnt2YWx9PC9kaXY+KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PXtyb3cua2V5fT5cbiAgICAgICAge3Jvdy52YWx1ZX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuICByZW5kZXIoKXtcbiAgICBsZXQgZGlzcGxheVBvc2l0aW9uID0gJ2xlZnQnO1xuICAgIGlmKHRoaXMucmVmcy5iYXNlKXtcbiAgICAgIHZhciBwcmV2aWV3UmVjdCA9IHRoaXMucmVmcy5iYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8g44OJ44Op44OD44Kw5Lit44GrMOOBp+WPluOCjOOCi+OBk+OBqOOBjOOBguOCi+OAglxuICAgICAgLy8g54m544Gr5Y+z56uv44Gn44OJ44Op44OD44Kw44KS44KE44KB44KL44Go77yQ44Gn57WC44KP44Gj44GmZGlzcGxheVBvc2l0aW9u44GMcmlnaHTjgavjgarjgaPjgabjgZfjgYZcbiAgICAgIGlmKHByZXZpZXdSZWN0LndpZHRoICE9PSAwICYmIHByZXZpZXdSZWN0LndpZHRoICE9PSAwKXtcbiAgICAgICAgdmFyIHByZXZpZXdSaWdodFNpZGUgPSBwcmV2aWV3UmVjdC5sZWZ0ICsgcHJldmlld1JlY3Qud2lkdGg7XG4gICAgICAgIGlmKHRoaXMucHJvcHMudGltZWxpbmUuZ2V0VG90YWxXaWR0aCgpID4gcHJldmlld1JpZ2h0U2lkZSArIDcwKXtcbiAgICAgICAgICBkaXNwbGF5UG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj1cImJhc2VcIiBzdHlsZT17e2hlaWdodDogJzEwMCUnfX0+XG4gICAgICAgIHsoKCkgPT4ge1xuICAgICAgICAgIGlmKHRoaXMucHJvcHMuZHJhZ2dpbmdEaXNwbGF5KXtcbiAgICAgICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3RsRHJhZ2dpbmdEaXNwbGF5JywgZGlzcGxheVBvc2l0aW9uKX0gc3R5bGU9e3t0b3A6IHRoaXMucHJvcHMuZHJhZ2dpbmdEaXNwbGF5VG9wfX0+e3RoaXMucHJvcHMuZHJhZ2dpbmdEaXNwbGF5fTwvZGl2Pik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRsRXZlbnREaXNwbGF5XCI+XG4gICAgICAgICAge3RoaXMucHJvcHMuZGlzcGxheS5tYXAocm93ID0+IHRoaXMucmVuZGVyRGlzcGxheShyb3cpKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICZuYnNwO1xuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5FdmVudEJhc2UuZGVmYXVsdFByb3BzID0ge2Rpc3BsYXk6IFtdfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL0V2ZW50QmFzZS5qc3hcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9zcmMvY29tcG9uZW50cy9FdmVudEJhc2UuanN4IiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJpbXBvcnQgVGltZWxpbmUgZnJvbSAnLi9jb21wb25lbnRzL1RpbWVsaW5lJztcbmltcG9ydCBUaW1lIGZyb20gJy4vY2xhc3Nlcy9UaW1lJztcbmltcG9ydCBUaW1lU3BhbiBmcm9tICcuL2NsYXNzZXMvVGltZVNwYW4nO1xuXG5leHBvcnQge1RpbWVsaW5lLCBUaW1lLCBUaW1lU3Bhbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5lczZcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9zcmMvaW5kZXguZXM2IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUaW1lU3BhbiBmcm9tICcuLi9jbGFzc2VzL1RpbWVTcGFuJztcbmltcG9ydCBMaW5lIGZyb20gJy4vTGluZSc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IERyYWdEcm9wQ29udGV4dCB9IGZyb20gJ3JlYWN0LWRuZCc7XG5pbXBvcnQgRG5kQmFja2VuZCBmcm9tICdyZWFjdC1kbmQtdG91Y2gtYmFja2VuZCc7XG5pbXBvcnQgRXZlbnRQcmV2aWV3IGZyb20gJy4vRXZlbnRQcmV2aWV3JztcbmltcG9ydCBFdmVudCBmcm9tICcuL0V2ZW50JztcbmltcG9ydCBSdWxlciBmcm9tICcuL1J1bGVyJztcbmltcG9ydCBMaW5lTGFiZWwgZnJvbSAnLi9MaW5lTGFiZWwnO1xuaW1wb3J0IHsgRHJvcFRhcmdldCB9IGZyb20gJ3JlYWN0LWRuZCc7XG5cblxuY29uc3QgdGFyZ2V0ID0ge1xuICBkcm9wKHByb3BzLCBtb25pdG9yLCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gbW9uaXRvci5nZXRJdGVtKCk7XG4gICAgY29uc3QgZGVsdGEgPSBtb25pdG9yLmdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCgpO1xuXG4gICAgY29uc3QgaW5pdGFsT2Zmc2V0ID0gaXRlbS5kcmFnZ2luZ0NvbXBvbmVudC5nZXRPZmZzZXQoKTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLnJvdW5kKGluaXRhbE9mZnNldC50b3AgKyBkZWx0YS55KTtcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5yb3VuZChpbml0YWxPZmZzZXQubGVmdCArIGRlbHRhLngpO1xuXG4gICAgaXRlbS5kcmFnZ2luZ0NvbXBvbmVudC5tb3ZlVG8odG9wLCBsZWZ0KTtcbiAgfSxcbiAgaG92ZXIocHJvcHMsIG1vbml0b3IsIGNvbXBvbmVudCl7XG4gICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gbW9uaXRvci5nZXRTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICBpZihjbGllbnRPZmZzZXQpe1xuICAgICAgY29uc3QgaXRlbSA9IG1vbml0b3IuZ2V0SXRlbSgpO1xuICAgICAgY29uc3QgbGluZVdyYXBwZXJCb3VuZHMgPSBjb21wb25lbnQucmVmcy5saW5lc1dyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBsaW5lQ29tcG9uZW50ID0gcHJvcHMudGltZWxpbmUuZHJhZ2dpbmdPdmVyKGNsaWVudE9mZnNldC54IC0gbGluZVdyYXBwZXJCb3VuZHMubGVmdCArIChpdGVtLmRyYWdnaW5nQ29tcG9uZW50LnByb3BzLndpZHRoIC8gMi8qZXZlbnTjga7nnJ/jgpPkuK3jgpLln7rmupbjgavjgZnjgosqLykpO1xuICAgICAgY29uc3QgdGltZSA9IHByb3BzLnRpbWVsaW5lLnRvcFRvVGltZShjbGllbnRPZmZzZXQueSArIGNvbXBvbmVudC5yZWZzLmxpbmVzV3JhcHBlci5zY3JvbGxUb3AgLSBsaW5lV3JhcHBlckJvdW5kcy50b3ApO1xuICAgICAgaXRlbS5kcmFnZ2luZ0NvbXBvbmVudC5kcmFnZ2luZyh0aW1lLCBsaW5lQ29tcG9uZW50ID8gbGluZUNvbXBvbmVudC5wcm9wcy5pZCA6IG51bGwpO1xuICAgIH1cbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNvbGxlY3QoY29ubmVjdCwgbW9uaXRvcikge1xuICByZXR1cm4ge1xuICAgIGNvbm5lY3REcm9wVGFyZ2V0OiBjb25uZWN0LmRyb3BUYXJnZXQoKVxuICB9O1xufVxuXG5jbGFzcyBGcmFtZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxue1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIGNvbnN0IHJ1bGVySW50ZXJ2YWwgPSA0O1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1pbldpZHRoOiAwLFxuICAgIH1cblxuICAgIHRoaXMucmVzaXppbmdFdmVudCA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnByb3BzLnRpbWVsaW5lLmZyYW1lQ29tcG9uZW50ID0gdGhpcztcbiAgfVxuXG4gIHJlc2l6ZVVwKGV2ZW50Q29tcG9uZW50LCBjbGlja2VkVG9wKXtcbiAgICBjb25zdCBpbml0aWFsSGVpZ2h0ID0gZXZlbnRDb21wb25lbnQuc3RhdGUuaGVpZ2h0O1xuICAgIGNvbnN0IHByZXZCb3R0b20gPSB0aGlzLnByb3BzLnRpbWVsaW5lLmdldFByZXZCb3R0b20oZXZlbnRDb21wb25lbnQpO1xuICAgIGNvbnN0IG1vdXNlTW92ZUV2ZW50ID0gKG1vdmVFdmVudCkgPT4ge1xuICAgICAgZXZlbnRDb21wb25lbnQucmVzaXppbmcgPSB0cnVlO1xuICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gaW5pdGlhbEhlaWdodCArIGNsaWNrZWRUb3AgLSBtb3ZlRXZlbnQuY2xpZW50WTtcbiAgICAgIGlmKHRhcmdldEhlaWdodCA+IDM2KXtcbiAgICAgICAgbGV0IHRhcmdldFRvcCA9IGV2ZW50Q29tcG9uZW50LnN0YXRlLnRvcCAtICh0YXJnZXRIZWlnaHQgLSBldmVudENvbXBvbmVudC5zdGF0ZS5oZWlnaHQpO1xuICAgICAgICBpZih0YXJnZXRUb3AgPD0gcHJldkJvdHRvbSl7XG4gICAgICAgICAgdGFyZ2V0VG9wID0gcHJldkJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50Q29tcG9uZW50LnJlc2l6aW5nVGltZVNwYW4gPSBuZXcgVGltZVNwYW4odGhpcy5wcm9wcy50aW1lbGluZS50b3BUb1RpbWUodGFyZ2V0VG9wKSwgZXZlbnRDb21wb25lbnQuY3VycmVudFRpbWVTcGFuLmdldEVuZFRpbWUoKSk7XG4gICAgICAgIGV2ZW50Q29tcG9uZW50LnNldFN0YXRlKHtcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMudGltZWxpbmUudGltZVNwYW5Ub0hlaWdodChldmVudENvbXBvbmVudC5yZXNpemluZ1RpbWVTcGFuKSxcbiAgICAgICAgICB0b3A6IHRoaXMucHJvcHMudGltZWxpbmUudGltZVRvVG9wKGV2ZW50Q29tcG9uZW50LnJlc2l6aW5nVGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpLFxuICAgICAgICAgIGRyYWdnaW5nRGlzcGxheTogZXZlbnRDb21wb25lbnQucmVzaXppbmdUaW1lU3Bhbi5nZXRTdGFydFRpbWUoKS5nZXREaXNwbGF5VGltZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzdG9wTW92ZUV2ZW50ID0gKG1vdXNlRXZlbnQpID0+IHtcbiAgICAgIHRoaXMucmVmcy5saW5lc1dyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgdGhpcy5yZWZzLmxpbmVzV3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3RvcE1vdmVFdmVudCk7XG4gICAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzdG9wTW92ZUV2ZW50KTtcbiAgICAgIGV2ZW50Q29tcG9uZW50LmVuZFJlc2l6aW5nKG1vdXNlRXZlbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlTW92ZUV2ZW50KTtcbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdG9wTW92ZUV2ZW50KTtcbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzdG9wTW92ZUV2ZW50KTtcbiAgfVxuXG4gIHJlc2l6ZURvd24oZXZlbnRDb21wb25lbnQsIGNsaWNrZWRUb3Ape1xuICAgIGNvbnN0IGluaXRpYWxIZWlnaHQgPSBldmVudENvbXBvbmVudC5zdGF0ZS5oZWlnaHQ7XG4gICAgY29uc3QgbmV4dFRvcCA9IHRoaXMucHJvcHMudGltZWxpbmUuZ2V0TmV4dFRvcChldmVudENvbXBvbmVudCk7XG4gICAgY29uc3QgbW91c2VNb3ZlRXZlbnQgPSAobW92ZUV2ZW50KSA9PiB7XG4gICAgICBldmVudENvbXBvbmVudC5yZXNpemluZyA9IHRydWU7XG4gICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSBpbml0aWFsSGVpZ2h0ICsgbW92ZUV2ZW50LmNsaWVudFkgLSBjbGlja2VkVG9wO1xuICAgICAgaWYodGFyZ2V0SGVpZ2h0ID4gMzYpe1xuICAgICAgICBsZXQgdGFyZ2V0Qm90dG9tID0gZXZlbnRDb21wb25lbnQuc3RhdGUudG9wICsgdGFyZ2V0SGVpZ2h0O1xuICAgICAgICBpZih0YXJnZXRCb3R0b20gPj0gbmV4dFRvcCl7XG4gICAgICAgICAgdGFyZ2V0Qm90dG9tID0gbmV4dFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50Q29tcG9uZW50LnJlc2l6aW5nVGltZVNwYW4gPSBuZXcgVGltZVNwYW4oZXZlbnRDb21wb25lbnQuY3VycmVudFRpbWVTcGFuLmdldFN0YXJ0VGltZSgpLCB0aGlzLnByb3BzLnRpbWVsaW5lLnRvcFRvVGltZSh0YXJnZXRCb3R0b20pKTtcbiAgICAgICAgZXZlbnRDb21wb25lbnQuc2V0U3RhdGUoe1xuICAgICAgICAgIGhlaWdodDogdGhpcy5wcm9wcy50aW1lbGluZS50aW1lU3BhblRvSGVpZ2h0KGV2ZW50Q29tcG9uZW50LnJlc2l6aW5nVGltZVNwYW4pLFxuICAgICAgICAgIGRyYWdnaW5nRGlzcGxheTogZXZlbnRDb21wb25lbnQucmVzaXppbmdUaW1lU3Bhbi5nZXRFbmRUaW1lKCkuZ2V0RGlzcGxheVRpbWUoKSxcbiAgICAgICAgICBkcmFnZ2luZ0Rpc3BsYXlUb3A6IHRhcmdldEhlaWdodCAtIDEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzdG9wTW92ZUV2ZW50ID0gKG1vdXNlRXZlbnQpID0+IHtcbiAgICAgIHRoaXMucmVmcy5saW5lc1dyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgdGhpcy5yZWZzLmxpbmVzV3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3RvcE1vdmVFdmVudCk7XG4gICAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzdG9wTW92ZUV2ZW50KTtcbiAgICAgIGV2ZW50Q29tcG9uZW50LmVuZFJlc2l6aW5nKG1vdXNlRXZlbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlTW92ZUV2ZW50KTtcbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdG9wTW92ZUV2ZW50KTtcbiAgICB0aGlzLnJlZnMubGluZXNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzdG9wTW92ZUV2ZW50KTtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpe1xuICAgIHRoaXMuc2V0U3RhdGUoe2hlaWdodDogaGVpZ2h0fSk7XG4gIH1cblxuICBnZXRSZWxhdGl2ZVBvcyhlKXtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBlLmNsaWVudFkgLSBlLmN1cnJlbnRUYXJnZXQub2Zmc2V0VG9wICsgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvcCxcbiAgICAgIGxlZnQ6IGUuY2xpZW50WCAtIGUuY3VycmVudFRhcmdldC5vZmZzZXRMZWZ0ICsgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbExlZnRcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKXtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIG1pbldpZHRoOiB0aGlzLnByb3BzLnRpbWVsaW5lLmdldFRvdGFsV2lkdGgoKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUsIHRoaXMuY29ycmVjdE91dHNpZGVFdmVudHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpe1xuICAgIGNvbnN0IG5ld1N0YXRlID0ge307XG5cbiAgICBpZihuZXh0UHJvcHMubGluZURhdGEgIT09IHRoaXMucHJvcHMubGluZURhdGEpe1xuICAgICAgbmV3U3RhdGUubWluV2lkdGggPSB0aGlzLnByb3BzLnRpbWVsaW5lLmdldFRvdGFsV2lkdGgoKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUsIHRoaXMuY29ycmVjdE91dHNpZGVFdmVudHMpXG4gIH1cblxuICBjb3JyZWN0T3V0c2lkZUV2ZW50cygpe1xuICAgIHRoaXMucHJvcHMudGltZWxpbmUuZXZlbnRDb21wb25lbnRzLmZvckVhY2goZXZlbnQgPT4gZXZlbnQuY29ycmVjdFBvc2l0aW9uKCkpXG4gIH1cblxuICByZW5kZXIoKXtcbiAgICBjb25zdCB7IGNvbm5lY3REcm9wVGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj17ZWxlbSA9PiB0aGlzLmVsZW1lbnQgPSBlbGVtfSBjbGFzc05hbWU9XCJ0bEZyYW1lVmlldyBzY3JvbGxXcmFwcGVyXCIgc3R5bGU9e3t3aWR0aDogdGhpcy5wcm9wcy53aWR0aCwgb3ZlcmZsb3dYOiAnYXV0byd9fT5cbiAgICAgICAgPGRpdiBzdHlsZT17e21pbldpZHRoOiB0aGlzLnN0YXRlLm1pbldpZHRoICsgdGhpcy5wcm9wcy5jaGlsZFdpZHRoLCBkaXNwbGF5OlwiZmxleFwifX0+XG4gICAgICAgICAgeygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdERyb3BUYXJnZXQoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGluZXNGcmFtZVwiIHN0eWxlPXt7d2lkdGg6IHRoaXMuc3RhdGUubWluV2lkdGgsIG92ZXJmbG93OiAnaGlkZGVuJ319PlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3t3aWR0aDogdGhpcy5zdGF0ZS5taW5XaWR0aCArIDIwfX0+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRsTGFiZWxWaWV3XCIgc3R5bGU9e3toZWlnaHQ6IExpbmVMYWJlbC5oZWlnaHR9fT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMubGluZURhdGEubWFwKChkYXRhLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNSdWxlciA9IGtleSAlIHRoaXMucHJvcHMucnVsZXJJbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UnVsZXIgPSAoa2V5ICsgMSkgJSB0aGlzLnByb3BzLnJ1bGVySW50ZXJ2YWwgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgPExpbmVMYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2RhdGEuaWQgKyBcIkBcIiArIGtleX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMubGluZVdpZHRofVxuICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSdWxlcj17aGFzUnVsZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZSdWxlcj17cHJldlJ1bGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17ZGF0YS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmU9e3RoaXMucHJvcHMudGltZWxpbmV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdD17a2V5ID09IHRoaXMucHJvcHMubGluZURhdGEubGVuZ3RoIC0gMX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJsaW5lc1dyYXBwZXJcIiBjbGFzc05hbWU9XCJ0bExpbmVzV3JhcHBlciBzY3JvbGxXcmFwcGVyXCIgc3R5bGU9e3toZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0IC0gTGluZUxhYmVsLmhlaWdodH19PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7aGVpZ2h0OiB0aGlzLnByb3BzLmxpbmVIZWlnaHQsIG92ZXJmbG93WTogXCJoaWRkZW5cIiwgcG9zaXRpb246XCJyZWxhdGl2ZVwifX0+XG4gICAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMubGluZURhdGEubWFwKChkYXRhLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1J1bGVyID0ga2V5ICUgdGhpcy5wcm9wcy5ydWxlckludGVydmFsID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJ1bGVyID0gKGtleSArIDEpICUgdGhpcy5wcm9wcy5ydWxlckludGVydmFsID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8TGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17XCJsaW5lQFwiICsgZGF0YS5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSdWxlcj17aGFzUnVsZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtkYXRhLmlkICsgXCJAXCIgKyBrZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2RhdGEuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMubGluZVdpZHRofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkhlaWdodD17dGhpcy5wcm9wcy5taW5IZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZVNwYW49e3RoaXMucHJvcHMudGltZVNwYW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbj17a2V5ICUgMiA9PT0gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZT17dGhpcy5wcm9wcy50aW1lbGluZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzPXtkYXRhLnZhcnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWU9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9e1wiZXZlbnRAXCIgKyBldmVudC5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2V2ZW50LmtleXx8ZXZlbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2V2ZW50LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yPXtldmVudC5jb2xvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3Bhbj17ZXZlbnQudGltZVNwYW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheT17ZXZlbnQuZGlzcGxheX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSWQ9e2V2ZW50LmxpbmVJZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZT17dGhpcy5wcm9wcy50aW1lbGluZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy50aW1lbGluZS5wcm9wcy5saW5lV2lkdGggLSAyIC0gKExpbmUuc2lkZVBhZGRpbmcgKiAyKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzPXtldmVudC52YXJzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0PXtldmVudC5mbG9hdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb249e2V2ZW50LmFjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxFdmVudFByZXZpZXcgdGltZWxpbmU9e3RoaXMucHJvcHMudGltZWxpbmV9IC8+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkoKX1cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG4vLyBGcmFtZS5wcm9wVHlwZXMgPSB7XG4vLyAgIHRpbWVTcGFuOiBSZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihUaW1lU3BhbikuaXNSZXF1aXJlZCxcbi8vICAgbGluZURhdGE6IFJlYWN0LlByb3BUeXBlcy5hcnJheU9mKFJlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4vLyAgICAgaWQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbi8vICAgICBsYWJlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG4vLyAgIH0pKS5pc1JlcXVpcmVkLFxuLy8gICBsaW5lV2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbi8vICAgbWluSGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4vLyAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuLy8gICB0aW1lbGluZTogUmVhY3QuUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkLFxuLy8gICBydWxlckludGVydmFsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4vLyAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4vLyB9XG5cbkZyYW1lLmRlZmF1bHRQcm9wcyA9IHtcbiAgZXZlbnRzOiBbXSxcbiAgY2hpbGRXaWR0aDogMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0Ryb3BDb250ZXh0KERuZEJhY2tlbmQoeyBlbmFibGVNb3VzZUV2ZW50czogdHJ1ZSB9KSkoRHJvcFRhcmdldChcIkV2ZW50XCIsIHRhcmdldCwgY29sbGVjdCkoRnJhbWUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL0ZyYW1lLmpzeFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0ZyYW1lLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGltZSBmcm9tICcuLi9jbGFzc2VzL1RpbWUnXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG91ciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxue1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBtaW51dGVzOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IG1pblN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLm1pbkhlaWdodCArICdweCdcbiAgICB9XG4gICAgVGltZS5lYWNoTWluKChrZXksIG1pbikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5taW51dGVzLnB1c2goXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBrZXk9e21pbn1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3RsTWluVmlldycsICd0bCcgKyBtaW4pfVxuICAgICAgICAgIHN0eWxlPXttaW5TdHlsZX1cbiAgICAgICAgPiZuYnNwOzwvZGl2PlxuICAgICAgKTtcbiAgICB9LCAxNSlcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndGxIb3VyVmlldycsICd0bCcgKyB0aGlzLnByb3BzLnRpbWUuZ2V0SG91cigpKX0+e3RoaXMuc3RhdGUubWludXRlc308L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbi8vIEhvdXIucHJvcFR5cGVzID0ge1xuLy8gICBtaW5IZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbi8vICAgdGltZTogUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoVGltZSkuaXNSZXF1aXJlZFxuLy8gfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvSG91ci5qc3hcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9zcmMvY29tcG9uZW50cy9Ib3VyLmpzeCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9EcmFnRHJvcE1hbmFnZXIgPSByZXF1aXJlKCcuL0RyYWdEcm9wTWFuYWdlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RyYWdEcm9wTWFuYWdlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdEcm9wTWFuYWdlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRHJhZ1NvdXJjZSA9IHJlcXVpcmUoJy4vRHJhZ1NvdXJjZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RyYWdTb3VyY2UnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnU291cmNlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Ecm9wVGFyZ2V0ID0gcmVxdWlyZSgnLi9Ecm9wVGFyZ2V0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRHJvcFRhcmdldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3BUYXJnZXQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2NyZWF0ZVRlc3RCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kcy9jcmVhdGVUZXN0QmFja2VuZCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVRlc3RCYWNrZW5kJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVGVzdEJhY2tlbmQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJ3JlZHV4L2xpYi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9yZWR1Y2VycyA9IHJlcXVpcmUoJy4vcmVkdWNlcnMnKTtcblxudmFyIF9yZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWR1Y2Vycyk7XG5cbnZhciBfZHJhZ0Ryb3AgPSByZXF1aXJlKCcuL2FjdGlvbnMvZHJhZ0Ryb3AnKTtcblxudmFyIGRyYWdEcm9wQWN0aW9ucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kcmFnRHJvcCk7XG5cbnZhciBfRHJhZ0Ryb3BNb25pdG9yID0gcmVxdWlyZSgnLi9EcmFnRHJvcE1vbml0b3InKTtcblxudmFyIF9EcmFnRHJvcE1vbml0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ0Ryb3BNb25pdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERyYWdEcm9wTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRHJhZ0Ryb3BNYW5hZ2VyKGNyZWF0ZUJhY2tlbmQpIHtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ0Ryb3BNYW5hZ2VyKTtcblxuICAgIHZhciBzdG9yZSA9ICgwLCBfY3JlYXRlU3RvcmUyLmRlZmF1bHQpKF9yZWR1Y2VyczIuZGVmYXVsdCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5tb25pdG9yID0gbmV3IF9EcmFnRHJvcE1vbml0b3IyLmRlZmF1bHQoc3RvcmUpO1xuICAgIHRoaXMucmVnaXN0cnkgPSB0aGlzLm1vbml0b3IucmVnaXN0cnk7XG4gICAgdGhpcy5iYWNrZW5kID0gY3JlYXRlQmFja2VuZCh0aGlzKTtcblxuICAgIHN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZVJlZkNvdW50Q2hhbmdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyYWdEcm9wTWFuYWdlciwgW3tcbiAgICBrZXk6ICdoYW5kbGVSZWZDb3VudENoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlZkNvdW50Q2hhbmdlKCkge1xuICAgICAgdmFyIHNob3VsZFNldFVwID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnJlZkNvdW50ID4gMDtcbiAgICAgIGlmIChzaG91bGRTZXRVcCAmJiAhdGhpcy5pc1NldFVwKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5zZXR1cCgpO1xuICAgICAgICB0aGlzLmlzU2V0VXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghc2hvdWxkU2V0VXAgJiYgdGhpcy5pc1NldFVwKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC50ZWFyZG93bigpO1xuICAgICAgICB0aGlzLmlzU2V0VXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb250ZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9uaXRvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vbml0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb25pdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEJhY2tlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYWNrZW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSZWdpc3RyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZ2lzdHJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QWN0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGlvbnMoKSB7XG4gICAgICB2YXIgbWFuYWdlciA9IHRoaXM7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSB0aGlzLnN0b3JlLmRpc3BhdGNoO1xuXG5cbiAgICAgIGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uQ3JlYXRvci5hcHBseShtYW5hZ2VyLCBhcmdzKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZHJhZ0Ryb3BBY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRyYWdEcm9wQWN0aW9uc1trZXldID09PSAnZnVuY3Rpb24nO1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChib3VuZEFjdGlvbnMsIGtleSkge1xuICAgICAgICB2YXIgYWN0aW9uID0gZHJhZ0Ryb3BBY3Rpb25zW2tleV07XG4gICAgICAgIGJvdW5kQWN0aW9uc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXR1cm4gYm91bmRBY3Rpb25zO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcmFnRHJvcE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdEcm9wTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvRHJhZ0Ryb3BNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0RyYWdEcm9wTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQWN0aW9uVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICAgKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAgICpcbiAgICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICAgKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gICAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICAgKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gICAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gICAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gICAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gICAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAgICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICAgKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICAgKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gICAqL1xufTtmdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MlsnZGVmYXVsdCddKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWR1Y2U7XG5cbnZhciBfZHJhZ09mZnNldCA9IHJlcXVpcmUoJy4vZHJhZ09mZnNldCcpO1xuXG52YXIgX2RyYWdPZmZzZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJhZ09mZnNldCk7XG5cbnZhciBfZHJhZ09wZXJhdGlvbiA9IHJlcXVpcmUoJy4vZHJhZ09wZXJhdGlvbicpO1xuXG52YXIgX2RyYWdPcGVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJhZ09wZXJhdGlvbik7XG5cbnZhciBfcmVmQ291bnQgPSByZXF1aXJlKCcuL3JlZkNvdW50Jyk7XG5cbnZhciBfcmVmQ291bnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVmQ291bnQpO1xuXG52YXIgX2RpcnR5SGFuZGxlcklkcyA9IHJlcXVpcmUoJy4vZGlydHlIYW5kbGVySWRzJyk7XG5cbnZhciBfZGlydHlIYW5kbGVySWRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpcnR5SGFuZGxlcklkcyk7XG5cbnZhciBfc3RhdGVJZCA9IHJlcXVpcmUoJy4vc3RhdGVJZCcpO1xuXG52YXIgX3N0YXRlSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhdGVJZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHJlZHVjZSgpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICByZXR1cm4ge1xuICAgIGRpcnR5SGFuZGxlcklkczogKDAsIF9kaXJ0eUhhbmRsZXJJZHMyLmRlZmF1bHQpKHN0YXRlLmRpcnR5SGFuZGxlcklkcywgYWN0aW9uLCBzdGF0ZS5kcmFnT3BlcmF0aW9uKSxcbiAgICBkcmFnT2Zmc2V0OiAoMCwgX2RyYWdPZmZzZXQyLmRlZmF1bHQpKHN0YXRlLmRyYWdPZmZzZXQsIGFjdGlvbiksXG4gICAgcmVmQ291bnQ6ICgwLCBfcmVmQ291bnQyLmRlZmF1bHQpKHN0YXRlLnJlZkNvdW50LCBhY3Rpb24pLFxuICAgIGRyYWdPcGVyYXRpb246ICgwLCBfZHJhZ09wZXJhdGlvbjIuZGVmYXVsdCkoc3RhdGUuZHJhZ09wZXJhdGlvbiwgYWN0aW9uKSxcbiAgICBzdGF0ZUlkOiAoMCwgX3N0YXRlSWQyLmRlZmF1bHQpKHN0YXRlLnN0YXRlSWQpXG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBkcmFnT3BlcmF0aW9uO1xuXG52YXIgX3dpdGhvdXQgPSByZXF1aXJlKCdsb2Rhc2gvd2l0aG91dCcpO1xuXG52YXIgX3dpdGhvdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aG91dCk7XG5cbnZhciBfZHJhZ0Ryb3AgPSByZXF1aXJlKCcuLi9hY3Rpb25zL2RyYWdEcm9wJyk7XG5cbnZhciBfcmVnaXN0cnkgPSByZXF1aXJlKCcuLi9hY3Rpb25zL3JlZ2lzdHJ5Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGl0ZW1UeXBlOiBudWxsLFxuICBpdGVtOiBudWxsLFxuICBzb3VyY2VJZDogbnVsbCxcbiAgdGFyZ2V0SWRzOiBbXSxcbiAgZHJvcFJlc3VsdDogbnVsbCxcbiAgZGlkRHJvcDogZmFsc2UsXG4gIGlzU291cmNlUHVibGljOiBudWxsXG59O1xuXG5mdW5jdGlvbiBkcmFnT3BlcmF0aW9uKCkge1xuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuQkVHSU5fRFJBRzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXRlbVR5cGU6IGFjdGlvbi5pdGVtVHlwZSxcbiAgICAgICAgaXRlbTogYWN0aW9uLml0ZW0sXG4gICAgICAgIHNvdXJjZUlkOiBhY3Rpb24uc291cmNlSWQsXG4gICAgICAgIGlzU291cmNlUHVibGljOiBhY3Rpb24uaXNTb3VyY2VQdWJsaWMsXG4gICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgIGRpZERyb3A6IGZhbHNlXG4gICAgICB9KTtcbiAgICBjYXNlIF9kcmFnRHJvcC5QVUJMSVNIX0RSQUdfU09VUkNFOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBpc1NvdXJjZVB1YmxpYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgY2FzZSBfZHJhZ0Ryb3AuSE9WRVI6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHRhcmdldElkczogYWN0aW9uLnRhcmdldElkc1xuICAgICAgfSk7XG4gICAgY2FzZSBfcmVnaXN0cnkuUkVNT1ZFX1RBUkdFVDpcbiAgICAgIGlmIChzdGF0ZS50YXJnZXRJZHMuaW5kZXhPZihhY3Rpb24udGFyZ2V0SWQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHRhcmdldElkczogKDAsIF93aXRob3V0Mi5kZWZhdWx0KShzdGF0ZS50YXJnZXRJZHMsIGFjdGlvbi50YXJnZXRJZClcbiAgICAgIH0pO1xuICAgIGNhc2UgX2RyYWdEcm9wLkRST1A6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGRyb3BSZXN1bHQ6IGFjdGlvbi5kcm9wUmVzdWx0LFxuICAgICAgICBkaWREcm9wOiB0cnVlLFxuICAgICAgICB0YXJnZXRJZHM6IFtdXG4gICAgICB9KTtcbiAgICBjYXNlIF9kcmFnRHJvcC5FTkRfRFJBRzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXRlbVR5cGU6IG51bGwsXG4gICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIHNvdXJjZUlkOiBudWxsLFxuICAgICAgICBkcm9wUmVzdWx0OiBudWxsLFxuICAgICAgICBkaWREcm9wOiBmYWxzZSxcbiAgICAgICAgaXNTb3VyY2VQdWJsaWM6IG51bGwsXG4gICAgICAgIHRhcmdldElkczogW11cbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvZHJhZ09wZXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9yZWR1Y2Vycy9kcmFnT3BlcmF0aW9uLmpzIiwidmFyIGJhc2VEaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9fYmFzZURpZmZlcmVuY2UnKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IFszXVxuICovXG52YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICA6IFtdO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aG91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC93aXRob3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL3dpdGhvdXQuanMiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWZDb3VudDtcblxudmFyIF9yZWdpc3RyeSA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvcmVnaXN0cnknKTtcblxuZnVuY3Rpb24gcmVmQ291bnQoKSB7XG4gIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBfcmVnaXN0cnkuQUREX1NPVVJDRTpcbiAgICBjYXNlIF9yZWdpc3RyeS5BRERfVEFSR0VUOlxuICAgICAgcmV0dXJuIHN0YXRlICsgMTtcbiAgICBjYXNlIF9yZWdpc3RyeS5SRU1PVkVfU09VUkNFOlxuICAgIGNhc2UgX3JlZ2lzdHJ5LlJFTU9WRV9UQVJHRVQ6XG4gICAgICByZXR1cm4gc3RhdGUgLSAxO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvcmVmQ291bnQuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3JlZHVjZXJzL3JlZkNvdW50LmpzIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVhvciA9IHJlcXVpcmUoJy4vX2Jhc2VYb3InKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gKiAvLyA9PiBbMSwgM11cbiAqL1xudmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB4b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gveG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC94b3IuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ2YXIgYmFzZURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL19iYXNlRGlmZmVyZW5jZScpLFxuICAgIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlWG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlWG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVhvci5qcyIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi9fYmFzZUludGVyc2VjdGlvbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBjYXN0QXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9fY2FzdEFycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzJdXG4gKi9cbnZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcnNlY3Rpb24uanMiLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgfVxuICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cbiAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoIShzZWVuXG4gICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICkpIHtcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUludGVyc2VjdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUludGVyc2VjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbnRlcnNlY3Rpb24uanMiLCJ2YXIgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEFycmF5TGlrZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEFycmF5TGlrZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RBcnJheUxpa2VPYmplY3QuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN0YXRlSWQ7XG5mdW5jdGlvbiBzdGF0ZUlkKCkge1xuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgcmV0dXJuIHN0YXRlICsgMTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvc3RhdGVJZC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvcmVkdWNlcnMvc3RhdGVJZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIF9pc0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXkpO1xuXG52YXIgX21hdGNoZXNUeXBlID0gcmVxdWlyZSgnLi91dGlscy9tYXRjaGVzVHlwZScpO1xuXG52YXIgX21hdGNoZXNUeXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoZXNUeXBlKTtcblxudmFyIF9IYW5kbGVyUmVnaXN0cnkgPSByZXF1aXJlKCcuL0hhbmRsZXJSZWdpc3RyeScpO1xuXG52YXIgX0hhbmRsZXJSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYW5kbGVyUmVnaXN0cnkpO1xuXG52YXIgX2RyYWdPZmZzZXQgPSByZXF1aXJlKCcuL3JlZHVjZXJzL2RyYWdPZmZzZXQnKTtcblxudmFyIF9kaXJ0eUhhbmRsZXJJZHMgPSByZXF1aXJlKCcuL3JlZHVjZXJzL2RpcnR5SGFuZGxlcklkcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRHJhZ0Ryb3BNb25pdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEcmFnRHJvcE1vbml0b3Ioc3RvcmUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ0Ryb3BNb25pdG9yKTtcblxuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IF9IYW5kbGVyUmVnaXN0cnkyLmRlZmF1bHQoc3RvcmUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyYWdEcm9wTW9uaXRvciwgW3tcbiAgICBrZXk6ICdzdWJzY3JpYmVUb1N0YXRlQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShsaXN0ZW5lcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGhhbmRsZXJJZHMgPSBvcHRpb25zLmhhbmRsZXJJZHM7XG5cbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicsICdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIGhhbmRsZXJJZHMgPT09ICd1bmRlZmluZWQnIHx8ICgwLCBfaXNBcnJheTIuZGVmYXVsdCkoaGFuZGxlcklkcyksICdoYW5kbGVySWRzLCB3aGVuIHNwZWNpZmllZCwgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLicpO1xuXG4gICAgICB2YXIgcHJldlN0YXRlSWQgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkuc3RhdGVJZDtcbiAgICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGVJZCA9IHN0YXRlLnN0YXRlSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNhblNraXBMaXN0ZW5lciA9IGN1cnJlbnRTdGF0ZUlkID09PSBwcmV2U3RhdGVJZCB8fCBjdXJyZW50U3RhdGVJZCA9PT0gcHJldlN0YXRlSWQgKyAxICYmICEoMCwgX2RpcnR5SGFuZGxlcklkcy5hcmVEaXJ0eSkoc3RhdGUuZGlydHlIYW5kbGVySWRzLCBoYW5kbGVySWRzKTtcblxuICAgICAgICAgIGlmICghY2FuU2tpcExpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBwcmV2U3RhdGVJZCA9IGN1cnJlbnRTdGF0ZUlkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdWJzY3JpYmVUb09mZnNldENoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJywgJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcblxuICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldDtcbiAgICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBfdGhpczIuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0O1xuICAgICAgICBpZiAobmV4dFN0YXRlID09PSBwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbkRyYWdTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmFnU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5yZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHNvdXJjZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSB2YWxpZCBzb3VyY2UuJyk7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2UuY2FuRHJhZyh0aGlzLCBzb3VyY2VJZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FuRHJvcE9uVGFyZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5yZWdpc3RyeS5nZXRUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRhcmdldCwgJ0V4cGVjdGVkIHRvIGZpbmQgYSB2YWxpZCB0YXJnZXQuJyk7XG5cbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkgfHwgdGhpcy5kaWREcm9wKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0VHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCk7XG4gICAgICB2YXIgZHJhZ2dlZEl0ZW1UeXBlID0gdGhpcy5nZXRJdGVtVHlwZSgpO1xuICAgICAgcmV0dXJuICgwLCBfbWF0Y2hlc1R5cGUyLmRlZmF1bHQpKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkgJiYgdGFyZ2V0LmNhbkRyb3AodGhpcywgdGFyZ2V0SWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzRHJhZ2dpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RyYWdnaW5nKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRJdGVtVHlwZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0RyYWdnaW5nU291cmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEcmFnZ2luZ1NvdXJjZShzb3VyY2VJZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMucmVnaXN0cnkuZ2V0U291cmNlKHNvdXJjZUlkLCB0cnVlKTtcbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShzb3VyY2UsICdFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLicpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpIHx8ICF0aGlzLmlzU291cmNlUHVibGljKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlVHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICB2YXIgZHJhZ2dlZEl0ZW1UeXBlID0gdGhpcy5nZXRJdGVtVHlwZSgpO1xuICAgICAgaWYgKHNvdXJjZVR5cGUgIT09IGRyYWdnZWRJdGVtVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2UuaXNEcmFnZ2luZyh0aGlzLCBzb3VyY2VJZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNPdmVyVGFyZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPdmVyVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyBzaGFsbG93OiBmYWxzZSB9O1xuICAgICAgdmFyIHNoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG5cbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0VHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCk7XG4gICAgICB2YXIgZHJhZ2dlZEl0ZW1UeXBlID0gdGhpcy5nZXRJdGVtVHlwZSgpO1xuICAgICAgaWYgKCEoMCwgX21hdGNoZXNUeXBlMi5kZWZhdWx0KSh0YXJnZXRUeXBlLCBkcmFnZ2VkSXRlbVR5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldElkcyA9IHRoaXMuZ2V0VGFyZ2V0SWRzKCk7XG4gICAgICBpZiAoIXRhcmdldElkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSB0YXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCk7XG4gICAgICBpZiAoc2hhbGxvdykge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IHRhcmdldElkcy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SXRlbVR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pdGVtVHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pdGVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNvdXJjZUlkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U291cmNlSWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uc291cmNlSWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGFyZ2V0SWRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0SWRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLnRhcmdldElkcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREcm9wUmVzdWx0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHJvcFJlc3VsdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5kcm9wUmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RpZERyb3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWREcm9wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLmRpZERyb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNTb3VyY2VQdWJsaWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NvdXJjZVB1YmxpYygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pc1NvdXJjZVB1YmxpYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJbml0aWFsQ2xpZW50T2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldC5pbml0aWFsQ2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0LmluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2xpZW50T2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0LmNsaWVudE9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9kcmFnT2Zmc2V0LmdldFNvdXJjZUNsaWVudE9mZnNldCkodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCgpIHtcbiAgICAgIHJldHVybiAoMCwgX2RyYWdPZmZzZXQuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KSh0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyYWdEcm9wTW9uaXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ0Ryb3BNb25pdG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9EcmFnRHJvcE1vbml0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0RyYWdEcm9wTW9uaXRvci5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheScpO1xuXG52YXIgX2lzQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheSk7XG5cbnZhciBfYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKTtcblxudmFyIF9hc2FwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzYXApO1xuXG52YXIgX3JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9hY3Rpb25zL3JlZ2lzdHJ5Jyk7XG5cbnZhciBfZ2V0TmV4dFVuaXF1ZUlkID0gcmVxdWlyZSgnLi91dGlscy9nZXROZXh0VW5pcXVlSWQnKTtcblxudmFyIF9nZXROZXh0VW5pcXVlSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0TmV4dFVuaXF1ZUlkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhhbmRsZXJSb2xlcyA9IHtcbiAgU09VUkNFOiAnU09VUkNFJyxcbiAgVEFSR0VUOiAnVEFSR0VUJ1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVTb3VyY2VDb250cmFjdChzb3VyY2UpIHtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBzb3VyY2UuY2FuRHJhZyA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGNhbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBzb3VyY2UuYmVnaW5EcmFnID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgYmVnaW5EcmFnIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2Ygc291cmNlLmVuZERyYWcgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBlbmREcmFnIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0Q29udHJhY3QodGFyZ2V0KSB7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2YgdGFyZ2V0LmNhbkRyb3AgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBjYW5Ecm9wIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2YgdGFyZ2V0LmhvdmVyID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgaG92ZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiB0YXJnZXQuZHJvcCA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGJlZ2luRHJhZyB0byBiZSBhIGZ1bmN0aW9uLicpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSwgYWxsb3dBcnJheSkge1xuICBpZiAoYWxsb3dBcnJheSAmJiAoMCwgX2lzQXJyYXkyLmRlZmF1bHQpKHR5cGUpKSB7XG4gICAgdHlwZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVUeXBlKHQsIGZhbHNlKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZSkpID09PSAnc3ltYm9sJywgYWxsb3dBcnJheSA/ICdUeXBlIGNhbiBvbmx5IGJlIGEgc3RyaW5nLCBhIHN5bWJvbCwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLicgOiAnVHlwZSBjYW4gb25seSBiZSBhIHN0cmluZyBvciBhIHN5bWJvbC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dEhhbmRsZXJJZChyb2xlKSB7XG4gIHZhciBpZCA9ICgwLCBfZ2V0TmV4dFVuaXF1ZUlkMi5kZWZhdWx0KSgpLnRvU3RyaW5nKCk7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgSGFuZGxlclJvbGVzLlNPVVJDRTpcbiAgICAgIHJldHVybiAnUycgKyBpZDtcbiAgICBjYXNlIEhhbmRsZXJSb2xlcy5UQVJHRVQ6XG4gICAgICByZXR1cm4gJ1QnICsgaWQ7XG4gICAgZGVmYXVsdDpcbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1Vua25vd24gcm9sZTogJyArIHJvbGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUm9sZUZyb21IYW5kbGVySWQoaGFuZGxlcklkKSB7XG4gIHN3aXRjaCAoaGFuZGxlcklkWzBdKSB7XG4gICAgY2FzZSAnUyc6XG4gICAgICByZXR1cm4gSGFuZGxlclJvbGVzLlNPVVJDRTtcbiAgICBjYXNlICdUJzpcbiAgICAgIHJldHVybiBIYW5kbGVyUm9sZXMuVEFSR0VUO1xuICAgIGRlZmF1bHQ6XG4gICAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdDYW5ub3QgcGFyc2UgaGFuZGxlciBJRDogJyArIGhhbmRsZXJJZCk7XG4gIH1cbn1cblxudmFyIEhhbmRsZXJSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFuZGxlclJlZ2lzdHJ5KHN0b3JlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZXJSZWdpc3RyeSk7XG5cbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG5cbiAgICB0aGlzLnR5cGVzID0ge307XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuXG4gICAgdGhpcy5waW5uZWRTb3VyY2VJZCA9IG51bGw7XG4gICAgdGhpcy5waW5uZWRTb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhhbmRsZXJSZWdpc3RyeSwgW3tcbiAgICBrZXk6ICdhZGRTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTb3VyY2UodHlwZSwgc291cmNlKSB7XG4gICAgICB2YWxpZGF0ZVR5cGUodHlwZSk7XG4gICAgICB2YWxpZGF0ZVNvdXJjZUNvbnRyYWN0KHNvdXJjZSk7XG5cbiAgICAgIHZhciBzb3VyY2VJZCA9IHRoaXMuYWRkSGFuZGxlcihIYW5kbGVyUm9sZXMuU09VUkNFLCB0eXBlLCBzb3VyY2UpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCwgX3JlZ2lzdHJ5LmFkZFNvdXJjZSkoc291cmNlSWQpKTtcbiAgICAgIHJldHVybiBzb3VyY2VJZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRUYXJnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUYXJnZXQodHlwZSwgdGFyZ2V0KSB7XG4gICAgICB2YWxpZGF0ZVR5cGUodHlwZSwgdHJ1ZSk7XG4gICAgICB2YWxpZGF0ZVRhcmdldENvbnRyYWN0KHRhcmdldCk7XG5cbiAgICAgIHZhciB0YXJnZXRJZCA9IHRoaXMuYWRkSGFuZGxlcihIYW5kbGVyUm9sZXMuVEFSR0VULCB0eXBlLCB0YXJnZXQpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCwgX3JlZ2lzdHJ5LmFkZFRhcmdldCkodGFyZ2V0SWQpKTtcbiAgICAgIHJldHVybiB0YXJnZXRJZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcihyb2xlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgaWQgPSBnZXROZXh0SGFuZGxlcklkKHJvbGUpO1xuICAgICAgdGhpcy50eXBlc1tpZF0gPSB0eXBlO1xuICAgICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBoYW5kbGVyO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29udGFpbnNIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZXJzW2tleV0gPT09IGhhbmRsZXI7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3VyY2Uoc291cmNlSWQsIGluY2x1ZGVQaW5uZWQpIHtcbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0aGlzLmlzU291cmNlSWQoc291cmNlSWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCBzb3VyY2UgSUQuJyk7XG5cbiAgICAgIHZhciBpc1Bpbm5lZCA9IGluY2x1ZGVQaW5uZWQgJiYgc291cmNlSWQgPT09IHRoaXMucGlubmVkU291cmNlSWQ7XG4gICAgICB2YXIgc291cmNlID0gaXNQaW5uZWQgPyB0aGlzLnBpbm5lZFNvdXJjZSA6IHRoaXMuaGFuZGxlcnNbc291cmNlSWRdO1xuXG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRhcmdldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuaXNUYXJnZXRJZCh0YXJnZXRJZCksICdFeHBlY3RlZCBhIHZhbGlkIHRhcmdldCBJRC4nKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzW3RhcmdldElkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTb3VyY2VUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U291cmNlVHlwZShzb3VyY2VJZCkge1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuaXNTb3VyY2VJZChzb3VyY2VJZCksICdFeHBlY3RlZCBhIHZhbGlkIHNvdXJjZSBJRC4nKTtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVzW3NvdXJjZUlkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUYXJnZXRUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCkge1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuaXNUYXJnZXRJZCh0YXJnZXRJZCksICdFeHBlY3RlZCBhIHZhbGlkIHRhcmdldCBJRC4nKTtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVzW3RhcmdldElkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc1NvdXJjZUlkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTb3VyY2VJZChoYW5kbGVySWQpIHtcbiAgICAgIHZhciByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgcmV0dXJuIHJvbGUgPT09IEhhbmRsZXJSb2xlcy5TT1VSQ0U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNUYXJnZXRJZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGFyZ2V0SWQoaGFuZGxlcklkKSB7XG4gICAgICB2YXIgcm9sZSA9IHBhcnNlUm9sZUZyb21IYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgIHJldHVybiByb2xlID09PSBIYW5kbGVyUm9sZXMuVEFSR0VUO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVNvdXJjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0aGlzLmdldFNvdXJjZShzb3VyY2VJZCksICdFeHBlY3RlZCBhbiBleGlzdGluZyBzb3VyY2UuJyk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLCBfcmVnaXN0cnkucmVtb3ZlU291cmNlKShzb3VyY2VJZCkpO1xuXG4gICAgICAoMCwgX2FzYXAyLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5oYW5kbGVyc1tzb3VyY2VJZF07XG4gICAgICAgIGRlbGV0ZSBfdGhpczIudHlwZXNbc291cmNlSWRdO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlVGFyZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMuZ2V0VGFyZ2V0KHRhcmdldElkKSwgJ0V4cGVjdGVkIGFuIGV4aXN0aW5nIHRhcmdldC4nKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAsIF9yZWdpc3RyeS5yZW1vdmVUYXJnZXQpKHRhcmdldElkKSk7XG5cbiAgICAgICgwLCBfYXNhcDIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgX3RoaXMzLmhhbmRsZXJzW3RhcmdldElkXTtcbiAgICAgICAgZGVsZXRlIF90aGlzMy50eXBlc1t0YXJnZXRJZF07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwaW5Tb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaW5Tb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoc291cmNlLCAnRXhwZWN0ZWQgYW4gZXhpc3Rpbmcgc291cmNlLicpO1xuXG4gICAgICB0aGlzLnBpbm5lZFNvdXJjZUlkID0gc291cmNlSWQ7XG4gICAgICB0aGlzLnBpbm5lZFNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bnBpblNvdXJjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGluU291cmNlKCkge1xuICAgICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHRoaXMucGlubmVkU291cmNlLCAnTm8gc291cmNlIGlzIHBpbm5lZCBhdCB0aGUgdGltZS4nKTtcblxuICAgICAgdGhpcy5waW5uZWRTb3VyY2VJZCA9IG51bGw7XG4gICAgICB0aGlzLnBpbm5lZFNvdXJjZSA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhhbmRsZXJSZWdpc3RyeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGFuZGxlclJlZ2lzdHJ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9IYW5kbGVyUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0hhbmRsZXJSZWdpc3RyeS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IHJlcXVpcmUoXCIuL3Jhd1wiKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgSU8sIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVkcmF3XG4vLyBldmVudHMgaW4gYnJvd3NlcnMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG1ldGhvZCB0aGF0IGF0dGVtcHRzIHRvIGtpY2tcbi8vIG9mZiBhIGBmbHVzaGAgZXZlbnQgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS4gYGZsdXNoYCB3aWxsIGF0dGVtcHQgdG8gZXhoYXVzdFxuLy8gdGhlIGV2ZW50IHF1ZXVlIGJlZm9yZSB5aWVsZGluZyB0byB0aGUgYnJvd3NlcidzIG93biBldmVudCBsb29wLlxudmFyIHJlcXVlc3RGbHVzaDtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuLy8gZXZlcnkgYXZhaWxhYmxlIFNhdWNlTGFicyBTZWxlbml1bSB3ZWIgZHJpdmVyIHdvcmtlciBhdCB0aW1lIG9mIHdyaXRpbmcuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xbUctNVVZR3VwNXF4R2RFTVdraFA2QldDejA1M05VYjJFMVFvVVRVMTZ1QS9lZGl0I2dpZD03ODM3MjQ1OTNcblxuLy8gU2FmYXJpIDYgYW5kIDYuMSBmb3IgZGVza3RvcCwgaVBhZCwgYW5kIGlQaG9uZSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdFxuLy8gaGF2ZSBXZWJLaXRNdXRhdGlvbk9ic2VydmVyIGJ1dCBub3QgdW4tcHJlZml4ZWQgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11c3QgdXNlIGBnbG9iYWxgIG9yIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIHRvIHdvcmsgaW4gYm90aCBmcmFtZXMgYW5kIHdlYlxuLy8gd29ya2Vycy4gYGdsb2JhbGAgaXMgYSBwcm92aXNpb24gb2YgQnJvd3NlcmlmeSwgTXIsIE1ycywgb3IgTW9wLlxuXG4vKiBnbG9iYWxzIHNlbGYgKi9cbnZhciBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBzZWxmO1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG4vLyBNdXRhdGlvbk9ic2VydmVycyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBoYXZlIGhpZ2ggcHJpb3JpdHkgYW5kIHdvcmtcbi8vIHJlbGlhYmx5IGV2ZXJ5d2hlcmUgdGhleSBhcmUgaW1wbGVtZW50ZWQuXG4vLyBUaGV5IGFyZSBpbXBsZW1lbnRlZCBpbiBhbGwgbW9kZXJuIGJyb3dzZXJzLlxuLy9cbi8vIC0gQW5kcm9pZCA0LTQuM1xuLy8gLSBDaHJvbWUgMjYtMzRcbi8vIC0gRmlyZWZveCAxNC0yOVxuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciAxMVxuLy8gLSBpUGFkIFNhZmFyaSA2LTcuMVxuLy8gLSBpUGhvbmUgU2FmYXJpIDctNy4xXG4vLyAtIFNhZmFyaSA2LTdcbmlmICh0eXBlb2YgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcblxuLy8gTWVzc2FnZUNoYW5uZWxzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGdpdmUgZGlyZWN0IGFjY2VzcyB0byB0aGUgSFRNTFxuLy8gdGFzayBxdWV1ZSwgYXJlIGltcGxlbWVudGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLCBTYWZhcmkgNS4wLTEsIGFuZCBPcGVyYVxuLy8gMTEtMTIsIGFuZCBpbiB3ZWIgd29ya2VycyBpbiBtYW55IGVuZ2luZXMuXG4vLyBBbHRob3VnaCBtZXNzYWdlIGNoYW5uZWxzIHlpZWxkIHRvIGFueSBxdWV1ZWQgcmVuZGVyaW5nIGFuZCBJTyB0YXNrcywgdGhleVxuLy8gd291bGQgYmUgYmV0dGVyIHRoYW4gaW1wb3NpbmcgdGhlIDRtcyBkZWxheSBvZiB0aW1lcnMuXG4vLyBIb3dldmVyLCB0aGV5IGRvIG5vdCB3b3JrIHJlbGlhYmx5IGluIEludGVybmV0IEV4cGxvcmVyIG9yIFNhZmFyaS5cblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG5cbi8vIFRpbWVycyBhcmUgaW1wbGVtZW50ZWQgdW5pdmVyc2FsbHkuXG4vLyBXZSBmYWxsIGJhY2sgdG8gdGltZXJzIGluIHdvcmtlcnMgaW4gbW9zdCBlbmdpbmVzLCBhbmQgaW4gZm9yZWdyb3VuZFxuLy8gY29udGV4dHMgaW4gdGhlIGZvbGxvd2luZyBicm93c2Vycy5cbi8vIEhvd2V2ZXIsIG5vdGUgdGhhdCBldmVuIHRoaXMgc2ltcGxlIGNhc2UgcmVxdWlyZXMgbnVhbmNlcyB0byBvcGVyYXRlIGluIGFcbi8vIGJyb2FkIHNwZWN0cnVtIG9mIGJyb3dzZXJzLlxuLy9cbi8vIC0gRmlyZWZveCAzLTEzXG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDYtOVxuLy8gLSBpUGFkIFNhZmFyaSA0LjNcbi8vIC0gTHlueCAyLjguN1xufSBlbHNlIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoZmx1c2gpO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCByZXF1ZXN0cyB0aGF0IHRoZSBoaWdoIHByaW9yaXR5IGV2ZW50IHF1ZXVlIGJlIGZsdXNoZWQgYXNcbi8vIHNvb24gYXMgcG9zc2libGUuXG4vLyBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFuIGVycm9yIHRocm93biBpbiBhIHRhc2sgZnJvbSBzdGFsbGluZyB0aGUgZXZlbnRcbi8vIHF1ZXVlIGlmIHRoZSBleGNlcHRpb24gaGFuZGxlZCBieSBOb2RlLmpz4oCZc1xuLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcblxuLy8gVG8gcmVxdWVzdCBhIGhpZ2ggcHJpb3JpdHkgZXZlbnQsIHdlIGluZHVjZSBhIG11dGF0aW9uIG9ic2VydmVyIGJ5IHRvZ2dsaW5nXG4vLyB0aGUgdGV4dCBvZiBhIHRleHQgbm9kZSBiZXR3ZWVuIFwiMVwiIGFuZCBcIi0xXCIuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICB0b2dnbGUgPSAtdG9nZ2xlO1xuICAgICAgICBub2RlLmRhdGEgPSB0b2dnbGU7XG4gICAgfTtcbn1cblxuLy8gVGhlIG1lc3NhZ2UgY2hhbm5lbCB0ZWNobmlxdWUgd2FzIGRpc2NvdmVyZWQgYnkgTWFsdGUgVWJsIGFuZCB3YXMgdGhlXG4vLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4vLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuXG4vLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4vLyBwYWdlJ3MgZmlyc3QgbG9hZC4gVGhhbmtmdWxseSwgdGhpcyB2ZXJzaW9uIG9mIFNhZmFyaSBzdXBwb3J0c1xuLy8gTXV0YXRpb25PYnNlcnZlcnMsIHNvIHdlIGRvbid0IG5lZWQgdG8gZmFsbCBiYWNrIGluIHRoYXQgY2FzZS5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU1lc3NhZ2VDaGFubmVsKGNhbGxiYWNrKSB7XG4vLyAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbi8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbi8vIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuLy8gRXZlbiBpZiB3ZSB3ZXJlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbi8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4vLyBgc2V0SW1tZWRpYXRlYCBtdXN0IGJlIGNhbGxlZCAqYnkgbmFtZSogYW5kIHRoZXJlZm9yZSBtdXN0IGJlIHdyYXBwZWQgaW4gYVxuLy8gY2xvc3VyZS5cbi8vIE5ldmVyIGZvcmdldC5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBTYWZhcmkgNi4wIGhhcyBhIHByb2JsZW0gd2hlcmUgdGltZXJzIHdpbGwgZ2V0IGxvc3Qgd2hpbGUgdGhlIHVzZXIgaXNcbi8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuLy8gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB0aGF0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQgaW5zdGVhZC5cbi8vIEhvd2V2ZXIsIGlmIHdlIGV2ZXIgZWxlY3QgdG8gdXNlIHRpbWVycyBpbiBTYWZhcmksIHRoZSBwcmV2YWxlbnQgd29yay1hcm91bmRcbi8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuXG4vLyBgc2V0VGltZW91dGAgZG9lcyBub3QgY2FsbCB0aGUgcGFzc2VkIGNhbGxiYWNrIGlmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW5cbi8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3Rcbi8vIGV2ZW4gdGhlbi5cblxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChoYW5kbGVUaW1lciwgMCk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoaXMgdGltZXIgZ2V0cyBmcmVxdWVudGx5IGRyb3BwZWQgaW4gRmlyZWZveFxuICAgICAgICAvLyB3b3JrZXJzLCB3ZSBlbmxpc3QgYW4gaW50ZXJ2YWwgaGFuZGxlIHRoYXQgd2lsbCB0cnkgdG8gZmlyZVxuICAgICAgICAvLyBhbiBldmVudCAyMCB0aW1lcyBwZXIgc2Vjb25kIHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChoYW5kbGVUaW1lciwgNTApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVyKCkge1xuICAgICAgICAgICAgLy8gV2hpY2hldmVyIHRpbWVyIHN1Y2NlZWRzIHdpbGwgY2FuY2VsIGJvdGggdGltZXJzIGFuZFxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIGZvciBgYXNhcC5qc2Agb25seS5cbi8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdCBkZXBlbmRzIG9uXG4vLyBpdHMgZXhpc3RlbmNlLlxucmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIgPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXI7XG5cbi8vIEFTQVAgd2FzIG9yaWdpbmFsbHkgYSBuZXh0VGljayBzaGltIGluY2x1ZGVkIGluIFEuIFRoaXMgd2FzIGZhY3RvcmVkIG91dFxuLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbi8vIGFtZW5kbWVudHMuIFRoZXNlIGRlY2lzaW9ucywgcGFydGljdWxhcmx5IHRvIG1hcmdpbmFsaXplIE1lc3NhZ2VDaGFubmVsIGFuZFxuLy8gdG8gY2FwdHVyZSB0aGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiBpbiBhIGNsb3N1cmUsIHdlcmUgaW50ZWdyYXRlZFxuLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL2NkZGY3MjMyNTQ2YTljZjg1ODUyNGI3NWNkZTZmOWVkZjcyNjIwYTcvbGliL3JzdnAvYXNhcC5qc1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNhcC9icm93c2VyLXJhdy5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXROZXh0VW5pcXVlSWQ7XG52YXIgbmV4dFVuaXF1ZUlkID0gMDtcblxuZnVuY3Rpb24gZ2V0TmV4dFVuaXF1ZUlkKCkge1xuICByZXR1cm4gbmV4dFVuaXF1ZUlkKys7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL3V0aWxzL2dldE5leHRVbmlxdWVJZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvdXRpbHMvZ2V0TmV4dFVuaXF1ZUlkLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEcmFnU291cmNlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEcmFnU291cmNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFnU291cmNlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcmFnU291cmNlLCBbe1xuICAgIGtleTogXCJjYW5EcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYWcoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEcmFnZ2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RyYWdnaW5nKG1vbml0b3IsIGhhbmRsZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZSA9PT0gbW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmREcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZERyYWcoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIERyYWdTb3VyY2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdTb3VyY2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0RyYWdTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL0RyYWdTb3VyY2UuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERyb3BUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3BUYXJnZXQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3BUYXJnZXQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3BUYXJnZXQsIFt7XG4gICAga2V5OiBcImNhbkRyb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRHJvcCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJob3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBob3ZlcigpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wVGFyZ2V0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcm9wVGFyZ2V0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9Ecm9wVGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2RuZC1jb3JlL2xpYi9Ecm9wVGFyZ2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCYWNrZW5kO1xuXG52YXIgX25vb3AgPSByZXF1aXJlKCdsb2Rhc2gvbm9vcCcpO1xuXG52YXIgX25vb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9vcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUZXN0QmFja2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVzdEJhY2tlbmQobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXN0QmFja2VuZCk7XG5cbiAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXN0QmFja2VuZCwgW3tcbiAgICBrZXk6ICdzZXR1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgdGhpcy5kaWRDYWxsU2V0dXAgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RlYXJkb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICB0aGlzLmRpZENhbGxUZWFyZG93biA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29ubmVjdERyYWdTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0RHJhZ1NvdXJjZSgpIHtcbiAgICAgIHJldHVybiBfbm9vcDIuZGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb25uZWN0RHJhZ1ByZXZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0RHJhZ1ByZXZpZXcoKSB7XG4gICAgICByZXR1cm4gX25vb3AyLmRlZmF1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29ubmVjdERyb3BUYXJnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0RHJvcFRhcmdldCgpIHtcbiAgICAgIHJldHVybiBfbm9vcDIuZGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaW11bGF0ZUJlZ2luRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbXVsYXRlQmVnaW5EcmFnKHNvdXJjZUlkcywgb3B0aW9ucykge1xuICAgICAgdGhpcy5hY3Rpb25zLmJlZ2luRHJhZyhzb3VyY2VJZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NpbXVsYXRlUHVibGlzaERyYWdTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW11bGF0ZVB1Ymxpc2hEcmFnU291cmNlKCkge1xuICAgICAgdGhpcy5hY3Rpb25zLnB1Ymxpc2hEcmFnU291cmNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2ltdWxhdGVIb3ZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbXVsYXRlSG92ZXIodGFyZ2V0SWRzLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmFjdGlvbnMuaG92ZXIodGFyZ2V0SWRzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaW11bGF0ZURyb3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW11bGF0ZURyb3AoKSB7XG4gICAgICB0aGlzLmFjdGlvbnMuZHJvcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NpbXVsYXRlRW5kRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbXVsYXRlRW5kRHJhZygpIHtcbiAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRlc3RCYWNrZW5kO1xufSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIpIHtcbiAgcmV0dXJuIG5ldyBUZXN0QmFja2VuZChtYW5hZ2VyKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kbmQtY29yZS9saWIvYmFja2VuZHMvY3JlYXRlVGVzdEJhY2tlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZG5kLWNvcmUvbGliL2JhY2tlbmRzL2NyZWF0ZVRlc3RCYWNrZW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NsYXNzLCBfdGVtcDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX0RyYWdEcm9wQ29udGV4dCA9IHJlcXVpcmUoJy4vRHJhZ0Ryb3BDb250ZXh0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGEgUmVhY3QtQ29tcG9uZW50IGJhc2VkIHZlcnNpb24gb2YgdGhlIERyYWdEcm9wQ29udGV4dC5cbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gZGVjb3JhdGluZyBhbiBhcHBsaWNhdGlvbiBjb21wb25lbnQgd2l0aCBhbiBFUzcgZGVjb3JhdG9yLlxuICovXG52YXIgRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXIgPSAoX3RlbXAgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdEcm9wQ29udGV4dFByb3ZpZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcmFnRHJvcENvbnRleHRQcm92aWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyYWdEcm9wQ29udGV4dFByb3ZpZGVyKSkuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgX3RoaXMuYmFja2VuZCA9ICgwLCBfRHJhZ0Ryb3BDb250ZXh0LnVucGFja0JhY2tlbmRGb3JFczVVc2VycykocHJvcHMuYmFja2VuZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyYWdEcm9wQ29udGV4dFByb3ZpZGVyLCBbe1xuICAgIGtleTogJ2dldENoaWxkQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgcHJvcGVydHkgZGV0ZXJtaW5lcyB3aGljaCB3aW5kb3cgZ2xvYmFsIHRvIHVzZSBmb3IgY3JlYXRpbmcgdGhlIERyYWdEcm9wTWFuYWdlci5cbiAgICAgICAqIElmIGEgd2luZG93IGhhcyBiZWVuIGluamVjdGVkIGV4cGxpY2l0bHkgdmlhIHByb3BzLCB0aGF0IGlzIHVzZWQgZmlyc3QuIElmIGl0IGlzIGF2YWlsYWJsZVxuICAgICAgICogYXMgYSBjb250ZXh0IHZhbHVlLCB0aGVuIHVzZSB0aGF0LCBvdGhlcndpc2UgdXNlIHRoZSBicm93c2VyIGdsb2JhbC5cbiAgICAgICAqL1xuICAgICAgdmFyIGdldFdpbmRvdyA9IGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICAgICAgaWYgKF90aGlzMi5wcm9wcyAmJiBfdGhpczIucHJvcHMud2luZG93KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy53aW5kb3c7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLmNvbnRleHQgJiYgX3RoaXMyLmNvbnRleHQud2luZG93KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5jb250ZXh0LndpbmRvdztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAoMCwgX0RyYWdEcm9wQ29udGV4dC5jcmVhdGVDaGlsZENvbnRleHQpKHRoaXMuYmFja2VuZCwgeyB3aW5kb3c6IGdldFdpbmRvdygpIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBfcmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXI7XG59KF9yZWFjdC5Db21wb25lbnQpLCBfY2xhc3MucHJvcFR5cGVzID0ge1xuICBiYWNrZW5kOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdF0pLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmVsZW1lbnQuaXNSZXF1aXJlZCxcbiAgd2luZG93OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCB9LCBfY2xhc3MuZGVmYXVsdFByb3BzID0ge1xuICB3aW5kb3c6IHVuZGVmaW5lZFxufSwgX2NsYXNzLmNoaWxkQ29udGV4dFR5cGVzID0gX0RyYWdEcm9wQ29udGV4dC5DSElMRF9DT05URVhUX1RZUEVTLCBfY2xhc3MuZGlzcGxheU5hbWUgPSAnRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXInLCBfY2xhc3MuY29udGV4dFR5cGVzID0ge1xuICB3aW5kb3c6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG59LCBfdGVtcCk7XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnRHJvcENvbnRleHRQcm92aWRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdEcm9wQ29udGV4dFByb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnU291cmNlO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzJyk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMpO1xuXG52YXIgX2RlY29yYXRlSGFuZGxlciA9IHJlcXVpcmUoJy4vZGVjb3JhdGVIYW5kbGVyJyk7XG5cbnZhciBfZGVjb3JhdGVIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY29yYXRlSGFuZGxlcik7XG5cbnZhciBfcmVnaXN0ZXJTb3VyY2UgPSByZXF1aXJlKCcuL3JlZ2lzdGVyU291cmNlJyk7XG5cbnZhciBfcmVnaXN0ZXJTb3VyY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnaXN0ZXJTb3VyY2UpO1xuXG52YXIgX2NyZWF0ZVNvdXJjZUZhY3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVNvdXJjZUZhY3RvcnknKTtcblxudmFyIF9jcmVhdGVTb3VyY2VGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVNvdXJjZUZhY3RvcnkpO1xuXG52YXIgX2NyZWF0ZVNvdXJjZU1vbml0b3IgPSByZXF1aXJlKCcuL2NyZWF0ZVNvdXJjZU1vbml0b3InKTtcblxudmFyIF9jcmVhdGVTb3VyY2VNb25pdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVNvdXJjZU1vbml0b3IpO1xuXG52YXIgX2NyZWF0ZVNvdXJjZUNvbm5lY3RvciA9IHJlcXVpcmUoJy4vY3JlYXRlU291cmNlQ29ubmVjdG9yJyk7XG5cbnZhciBfY3JlYXRlU291cmNlQ29ubmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVNvdXJjZUNvbm5lY3Rvcik7XG5cbnZhciBfaXNWYWxpZFR5cGUgPSByZXF1aXJlKCcuL3V0aWxzL2lzVmFsaWRUeXBlJyk7XG5cbnZhciBfaXNWYWxpZFR5cGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNWYWxpZFR5cGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBEcmFnU291cmNlKHR5cGUsIHNwZWMsIGNvbGxlY3QpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIF9jaGVja0RlY29yYXRvckFyZ3VtZW50czIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFsnRHJhZ1NvdXJjZScsICd0eXBlLCBzcGVjLCBjb2xsZWN0Wywgb3B0aW9uc10nXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICB2YXIgZ2V0VHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzVmFsaWRUeXBlMi5kZWZhdWx0KSh0eXBlKSwgJ0V4cGVjdGVkIFwidHlwZVwiIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBEcmFnU291cmNlIHRvIGJlICcgKyAnYSBzdHJpbmcsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIGdpdmVuIHRoZSBjdXJyZW50IHByb3BzLiAnICsgJ0luc3RlYWQsIHJlY2VpdmVkICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIHR5cGUpO1xuICAgIGdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfTtcbiAgfVxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoKDAsIF9pc1BsYWluT2JqZWN0Mi5kZWZhdWx0KShzcGVjKSwgJ0V4cGVjdGVkIFwic3BlY1wiIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gRHJhZ1NvdXJjZSB0byBiZSAnICsgJ2EgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctc291cmNlLmh0bWwnLCBzcGVjKTtcbiAgdmFyIGNyZWF0ZVNvdXJjZSA9ICgwLCBfY3JlYXRlU291cmNlRmFjdG9yeTIuZGVmYXVsdCkoc3BlYyk7XG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2YgY29sbGVjdCA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIFwiY29sbGVjdFwiIHByb3ZpZGVkIGFzIHRoZSB0aGlyZCBhcmd1bWVudCB0byBEcmFnU291cmNlIHRvIGJlICcgKyAnYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwbGFpbiBvYmplY3Qgb2YgcHJvcHMgdG8gaW5qZWN0LiAnICsgJ0luc3RlYWQsIHJlY2VpdmVkICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGNvbGxlY3QpO1xuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoKDAsIF9pc1BsYWluT2JqZWN0Mi5kZWZhdWx0KShvcHRpb25zKSwgJ0V4cGVjdGVkIFwib3B0aW9uc1wiIHByb3ZpZGVkIGFzIHRoZSBmb3VydGggYXJndW1lbnQgdG8gRHJhZ1NvdXJjZSB0byBiZSAnICsgJ2EgcGxhaW4gb2JqZWN0IHdoZW4gc3BlY2lmaWVkLiAnICsgJ0luc3RlYWQsIHJlY2VpdmVkICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGNvbGxlY3QpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0ZVNvdXJjZShEZWNvcmF0ZWRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gKDAsIF9kZWNvcmF0ZUhhbmRsZXIyLmRlZmF1bHQpKHtcbiAgICAgIGNvbm5lY3RCYWNrZW5kOiBmdW5jdGlvbiBjb25uZWN0QmFja2VuZChiYWNrZW5kLCBzb3VyY2VJZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jb25uZWN0RHJhZ1NvdXJjZShzb3VyY2VJZCk7XG4gICAgICB9LFxuICAgICAgY29udGFpbmVyRGlzcGxheU5hbWU6ICdEcmFnU291cmNlJyxcbiAgICAgIGNyZWF0ZUhhbmRsZXI6IGNyZWF0ZVNvdXJjZSxcbiAgICAgIHJlZ2lzdGVySGFuZGxlcjogX3JlZ2lzdGVyU291cmNlMi5kZWZhdWx0LFxuICAgICAgY3JlYXRlTW9uaXRvcjogX2NyZWF0ZVNvdXJjZU1vbml0b3IyLmRlZmF1bHQsXG4gICAgICBjcmVhdGVDb25uZWN0b3I6IF9jcmVhdGVTb3VyY2VDb25uZWN0b3IyLmRlZmF1bHQsXG4gICAgICBEZWNvcmF0ZWRDb21wb25lbnQ6IERlY29yYXRlZENvbXBvbmVudCxcbiAgICAgIGdldFR5cGU6IGdldFR5cGUsXG4gICAgICBjb2xsZWN0OiBjb2xsZWN0LFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvRHJhZ1NvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdTb3VyY2UuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0Rpc3Bvc2FibGUyID0gcmVxdWlyZSgnLi9pc0Rpc3Bvc2FibGUnKTtcblxudmFyIF9pc0Rpc3Bvc2FibGUzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2lzRGlzcG9zYWJsZTIpO1xuXG5leHBvcnRzLmlzRGlzcG9zYWJsZSA9IF9pc0Rpc3Bvc2FibGUzWydkZWZhdWx0J107XG5cbnZhciBfRGlzcG9zYWJsZTIgPSByZXF1aXJlKCcuL0Rpc3Bvc2FibGUnKTtcblxudmFyIF9EaXNwb3NhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9EaXNwb3NhYmxlMik7XG5cbmV4cG9ydHMuRGlzcG9zYWJsZSA9IF9EaXNwb3NhYmxlM1snZGVmYXVsdCddO1xuXG52YXIgX0NvbXBvc2l0ZURpc3Bvc2FibGUyID0gcmVxdWlyZSgnLi9Db21wb3NpdGVEaXNwb3NhYmxlJyk7XG5cbnZhciBfQ29tcG9zaXRlRGlzcG9zYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfQ29tcG9zaXRlRGlzcG9zYWJsZTIpO1xuXG5leHBvcnRzLkNvbXBvc2l0ZURpc3Bvc2FibGUgPSBfQ29tcG9zaXRlRGlzcG9zYWJsZTNbJ2RlZmF1bHQnXTtcblxudmFyIF9TZXJpYWxEaXNwb3NhYmxlMiA9IHJlcXVpcmUoJy4vU2VyaWFsRGlzcG9zYWJsZScpO1xuXG52YXIgX1NlcmlhbERpc3Bvc2FibGUzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1NlcmlhbERpc3Bvc2FibGUyKTtcblxuZXhwb3J0cy5TZXJpYWxEaXNwb3NhYmxlID0gX1NlcmlhbERpc3Bvc2FibGUzWydkZWZhdWx0J107XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kaXNwb3NhYmxlcy9tb2R1bGVzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIGJhc2ljIGRpc3Bvc2FibGUuXG4gKi9cblxudmFyIERpc3Bvc2FibGUgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXNwb3NhYmxlKGFjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uIHx8IG5vb3A7XG4gIH1cblxuICBEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5hY3Rpb24uY2FsbChudWxsKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBudWxsLCBbe1xuICAgIGtleTogXCJlbXB0eVwiLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHsgZGlzcG9zZTogbm9vcCB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlzcG9zYWJsZTtcbn0pKCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGlzcG9zYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9EaXNwb3NhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Rpc3Bvc2FibGVzL21vZHVsZXMvRGlzcG9zYWJsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9O1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vaXNEaXNwb3NhYmxlJyk7XG5cbnZhciBfaXNEaXNwb3NhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pc0Rpc3Bvc2FibGUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBncm91cCBvZiBkaXNwb3NhYmxlIHJlc291cmNlcyB0aGF0IGFyZSBkaXNwb3NlZCB0b2dldGhlci5cbiAqL1xuXG52YXIgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbXBvc2l0ZURpc3Bvc2FibGUoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRpc3Bvc2FibGVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkaXNwb3NhYmxlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9zaXRlRGlzcG9zYWJsZSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlc1swXSkgJiYgZGlzcG9zYWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBkaXNwb3NhYmxlcyA9IGRpc3Bvc2FibGVzWzBdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghX2lzRGlzcG9zYWJsZTJbJ2RlZmF1bHQnXShkaXNwb3NhYmxlc1tpXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGRpc3Bvc2FibGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3Bvc2FibGVzID0gZGlzcG9zYWJsZXM7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGRpc3Bvc2FibGUgdG8gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgb3IgZGlzcG9zZXMgdGhlIGRpc3Bvc2FibGUgaWYgdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgaXMgZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gaXRlbSBEaXNwb3NhYmxlIHRvIGFkZC5cbiAgICovXG5cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGl0ZW0pIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbmQgZGlzcG9zZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBkaXNwb3NhYmxlIGZyb20gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUuXG4gICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gaXRlbSBEaXNwb3NhYmxlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgZm91bmQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGl0ZW0pIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5kaXNwb3NhYmxlcy5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3Bvc2FibGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGFsbCBkaXNwb3NhYmxlcyBpbiB0aGUgZ3JvdXAgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBncm91cC5cbiAgICovXG5cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSB0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aDtcbiAgICB2YXIgY3VycmVudERpc3Bvc2FibGVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudERpc3Bvc2FibGVzW2ldID0gdGhpcy5kaXNwb3NhYmxlc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjdXJyZW50RGlzcG9zYWJsZXNbaV0uZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29tcG9zaXRlRGlzcG9zYWJsZTtcbn0pKCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbXBvc2l0ZURpc3Bvc2FibGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kaXNwb3NhYmxlcy9tb2R1bGVzL0NvbXBvc2l0ZURpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvZGlzcG9zYWJsZXMvbW9kdWxlcy9Db21wb3NpdGVEaXNwb3NhYmxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH07XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNEaXNwb3NhYmxlID0gcmVxdWlyZSgnLi9pc0Rpc3Bvc2FibGUnKTtcblxudmFyIF9pc0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2lzRGlzcG9zYWJsZSk7XG5cbnZhciBTZXJpYWxEaXNwb3NhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VyaWFsRGlzcG9zYWJsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VyaWFsRGlzcG9zYWJsZSk7XG5cbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZS5cbiAgICogQHJldHVybiBUaGUgdW5kZXJseWluZyBkaXNwb3NhYmxlLlxuICAgKi9cblxuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gZ2V0RGlzcG9zYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUuXG4gICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gdmFsdWUgVGhlIG5ldyB1bmRlcmx5aW5nIGRpc3Bvc2FibGUuXG4gICAqL1xuXG4gIFNlcmlhbERpc3Bvc2FibGUucHJvdG90eXBlLnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiBzZXREaXNwb3NhYmxlKCkge1xuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICFfaXNEaXNwb3NhYmxlMlsnZGVmYXVsdCddKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlaXRoZXIgYW4gZW1wdHkgdmFsdWUgb3IgYSB2YWxpZCBkaXNwb3NhYmxlJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRGlzcG9zZWQgPSB0aGlzLmlzRGlzcG9zZWQ7XG4gICAgdmFyIHByZXZpb3VzID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFpc0Rpc3Bvc2VkKSB7XG4gICAgICBwcmV2aW91cyA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgcHJldmlvdXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3Bvc2VkICYmIHZhbHVlKSB7XG4gICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlIGFzIHdlbGwgYXMgYWxsIGZ1dHVyZSByZXBsYWNlbWVudHMuXG4gICAqL1xuXG4gIFNlcmlhbERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHZhciBwcmV2aW91cyA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICBwcmV2aW91cy5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTZXJpYWxEaXNwb3NhYmxlO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2VyaWFsRGlzcG9zYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Rpc3Bvc2FibGVzL21vZHVsZXMvU2VyaWFsRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9kaXNwb3NhYmxlcy9tb2R1bGVzL1NlcmlhbERpc3Bvc2FibGUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlZ2lzdGVyU291cmNlO1xuZnVuY3Rpb24gcmVnaXN0ZXJTb3VyY2UodHlwZSwgc291cmNlLCBtYW5hZ2VyKSB7XG4gIHZhciByZWdpc3RyeSA9IG1hbmFnZXIuZ2V0UmVnaXN0cnkoKTtcbiAgdmFyIHNvdXJjZUlkID0gcmVnaXN0cnkuYWRkU291cmNlKHR5cGUsIHNvdXJjZSk7XG5cbiAgZnVuY3Rpb24gdW5yZWdpc3RlclNvdXJjZSgpIHtcbiAgICByZWdpc3RyeS5yZW1vdmVTb3VyY2Uoc291cmNlSWQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVySWQ6IHNvdXJjZUlkLFxuICAgIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJTb3VyY2VcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3JlZ2lzdGVyU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvcmVnaXN0ZXJTb3VyY2UuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVNvdXJjZUZhY3Rvcnk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEFMTE9XRURfU1BFQ19NRVRIT0RTID0gWydjYW5EcmFnJywgJ2JlZ2luRHJhZycsICdpc0RyYWdnaW5nJywgJ2VuZERyYWcnXTtcbnZhciBSRVFVSVJFRF9TUEVDX01FVEhPRFMgPSBbJ2JlZ2luRHJhZyddO1xuXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2VGYWN0b3J5KHNwZWMpIHtcbiAgT2JqZWN0LmtleXMoc3BlYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKEFMTE9XRURfU1BFQ19NRVRIT0RTLmluZGV4T2Yoa2V5KSA+IC0xLCAnRXhwZWN0ZWQgdGhlIGRyYWcgc291cmNlIHNwZWNpZmljYXRpb24gdG8gb25seSBoYXZlICcgKyAnc29tZSBvZiB0aGUgZm9sbG93aW5nIGtleXM6ICVzLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQgYSBzcGVjaWZpY2F0aW9uIHdpdGggYW4gdW5leHBlY3RlZCBcIiVzXCIga2V5LiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIEFMTE9XRURfU1BFQ19NRVRIT0RTLmpvaW4oJywgJyksIGtleSk7XG4gICAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBzcGVjW2tleV0gPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCAlcyBpbiB0aGUgZHJhZyBzb3VyY2Ugc3BlY2lmaWNhdGlvbiB0byBiZSBhIGZ1bmN0aW9uLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQgYSBzcGVjaWZpY2F0aW9uIHdpdGggJXM6ICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGtleSwga2V5LCBzcGVjW2tleV0pO1xuICB9KTtcbiAgUkVRVUlSRURfU1BFQ19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2Ygc3BlY1trZXldID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgJXMgaW4gdGhlIGRyYWcgc291cmNlIHNwZWNpZmljYXRpb24gdG8gYmUgYSBmdW5jdGlvbi4gJyArICdJbnN0ZWFkIHJlY2VpdmVkIGEgc3BlY2lmaWNhdGlvbiB3aXRoICVzOiAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctc291cmNlLmh0bWwnLCBrZXksIGtleSwgc3BlY1trZXldKTtcbiAgfSk7XG5cbiAgdmFyIFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb3VyY2UobW9uaXRvcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZSk7XG5cbiAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU291cmNlLCBbe1xuICAgICAga2V5OiAncmVjZWl2ZVByb3BzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlaXZlUHJvcHMocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlY2VpdmVDb21wb25lbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbkRyYWcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYWcoKSB7XG4gICAgICAgIGlmICghc3BlYy5jYW5EcmFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BlYy5jYW5EcmFnKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaXNEcmFnZ2luZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEcmFnZ2luZyhnbG9iYWxNb25pdG9yLCBzb3VyY2VJZCkge1xuICAgICAgICBpZiAoIXNwZWMuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHJldHVybiBzb3VyY2VJZCA9PT0gZ2xvYmFsTW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwZWMuaXNEcmFnZ2luZyh0aGlzLnByb3BzLCB0aGlzLm1vbml0b3IpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2JlZ2luRHJhZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW5EcmFnKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHNwZWMuYmVnaW5EcmFnKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvciwgdGhpcy5jb21wb25lbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzUGxhaW5PYmplY3QyLmRlZmF1bHQpKGl0ZW0pLCAnYmVnaW5EcmFnKCkgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBkcmFnZ2VkIGl0ZW0uICcgKyAnSW5zdGVhZCByZWNlaXZlZCAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctc291cmNlLmh0bWwnLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlbmREcmFnJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmREcmFnKCkge1xuICAgICAgICBpZiAoIXNwZWMuZW5kRHJhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZWMuZW5kRHJhZyh0aGlzLnByb3BzLCB0aGlzLm1vbml0b3IsIHRoaXMuY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU291cmNlO1xuICB9KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZShtb25pdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2UobW9uaXRvcik7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVTb3VyY2VGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlRmFjdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlU291cmNlTW9uaXRvcjtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbnZhciBpc0NhbGxpbmdJc0RyYWdnaW5nID0gZmFsc2U7XG5cbnZhciBTb3VyY2VNb25pdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTb3VyY2VNb25pdG9yKG1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU291cmNlTW9uaXRvcik7XG5cbiAgICB0aGlzLmludGVybmFsTW9uaXRvciA9IG1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvdXJjZU1vbml0b3IsIFt7XG4gICAga2V5OiAncmVjZWl2ZUhhbmRsZXJJZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVIYW5kbGVySWQoc291cmNlSWQpIHtcbiAgICAgIHRoaXMuc291cmNlSWQgPSBzb3VyY2VJZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5EcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRHJhZygpIHtcbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSghaXNDYWxsaW5nQ2FuRHJhZywgJ1lvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5jYW5EcmFnKCkgaW5zaWRlIHlvdXIgY2FuRHJhZygpIGltcGxlbWVudGF0aW9uLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UtbW9uaXRvci5odG1sJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlzQ2FsbGluZ0NhbkRyYWcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuY2FuRHJhZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0RyYWdnaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSghaXNDYWxsaW5nSXNEcmFnZ2luZywgJ1lvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5pc0RyYWdnaW5nKCkgaW5zaWRlIHlvdXIgaXNEcmFnZ2luZygpIGltcGxlbWVudGF0aW9uLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UtbW9uaXRvci5odG1sJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlzQ2FsbGluZ0lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzQ2FsbGluZ0lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJdGVtVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1UeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERyb3BSZXN1bHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREcm9wUmVzdWx0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaWREcm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlkRHJvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5pdGlhbENsaWVudE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2xpZW50T2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU291cmNlTW9uaXRvcjtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlU291cmNlTW9uaXRvcihtYW5hZ2VyKSB7XG4gIHJldHVybiBuZXcgU291cmNlTW9uaXRvcihtYW5hZ2VyKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVNvdXJjZU1vbml0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVTb3VyY2VNb25pdG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlU291cmNlQ29ubmVjdG9yO1xuXG52YXIgX3dyYXBDb25uZWN0b3JIb29rcyA9IHJlcXVpcmUoJy4vd3JhcENvbm5lY3Rvckhvb2tzJyk7XG5cbnZhciBfd3JhcENvbm5lY3Rvckhvb2tzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBDb25uZWN0b3JIb29rcyk7XG5cbnZhciBfYXJlT3B0aW9uc0VxdWFsID0gcmVxdWlyZSgnLi9hcmVPcHRpb25zRXF1YWwnKTtcblxudmFyIF9hcmVPcHRpb25zRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJlT3B0aW9uc0VxdWFsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlU291cmNlQ29ubmVjdG9yKGJhY2tlbmQpIHtcbiAgdmFyIGN1cnJlbnRIYW5kbGVySWQgPSB2b2lkIDA7XG5cbiAgdmFyIGN1cnJlbnREcmFnU291cmNlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIGN1cnJlbnREcmFnU291cmNlT3B0aW9ucyA9IHZvaWQgMDtcbiAgdmFyIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1NvdXJjZSA9IHZvaWQgMDtcblxuICB2YXIgY3VycmVudERyYWdQcmV2aWV3Tm9kZSA9IHZvaWQgMDtcbiAgdmFyIGN1cnJlbnREcmFnUHJldmlld09wdGlvbnMgPSB2b2lkIDA7XG4gIHZhciBkaXNjb25uZWN0Q3VycmVudERyYWdQcmV2aWV3ID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIHJlY29ubmVjdERyYWdTb3VyY2UoKSB7XG4gICAgaWYgKGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1NvdXJjZSkge1xuICAgICAgZGlzY29ubmVjdEN1cnJlbnREcmFnU291cmNlKCk7XG4gICAgICBkaXNjb25uZWN0Q3VycmVudERyYWdTb3VyY2UgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SGFuZGxlcklkICYmIGN1cnJlbnREcmFnU291cmNlTm9kZSkge1xuICAgICAgZGlzY29ubmVjdEN1cnJlbnREcmFnU291cmNlID0gYmFja2VuZC5jb25uZWN0RHJhZ1NvdXJjZShjdXJyZW50SGFuZGxlcklkLCBjdXJyZW50RHJhZ1NvdXJjZU5vZGUsIGN1cnJlbnREcmFnU291cmNlT3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25uZWN0RHJhZ1ByZXZpZXcoKSB7XG4gICAgaWYgKGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcpIHtcbiAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcoKTtcbiAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SGFuZGxlcklkICYmIGN1cnJlbnREcmFnUHJldmlld05vZGUpIHtcbiAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcgPSBiYWNrZW5kLmNvbm5lY3REcmFnUHJldmlldyhjdXJyZW50SGFuZGxlcklkLCBjdXJyZW50RHJhZ1ByZXZpZXdOb2RlLCBjdXJyZW50RHJhZ1ByZXZpZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNlaXZlSGFuZGxlcklkKGhhbmRsZXJJZCkge1xuICAgIGlmIChoYW5kbGVySWQgPT09IGN1cnJlbnRIYW5kbGVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50SGFuZGxlcklkID0gaGFuZGxlcklkO1xuICAgIHJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICByZWNvbm5lY3REcmFnUHJldmlldygpO1xuICB9XG5cbiAgdmFyIGhvb2tzID0gKDAsIF93cmFwQ29ubmVjdG9ySG9va3MyLmRlZmF1bHQpKHtcbiAgICBkcmFnU291cmNlOiBmdW5jdGlvbiBjb25uZWN0RHJhZ1NvdXJjZShub2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyYWdTb3VyY2VOb2RlICYmICgwLCBfYXJlT3B0aW9uc0VxdWFsMi5kZWZhdWx0KShvcHRpb25zLCBjdXJyZW50RHJhZ1NvdXJjZU9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERyYWdTb3VyY2VOb2RlID0gbm9kZTtcbiAgICAgIGN1cnJlbnREcmFnU291cmNlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIHJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICB9LFxuXG4gICAgZHJhZ1ByZXZpZXc6IGZ1bmN0aW9uIGNvbm5lY3REcmFnUHJldmlldyhub2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyYWdQcmV2aWV3Tm9kZSAmJiAoMCwgX2FyZU9wdGlvbnNFcXVhbDIuZGVmYXVsdCkob3B0aW9ucywgY3VycmVudERyYWdQcmV2aWV3T3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RHJhZ1ByZXZpZXdOb2RlID0gbm9kZTtcbiAgICAgIGN1cnJlbnREcmFnUHJldmlld09wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICByZWNvbm5lY3REcmFnUHJldmlldygpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICByZWNlaXZlSGFuZGxlcklkOiByZWNlaXZlSGFuZGxlcklkLFxuICAgIGhvb2tzOiBob29rc1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlQ29ubmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlQ29ubmVjdG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmVXaXRoUmVmO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xvbmVXaXRoUmVmKGVsZW1lbnQsIG5ld1JlZikge1xuICB2YXIgcHJldmlvdXNSZWYgPSBlbGVtZW50LnJlZjtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKHR5cGVvZiBwcmV2aW91c1JlZiAhPT0gJ3N0cmluZycsICdDYW5ub3QgY29ubmVjdCBSZWFjdCBEbkQgdG8gYW4gZWxlbWVudCB3aXRoIGFuIGV4aXN0aW5nIHN0cmluZyByZWYuICcgKyAnUGxlYXNlIGNvbnZlcnQgaXQgdG8gdXNlIGEgY2FsbGJhY2sgcmVmIGluc3RlYWQsIG9yIHdyYXAgaXQgaW50byBhIDxzcGFuPiBvciA8ZGl2Pi4gJyArICdSZWFkIG1vcmU6IGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvbW9yZS1hYm91dC1yZWZzLmh0bWwjdGhlLXJlZi1jYWxsYmFjay1hdHRyaWJ1dGUnKTtcblxuICBpZiAoIXByZXZpb3VzUmVmKSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyByZWYgb24gdGhlIGVsZW1lbnQsIHVzZSB0aGUgbmV3IHJlZiBkaXJlY3RseVxuICAgIHJldHVybiAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwge1xuICAgICAgcmVmOiBuZXdSZWZcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwge1xuICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgIG5ld1JlZihub2RlKTtcblxuICAgICAgaWYgKHByZXZpb3VzUmVmKSB7XG4gICAgICAgIHByZXZpb3VzUmVmKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi91dGlscy9jbG9uZVdpdGhSZWYuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi91dGlscy9jbG9uZVdpdGhSZWYuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEcm9wVGFyZ2V0O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzJyk7XG5cbnZhciBfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tEZWNvcmF0b3JBcmd1bWVudHMpO1xuXG52YXIgX2RlY29yYXRlSGFuZGxlciA9IHJlcXVpcmUoJy4vZGVjb3JhdGVIYW5kbGVyJyk7XG5cbnZhciBfZGVjb3JhdGVIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY29yYXRlSGFuZGxlcik7XG5cbnZhciBfcmVnaXN0ZXJUYXJnZXQgPSByZXF1aXJlKCcuL3JlZ2lzdGVyVGFyZ2V0Jyk7XG5cbnZhciBfcmVnaXN0ZXJUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnaXN0ZXJUYXJnZXQpO1xuXG52YXIgX2NyZWF0ZVRhcmdldEZhY3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVRhcmdldEZhY3RvcnknKTtcblxudmFyIF9jcmVhdGVUYXJnZXRGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRhcmdldEZhY3RvcnkpO1xuXG52YXIgX2NyZWF0ZVRhcmdldE1vbml0b3IgPSByZXF1aXJlKCcuL2NyZWF0ZVRhcmdldE1vbml0b3InKTtcblxudmFyIF9jcmVhdGVUYXJnZXRNb25pdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRhcmdldE1vbml0b3IpO1xuXG52YXIgX2NyZWF0ZVRhcmdldENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY3JlYXRlVGFyZ2V0Q29ubmVjdG9yJyk7XG5cbnZhciBfY3JlYXRlVGFyZ2V0Q29ubmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRhcmdldENvbm5lY3Rvcik7XG5cbnZhciBfaXNWYWxpZFR5cGUgPSByZXF1aXJlKCcuL3V0aWxzL2lzVmFsaWRUeXBlJyk7XG5cbnZhciBfaXNWYWxpZFR5cGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNWYWxpZFR5cGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBEcm9wVGFyZ2V0KHR5cGUsIHNwZWMsIGNvbGxlY3QpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIF9jaGVja0RlY29yYXRvckFyZ3VtZW50czIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFsnRHJvcFRhcmdldCcsICd0eXBlLCBzcGVjLCBjb2xsZWN0Wywgb3B0aW9uc10nXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICB2YXIgZ2V0VHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSgoMCwgX2lzVmFsaWRUeXBlMi5kZWZhdWx0KSh0eXBlLCB0cnVlKSwgJ0V4cGVjdGVkIFwidHlwZVwiIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBEcm9wVGFyZ2V0IHRvIGJlICcgKyAnYSBzdHJpbmcsIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlciBnaXZlbiAnICsgJ3RoZSBjdXJyZW50IHByb3BzLiBJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCB0eXBlKTtcbiAgICBnZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG4gIH1cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKCgwLCBfaXNQbGFpbk9iamVjdDIuZGVmYXVsdCkoc3BlYyksICdFeHBlY3RlZCBcInNwZWNcIiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIERyb3BUYXJnZXQgdG8gYmUgJyArICdhIHBsYWluIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQgJXMuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywgc3BlYyk7XG4gIHZhciBjcmVhdGVUYXJnZXQgPSAoMCwgX2NyZWF0ZVRhcmdldEZhY3RvcnkyLmRlZmF1bHQpKHNwZWMpO1xuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIGNvbGxlY3QgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBcImNvbGxlY3RcIiBwcm92aWRlZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQgdG8gRHJvcFRhcmdldCB0byBiZSAnICsgJ2EgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcGxhaW4gb2JqZWN0IG9mIHByb3BzIHRvIGluamVjdC4gJyArICdJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCBjb2xsZWN0KTtcbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKCgwLCBfaXNQbGFpbk9iamVjdDIuZGVmYXVsdCkob3B0aW9ucyksICdFeHBlY3RlZCBcIm9wdGlvbnNcIiBwcm92aWRlZCBhcyB0aGUgZm91cnRoIGFyZ3VtZW50IHRvIERyb3BUYXJnZXQgdG8gYmUgJyArICdhIHBsYWluIG9iamVjdCB3aGVuIHNwZWNpZmllZC4gJyArICdJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCBjb2xsZWN0KTtcblxuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdGVUYXJnZXQoRGVjb3JhdGVkQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuICgwLCBfZGVjb3JhdGVIYW5kbGVyMi5kZWZhdWx0KSh7XG4gICAgICBjb25uZWN0QmFja2VuZDogZnVuY3Rpb24gY29ubmVjdEJhY2tlbmQoYmFja2VuZCwgdGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgfSxcbiAgICAgIGNvbnRhaW5lckRpc3BsYXlOYW1lOiAnRHJvcFRhcmdldCcsXG4gICAgICBjcmVhdGVIYW5kbGVyOiBjcmVhdGVUYXJnZXQsXG4gICAgICByZWdpc3RlckhhbmRsZXI6IF9yZWdpc3RlclRhcmdldDIuZGVmYXVsdCxcbiAgICAgIGNyZWF0ZU1vbml0b3I6IF9jcmVhdGVUYXJnZXRNb25pdG9yMi5kZWZhdWx0LFxuICAgICAgY3JlYXRlQ29ubmVjdG9yOiBfY3JlYXRlVGFyZ2V0Q29ubmVjdG9yMi5kZWZhdWx0LFxuICAgICAgRGVjb3JhdGVkQ29tcG9uZW50OiBEZWNvcmF0ZWRDb21wb25lbnQsXG4gICAgICBnZXRUeXBlOiBnZXRUeXBlLFxuICAgICAgY29sbGVjdDogY29sbGVjdCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0Ryb3BUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9Ecm9wVGFyZ2V0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWdpc3RlclRhcmdldDtcbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0KHR5cGUsIHRhcmdldCwgbWFuYWdlcikge1xuICB2YXIgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gIHZhciB0YXJnZXRJZCA9IHJlZ2lzdHJ5LmFkZFRhcmdldCh0eXBlLCB0YXJnZXQpO1xuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUYXJnZXQoKSB7XG4gICAgcmVnaXN0cnkucmVtb3ZlVGFyZ2V0KHRhcmdldElkKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFuZGxlcklkOiB0YXJnZXRJZCxcbiAgICB1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyVGFyZ2V0XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9yZWdpc3RlclRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3JlZ2lzdGVyVGFyZ2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUYXJnZXRGYWN0b3J5O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBTExPV0VEX1NQRUNfTUVUSE9EUyA9IFsnY2FuRHJvcCcsICdob3ZlcicsICdkcm9wJ107XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhcmdldEZhY3Rvcnkoc3BlYykge1xuICBPYmplY3Qua2V5cyhzcGVjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoQUxMT1dFRF9TUEVDX01FVEhPRFMuaW5kZXhPZihrZXkpID4gLTEsICdFeHBlY3RlZCB0aGUgZHJvcCB0YXJnZXQgc3BlY2lmaWNhdGlvbiB0byBvbmx5IGhhdmUgJyArICdzb21lIG9mIHRoZSBmb2xsb3dpbmcga2V5czogJXMuICcgKyAnSW5zdGVhZCByZWNlaXZlZCBhIHNwZWNpZmljYXRpb24gd2l0aCBhbiB1bmV4cGVjdGVkIFwiJXNcIiBrZXkuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywgQUxMT1dFRF9TUEVDX01FVEhPRFMuam9pbignLCAnKSwga2V5KTtcbiAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIHNwZWNba2V5XSA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkICVzIGluIHRoZSBkcm9wIHRhcmdldCBzcGVjaWZpY2F0aW9uIHRvIGJlIGEgZnVuY3Rpb24uICcgKyAnSW5zdGVhZCByZWNlaXZlZCBhIHNwZWNpZmljYXRpb24gd2l0aCAlczogJXMuICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywga2V5LCBrZXksIHNwZWNba2V5XSk7XG4gIH0pO1xuXG4gIHZhciBUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFyZ2V0KG1vbml0b3IpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYXJnZXQpO1xuXG4gICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRhcmdldCwgW3tcbiAgICAgIGtleTogJ3JlY2VpdmVQcm9wcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWNlaXZlTW9uaXRvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjZWl2ZU1vbml0b3IobW9uaXRvcikge1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlY2VpdmVDb21wb25lbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbkRyb3AnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyb3AoKSB7XG4gICAgICAgIGlmICghc3BlYy5jYW5Ecm9wKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BlYy5jYW5Ecm9wKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaG92ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyKCkge1xuICAgICAgICBpZiAoIXNwZWMuaG92ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzcGVjLmhvdmVyKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvciwgdGhpcy5jb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Ryb3AnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICAgIGlmICghc3BlYy5kcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcm9wUmVzdWx0ID0gc3BlYy5kcm9wKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvciwgdGhpcy5jb21wb25lbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh0eXBlb2YgZHJvcFJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgKDAsIF9pc1BsYWluT2JqZWN0Mi5kZWZhdWx0KShkcm9wUmVzdWx0KSwgJ2Ryb3AoKSBtdXN0IGVpdGhlciByZXR1cm4gdW5kZWZpbmVkLCBvciBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBkcm9wIHJlc3VsdC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkICVzLiAnICsgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJvcC10YXJnZXQuaHRtbCcsIGRyb3BSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcm9wUmVzdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUYXJnZXQ7XG4gIH0oKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlVGFyZ2V0KG1vbml0b3IpIHtcbiAgICByZXR1cm4gbmV3IFRhcmdldChtb25pdG9yKTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVRhcmdldEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVUYXJnZXRGYWN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUYXJnZXRNb25pdG9yO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgaXNDYWxsaW5nQ2FuRHJvcCA9IGZhbHNlO1xuXG52YXIgVGFyZ2V0TW9uaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGFyZ2V0TW9uaXRvcihtYW5hZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhcmdldE1vbml0b3IpO1xuXG4gICAgdGhpcy5pbnRlcm5hbE1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUYXJnZXRNb25pdG9yLCBbe1xuICAgIGtleTogJ3JlY2VpdmVIYW5kbGVySWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlaXZlSGFuZGxlcklkKHRhcmdldElkKSB7XG4gICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FuRHJvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyb3AoKSB7XG4gICAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoIWlzQ2FsbGluZ0NhbkRyb3AsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJvcCgpIGluc2lkZSB5b3VyIGNhbkRyb3AoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0LW1vbml0b3IuaHRtbCcpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyb3BPblRhcmdldCh0aGlzLnRhcmdldElkKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc092ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXIob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmlzT3ZlclRhcmdldCh0aGlzLnRhcmdldElkLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJdGVtVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1UeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERyb3BSZXN1bHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREcm9wUmVzdWx0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaWREcm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlkRHJvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5pdGlhbENsaWVudE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTb3VyY2VDbGllbnRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2xpZW50T2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFyZ2V0TW9uaXRvcjtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlVGFyZ2V0TW9uaXRvcihtYW5hZ2VyKSB7XG4gIHJldHVybiBuZXcgVGFyZ2V0TW9uaXRvcihtYW5hZ2VyKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVRhcmdldE1vbml0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjazovLy9ub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVUYXJnZXRNb25pdG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVGFyZ2V0Q29ubmVjdG9yO1xuXG52YXIgX3dyYXBDb25uZWN0b3JIb29rcyA9IHJlcXVpcmUoJy4vd3JhcENvbm5lY3Rvckhvb2tzJyk7XG5cbnZhciBfd3JhcENvbm5lY3Rvckhvb2tzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBDb25uZWN0b3JIb29rcyk7XG5cbnZhciBfYXJlT3B0aW9uc0VxdWFsID0gcmVxdWlyZSgnLi9hcmVPcHRpb25zRXF1YWwnKTtcblxudmFyIF9hcmVPcHRpb25zRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJlT3B0aW9uc0VxdWFsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlVGFyZ2V0Q29ubmVjdG9yKGJhY2tlbmQpIHtcbiAgdmFyIGN1cnJlbnRIYW5kbGVySWQgPSB2b2lkIDA7XG5cbiAgdmFyIGN1cnJlbnREcm9wVGFyZ2V0Tm9kZSA9IHZvaWQgMDtcbiAgdmFyIGN1cnJlbnREcm9wVGFyZ2V0T3B0aW9ucyA9IHZvaWQgMDtcbiAgdmFyIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZWNvbm5lY3REcm9wVGFyZ2V0KCkge1xuICAgIGlmIChkaXNjb25uZWN0Q3VycmVudERyb3BUYXJnZXQpIHtcbiAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldCgpO1xuICAgICAgZGlzY29ubmVjdEN1cnJlbnREcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEhhbmRsZXJJZCAmJiBjdXJyZW50RHJvcFRhcmdldE5vZGUpIHtcbiAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldCA9IGJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQoY3VycmVudEhhbmRsZXJJZCwgY3VycmVudERyb3BUYXJnZXROb2RlLCBjdXJyZW50RHJvcFRhcmdldE9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKSB7XG4gICAgaWYgKGhhbmRsZXJJZCA9PT0gY3VycmVudEhhbmRsZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRIYW5kbGVySWQgPSBoYW5kbGVySWQ7XG4gICAgcmVjb25uZWN0RHJvcFRhcmdldCgpO1xuICB9XG5cbiAgdmFyIGhvb2tzID0gKDAsIF93cmFwQ29ubmVjdG9ySG9va3MyLmRlZmF1bHQpKHtcbiAgICBkcm9wVGFyZ2V0OiBmdW5jdGlvbiBjb25uZWN0RHJvcFRhcmdldChub2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyb3BUYXJnZXROb2RlICYmICgwLCBfYXJlT3B0aW9uc0VxdWFsMi5kZWZhdWx0KShvcHRpb25zLCBjdXJyZW50RHJvcFRhcmdldE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERyb3BUYXJnZXROb2RlID0gbm9kZTtcbiAgICAgIGN1cnJlbnREcm9wVGFyZ2V0T3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIHJlY29ubmVjdERyb3BUYXJnZXQoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZUhhbmRsZXJJZDogcmVjZWl2ZUhhbmRsZXJJZCxcbiAgICBob29rczogaG9va3NcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVRhcmdldENvbm5lY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVRhcmdldENvbm5lY3Rvci5qcyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28gSW5jLlxyXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cclxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVG91Y2hCYWNrZW5kID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUb3VjaEJhY2tlbmQ7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2xpZW50VG91Y2hPZmZzZXQoZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudE9mZnNldChlLnRhcmdldFRvdWNoZXNbMF0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50Q2xpZW50VG91Y2hPZmZzZXQoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUG9seWZpbGwgZm9yIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50XG52YXIgZWxlbWVudHNGcm9tUG9pbnQgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCB8fCBmdW5jdGlvbiAoeCwgeSkge1xuXG4gICAgaWYgKGRvY3VtZW50Lm1zRWxlbWVudHNGcm9tUG9pbnQpIHtcbiAgICAgICAgLy8gbXNFbGVtZW50c0Zyb21Qb2ludCBpcyBtdWNoIGZhc3RlciBidXQgcmV0dXJucyBhIG5vZGUtbGlzdCwgc28gY29udmVydCBpdCB0byBhbiBhcnJheVxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQubXNFbGVtZW50c0Zyb21Qb2ludCh4LCB5KSwgMCk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHByZXZpb3VzUG9pbnRlckV2ZW50cyA9IFtdLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBpLFxuICAgICAgICBkO1xuXG4gICAgLy8gZ2V0IGFsbCBlbGVtZW50cyB2aWEgZWxlbWVudEZyb21Qb2ludCwgYW5kIHJlbW92ZSB0aGVtIGZyb20gaGl0LXRlc3RpbmcgaW4gb3JkZXJcbiAgICB3aGlsZSAoKGN1cnJlbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSAmJiBlbGVtZW50cy5pbmRleE9mKGN1cnJlbnQpID09PSAtMSAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG5cbiAgICAgICAgLy8gcHVzaCB0aGUgZWxlbWVudCBhbmQgaXRzIGN1cnJlbnQgc3R5bGVcbiAgICAgICAgZWxlbWVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgcHJldmlvdXNQb2ludGVyRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9pbnRlci1ldmVudHMnKSxcbiAgICAgICAgICAgIHByaW9yaXR5OiBjdXJyZW50LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ3BvaW50ZXItZXZlbnRzJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIFwicG9pbnRlci1ldmVudHM6IG5vbmVcIiwgdG8gZ2V0IHRvIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnRcbiAgICAgICAgY3VycmVudC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBwb2ludGVyLWV2ZW50cyB2YWx1ZXNcbiAgICBmb3IgKGkgPSBwcmV2aW91c1BvaW50ZXJFdmVudHMubGVuZ3RoOyBkID0gcHJldmlvdXNQb2ludGVyRXZlbnRzWy0taV07KSB7XG4gICAgICAgIGVsZW1lbnRzW2ldLnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsIGQudmFsdWUgPyBkLnZhbHVlIDogJycsIGQucHJpb3JpdHkpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBvdXIgcmVzdWx0c1xuICAgIHJldHVybiBlbGVtZW50cztcbn0pLmJpbmQodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2ltdWxhciB0byBqUXVlcnkncyB0ZXN0XG4gICAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn0oKTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG5mdW5jdGlvbiBnZXROb2RlQ2xpZW50T2Zmc2V0KG5vZGUpIHtcbiAgICB2YXIgZWwgPSBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgPyBub2RlIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX2VsJGdldEJvdW5kaW5nQ2xpZW50ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHRvcCA9IF9lbCRnZXRCb3VuZGluZ0NsaWVudC50b3AsXG4gICAgICAgIGxlZnQgPSBfZWwkZ2V0Qm91bmRpbmdDbGllbnQubGVmdDtcblxuICAgIHJldHVybiB7IHg6IGxlZnQsIHk6IHRvcCB9O1xufVxuXG52YXIgZXZlbnROYW1lcyA9IHtcbiAgICBtb3VzZToge1xuICAgICAgICBzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICBlbmQ6ICdtb3VzZXVwJyxcbiAgICAgICAgY29udGV4dG1lbnU6ICdjb250ZXh0bWVudSdcbiAgICB9LFxuICAgIHRvdWNoOiB7XG4gICAgICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG4gICAgICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgICAgICBlbmQ6ICd0b3VjaGVuZCdcbiAgICB9LFxuICAgIGtleWJvYXJkOiB7XG4gICAgICAgIGtleWRvd246ICdrZXlkb3duJ1xuICAgIH1cbn07XG5cbnZhciBUb3VjaEJhY2tlbmQgPSBleHBvcnRzLlRvdWNoQmFja2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb3VjaEJhY2tlbmQobWFuYWdlcikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvdWNoQmFja2VuZCk7XG5cbiAgICAgICAgb3B0aW9ucy5kZWxheVRvdWNoU3RhcnQgPSBvcHRpb25zLmRlbGF5VG91Y2hTdGFydCB8fCBvcHRpb25zLmRlbGF5O1xuXG4gICAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBlbmFibGVUb3VjaEV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZU1vdXNlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIGVuYWJsZUtleWJvYXJkRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIGRlbGF5VG91Y2hTdGFydDogMCxcbiAgICAgICAgICAgIGRlbGF5TW91c2VTdGFydDogMFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG5cbiAgICAgICAgdGhpcy5lbmFibGVLZXlib2FyZEV2ZW50cyA9IG9wdGlvbnMuZW5hYmxlS2V5Ym9hcmRFdmVudHM7XG4gICAgICAgIHRoaXMuZW5hYmxlTW91c2VFdmVudHMgPSBvcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzO1xuICAgICAgICB0aGlzLmRlbGF5VG91Y2hTdGFydCA9IG9wdGlvbnMuZGVsYXlUb3VjaFN0YXJ0O1xuICAgICAgICB0aGlzLmRlbGF5TW91c2VTdGFydCA9IG9wdGlvbnMuZGVsYXlNb3VzZVN0YXJ0O1xuICAgICAgICB0aGlzLnNvdXJjZU5vZGVzID0ge307XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy50YXJnZXROb2RlcyA9IHt9O1xuICAgICAgICB0aGlzLnRhcmdldE5vZGVPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcyA9IFtdO1xuICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaCgnbW91c2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZVRvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaCgndG91Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaCgna2V5Ym9hcmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gdGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQgPSB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5ID0gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUgPSB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlQ2FwdHVyZSA9IHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlID0gdGhpcy5oYW5kbGVUb3BNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUgPSB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGUgPSB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRvdWNoQmFja2VuZCwgW3tcbiAgICAgICAga2V5OiAnc2V0dXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSghdGhpcy5jb25zdHJ1Y3Rvci5pc1NldFVwLCAnQ2Fubm90IGhhdmUgdHdvIFRvdWNoIGJhY2tlbmRzIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmlzU2V0VXAgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnc3RhcnQnLCB0aGlzLmdldFRvcE1vdmVTdGFydEhhbmRsZXIoKSk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmUpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdlbmQnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlS2V5Ym9hcmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZWFyZG93bicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3N0YXJ0JywgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdtb3ZlJywgdGhpcy5oYW5kbGVUb3BNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdlbmQnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlS2V5Ym9hcmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkRXZlbnRMaXN0ZW5lcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogZmFsc2UgfSA6IGNhcHR1cmU7XG5cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lc1tsaXN0ZW5lclR5cGVdW2V2ZW50XSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogZmFsc2UgfSA6IGNhcHR1cmU7XG5cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lc1tsaXN0ZW5lclR5cGVdW2V2ZW50XSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29ubmVjdERyYWdTb3VyY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdERyYWdTb3VyY2Uoc291cmNlSWQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVNb3ZlU3RhcnQgPSB0aGlzLmhhbmRsZU1vdmVTdGFydC5iaW5kKHRoaXMsIHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlTm9kZXNbc291cmNlSWRdID0gbm9kZTtcblxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNvdXJjZU5vZGVzW3NvdXJjZUlkXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb25uZWN0RHJhZ1ByZXZpZXcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdERyYWdQcmV2aWV3KHNvdXJjZUlkLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnNbc291cmNlSWRdID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzW3NvdXJjZUlkXSA9IG5vZGU7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzMi5zb3VyY2VQcmV2aWV3Tm9kZXNbc291cmNlSWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczIuc291cmNlUHJldmlld05vZGVPcHRpb25zW3NvdXJjZUlkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Nvbm5lY3REcm9wVGFyZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3REcm9wVGFyZ2V0KHRhcmdldElkLCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGhhbmRsZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3ZlKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHcmFiIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGN1cnJlbnQgbW91c2UvdG91Y2ggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXZlbnROYW1lcy5tb3VzZS5tb3ZlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzID0geyB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBldmVudE5hbWVzLnRvdWNoLm1vdmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSB7IHg6IGUudG91Y2hlc1swXS5jbGllbnRYLCB5OiBlLnRvdWNoZXNbMF0uY2xpZW50WSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVc2UgdGhlIGNvb3JkaW5hdGVzIHRvIGdyYWIgdGhlIGVsZW1lbnQgdGhlIGRyYWcgZW5kZWQgb24uXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyB0aGUgc2FtZSBhcyB0aGUgdGFyZ2V0IG5vZGUgKG9yIGFueSBvZiBpdCdzIGNoaWxkcmVuKSB0aGVuIHdlIGhhdmUgaGl0IGEgZHJvcCB0YXJnZXQgYW5kIGNhbiBoYW5kbGUgdGhlIG1vdmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgZHJvcHBlZE9uID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE1hdGNoID0gbm9kZS5jb250YWlucyhkcm9wcGVkT24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyb3BwZWRPbiA9PT0gbm9kZSB8fCBjaGlsZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuaGFuZGxlTW92ZShlLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEF0dGFjaGluZyB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGJvZHkgc28gdGhhdCB0b3VjaG1vdmUgd2lsbCB3b3JrIHdoaWxlIGRyYWdnaW5nIG92ZXIgbXVsdGlwbGUgdGFyZ2V0IGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JyksICdtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldE5vZGVzW3RhcmdldElkXSA9IG5vZGU7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzMy50YXJnZXROb2Rlc1t0YXJnZXRJZF07XG4gICAgICAgICAgICAgICAgX3RoaXMzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLCAnbW92ZScsIGhhbmRsZU1vdmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0U291cmNlQ2xpZW50T2Zmc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNvdXJjZUNsaWVudE9mZnNldChzb3VyY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVDbGllbnRPZmZzZXQodGhpcy5zb3VyY2VOb2Rlc1tzb3VyY2VJZF0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVUb3BNb3ZlU3RhcnRDYXB0dXJlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUoZSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnRTb3VyY2VJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlTW92ZVN0YXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmVTdGFydChzb3VyY2VJZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnRTb3VyY2VJZHMudW5zaGlmdChzb3VyY2VJZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFRvcE1vdmVTdGFydEhhbmRsZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZWxheVRvdWNoU3RhcnQgJiYgIXRoaXMuZGVsYXlNb3VzZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlVG9wTW92ZVN0YXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvcE1vdmVTdGFydChlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBwcmVtYXR1cmVseSBwcmV2ZW50RGVmYXVsdCgpIGhlcmUgc2luY2UgaXQgbWlnaHQ6XG4gICAgICAgICAgICAvLyAxLiBNZXNzIHVwIHNjcm9sbGluZ1xuICAgICAgICAgICAgLy8gMi4gTWVzcyB1cCBsb25nIHRhcCAod2hpY2ggYnJpbmdzIHVwIGNvbnRleHQgbWVudSlcbiAgICAgICAgICAgIC8vIDMuIElmIHRoZXJlJ3MgYW4gYW5jaG9yIGxpbmsgYXMgYSBjaGlsZCwgdGFwIHdvbid0IGJlIHRyaWdnZXJlZCBvbiBsaW5rXG5cbiAgICAgICAgICAgIHZhciBjbGllbnRPZmZzZXQgPSBnZXRFdmVudENsaWVudE9mZnNldChlKTtcbiAgICAgICAgICAgIGlmIChjbGllbnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IGNsaWVudE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlVG9wTW92ZVN0YXJ0RGVsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9wTW92ZVN0YXJ0RGVsYXkoZSkge1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gZS50eXBlID09PSBldmVudE5hbWVzLnRvdWNoLnN0YXJ0ID8gdGhpcy5kZWxheVRvdWNoU3RhcnQgOiB0aGlzLmRlbGF5TW91c2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVUb3BNb3ZlQ2FwdHVyZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3BNb3ZlQ2FwdHVyZShlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZU1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW92ZShlLCB0YXJnZXRJZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnT3ZlclRhcmdldElkcy51bnNoaWZ0KHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlVG9wTW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3BNb3ZlKGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcblxuICAgICAgICAgICAgdmFyIG1vdmVTdGFydFNvdXJjZUlkcyA9IHRoaXMubW92ZVN0YXJ0U291cmNlSWRzLFxuICAgICAgICAgICAgICAgIGRyYWdPdmVyVGFyZ2V0SWRzID0gdGhpcy5kcmFnT3ZlclRhcmdldElkcztcblxuICAgICAgICAgICAgdmFyIGNsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUpO1xuXG4gICAgICAgICAgICBpZiAoIWNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIGFuZCB3ZSd2ZSBtb3ZlZCBhIGxpdHRsZSwgdGhhdCBjb3VudHMgYXMgYSBkcmFnIHN0YXJ0XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgJiYgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBtb3ZlU3RhcnRTb3VyY2VJZHMgJiYgKHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnggIT09IGNsaWVudE9mZnNldC54IHx8IHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnkgIT09IGNsaWVudE9mZnNldC55KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKG1vdmVTdGFydFNvdXJjZUlkcywge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQ6IHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoU291cmNlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzb3VyY2VOb2RlID0gdGhpcy5zb3VyY2VOb2Rlc1t0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKV07XG4gICAgICAgICAgICB0aGlzLmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKHNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnB1Ymxpc2hEcmFnU291cmNlKCk7XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBub2RlIGVsZW1lbnRzIG9mIHRoZSBob3ZlcmVkIERyb3BUYXJnZXRzXG4gICAgICAgICAgICB2YXIgZHJhZ092ZXJUYXJnZXROb2RlcyA9IGRyYWdPdmVyVGFyZ2V0SWRzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC50YXJnZXROb2Rlc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGEgb3JkZXJlZCBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRvdWNoZWQgYnlcbiAgICAgICAgICAgIHZhciBlbGVtZW50c0F0UG9pbnQgPSBlbGVtZW50c0Zyb21Qb2ludChjbGllbnRPZmZzZXQueCwgY2xpZW50T2Zmc2V0LnkpO1xuICAgICAgICAgICAgdmFyIG9yZGVyZWREcmFnT3ZlclRhcmdldElkcyA9IGVsZW1lbnRzQXRQb2ludFxuICAgICAgICAgICAgLy8gRmlsdGVyIG9mZiBub2RlcyB0aGF0IGFyZW50IGEgaG92ZXJlZCBEcm9wVGFyZ2V0cyBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcmFnT3ZlclRhcmdldE5vZGVzLmluZGV4T2Yobm9kZSkgPiAtMTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBNYXAgYmFjayB0aGUgbm9kZXMgZWxlbWVudHMgdG8gdGFyZ2V0SWRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGFyZ2V0SWQgaW4gX3RoaXM0LnRhcmdldE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBfdGhpczQudGFyZ2V0Tm9kZXNbdGFyZ2V0SWRdKSByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIEZpbHRlciBvZmYgcG9zc2libGUgbnVsbCByb3dzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbm9kZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGJlY2F1c2UgZG5kLWNvcmUgcmV2ZXJzZSBpdCBiZWZvcmUgY2FsbGluZyB0aGUgRHJvcFRhcmdldCBkcm9wIG1ldGhvZHNcbiAgICAgICAgICAgIG9yZGVyZWREcmFnT3ZlclRhcmdldElkcy5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZVRvcE1vdmVFbmRDYXB0dXJlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSB8fCB0aGlzLm1vbml0b3IuZGlkRHJvcCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5kcm9wKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVDYW5jZWxPbkVzY2FwZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDYW5jZWxPbkVzY2FwZShlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQgPSB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZU9uQ29udGV4dE1lbnUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlT25Db250ZXh0TWVudSgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIobm9kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIgPSBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNS5yZXN1cnJlY3RTb3VyY2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNS51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLm9ic2VydmUobm9kZS5wYXJlbnRFbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzdXJyZWN0U291cmNlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1cnJlY3RTb3VyY2VOb2RlKCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcmVhY3RpZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdnZWRTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUb3VjaEJhY2tlbmQ7XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvdWNoQmFja2VuZCgpIHtcbiAgICB2YXIgb3B0aW9uc09yTWFuYWdlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICB2YXIgdG91Y2hCYWNrZW5kRmFjdG9yeSA9IGZ1bmN0aW9uIHRvdWNoQmFja2VuZEZhY3RvcnkobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbmV3IFRvdWNoQmFja2VuZChtYW5hZ2VyLCBvcHRpb25zT3JNYW5hZ2VyKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnNPck1hbmFnZXIuZ2V0TW9uaXRvcikge1xuICAgICAgICByZXR1cm4gdG91Y2hCYWNrZW5kRmFjdG9yeShvcHRpb25zT3JNYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG91Y2hCYWNrZW5kRmFjdG9yeTtcbiAgICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG5kLXRvdWNoLWJhY2tlbmQvZGlzdC9Ub3VjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQtdG91Y2gtYmFja2VuZC9kaXN0L1RvdWNoLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRuZC10b3VjaC1iYWNrZW5kL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kbmQtdG91Y2gtYmFja2VuZC9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IERyYWdMYXllciBmcm9tICdyZWFjdC1kbmQvbGliL0RyYWdMYXllcic7XG5pbXBvcnQgRXZlbnRCYXNlIGZyb20gJy4vRXZlbnRCYXNlJztcbmltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5cbmZ1bmN0aW9uIGNvbGxlY3QgKG1vbml0b3Ipe1xuICBjb25zdCBwcm9wcyA9IHtcbiAgICBjbGllbnRPZmZzZXQ6IG1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KClcbiAgfTtcblxuICBjb25zdCBpdGVtID0gbW9uaXRvci5nZXRJdGVtKCk7XG4gIGlmKGl0ZW0gJiYgaXRlbVsnZHJhZ2dpbmdDb21wb25lbnQnXSl7XG4gICAgcHJvcHNbJ2RyYWdnaW5nQ29tcG9uZW50J10gPSBpdGVtWydkcmFnZ2luZ0NvbXBvbmVudCddO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jbGFzcyBFdmVudFByZXZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBnZXRJdGVtU3R5bGVzICgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMuY2xpZW50T2Zmc2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IHRoaXMucHJvcHMuY2xpZW50T2Zmc2V0Lng7XG4gICAgY29uc3QgeSA9IHRoaXMucHJvcHMuY2xpZW50T2Zmc2V0Lnk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgO1xuXG4gICAgcmV0dXJuIGFzc2lnbih0aGlzLnByb3BzLmRyYWdnaW5nQ29tcG9uZW50LmdldERyYWdnaW5nU3R5bGUoKSwge1xuICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgbGV0IGRyYWdnaW5nRGlzcGxheSA9ICcnO1xuICAgIGlmKHRoaXMucHJvcHMuZHJhZ2dpbmdDb21wb25lbnQgJiYgdGhpcy5wcm9wcy5kcmFnZ2luZ0NvbXBvbmVudC5zdGF0ZS5kcmFnZ2luZ0Rpc3BsYXkpe1xuICAgICAgZHJhZ2dpbmdEaXNwbGF5ID0gdGhpcy5wcm9wcy5kcmFnZ2luZ0NvbXBvbmVudC5zdGF0ZS5kcmFnZ2luZ0Rpc3BsYXk7XG4gICAgfVxuXG4gICAgbGV0IGRpc3BsYXkgPSBbXTtcbiAgICBpZih0aGlzLnByb3BzLmRyYWdnaW5nQ29tcG9uZW50ICYmIHRoaXMucHJvcHMuZHJhZ2dpbmdDb21wb25lbnQuc3RhdGUuZGlzcGxheSl7XG4gICAgICBkaXNwbGF5ID0gdGhpcy5wcm9wcy5kcmFnZ2luZ0NvbXBvbmVudC5zdGF0ZS5kaXNwbGF5O1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiByZWY9XCJwcmV2aWV3XCIgY2xhc3NOYW1lPVwidGxFdmVudFZpZXcgdGxEcmFnZ2luZ0V2ZW50XCIgc3R5bGU9e3RoaXMuZ2V0SXRlbVN0eWxlcygpfT5cbiAgICAgICAgPEV2ZW50QmFzZVxuICAgICAgICAgIGRyYWdnaW5nRGlzcGxheT17ZHJhZ2dpbmdEaXNwbGF5fVxuICAgICAgICAgIGRpc3BsYXk9e2Rpc3BsYXl9XG4gICAgICAgICAgdGltZWxpbmU9e3RoaXMucHJvcHMudGltZWxpbmV9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdMYXllcihjb2xsZWN0KShFdmVudFByZXZpZXcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvRXZlbnRQcmV2aWV3LmpzeFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0V2ZW50UHJldmlldy5qc3giLCJleHBvcnQgZnVuY3Rpb24gY2xvc2VzdChlbGVtLCBzZWxlY3Rvcikge1xuICB2YXIgbWF0Y2hlc0ZuO1xuXG4gIC8vIGZpbmQgdmVuZG9yIHByZWZpeFxuICBbJ21hdGNoZXMnLCd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCdtb3pNYXRjaGVzU2VsZWN0b3InLCdtc01hdGNoZXNTZWxlY3RvcicsJ29NYXRjaGVzU2VsZWN0b3InXS5zb21lKGZ1bmN0aW9uKGZuKSB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHlbZm5dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtYXRjaGVzRm4gPSBmbjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSlcblxuICB2YXIgcGFyZW50O1xuXG4gIC8vIHRyYXZlcnNlIHBhcmVudHNcbiAgd2hpbGUgKGVsZW0pIHtcbiAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50W21hdGNoZXNGbl0oc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGVsZW0gPSBwYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMuZXM2XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vc3JjL3V0aWxzLmVzNiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBUaW1lU3BhbiBmcm9tICcuLi9jbGFzc2VzL1RpbWVTcGFuJztcbmltcG9ydCB7RHJhZ1NvdXJjZX0gZnJvbSAncmVhY3QtZG5kJztcbmltcG9ydCBFdmVudEJhc2UgZnJvbSAnLi9FdmVudEJhc2UnO1xuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vVGltZWxpbmUnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJ1xuXG5jb25zdCBzb3VyY2UgPSB7XG4gIGJlZ2luRHJhZzogZnVuY3Rpb24gKHByb3BzLCBtb25pdG9yLCBjb21wb25lbnQpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wcywge2RyYWdnaW5nQ29tcG9uZW50OiBjb21wb25lbnR9KTtcbiAgfSxcbiAgY2FuRHJhZzogZnVuY3Rpb24ocHJvcHMsIG1vbml0b3IsIGNvbXBvbmVudCl7XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gcHJvcHMudGltZWxpbmUuZmluZEV2ZW50QnlJZChwcm9wcy5pZCkuc3RhdGUuZHJhZ2dhYmxlO1xuICAgIHJldHVybiAhIWRyYWdnYWJsZTtcbiAgfVxufVxuXG5jb25zdCBjb2xsZWN0ID0gKGNvbm5lY3QsIG1vbml0b3IpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0RHJhZ1NvdXJjZTogY29ubmVjdC5kcmFnU291cmNlKCksXG4gICAgaXNEcmFnZ2luZzogbW9uaXRvci5pc0RyYWdnaW5nKClcbiAgfTtcbn1cblxuY2xhc3MgRXZlbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRvcDogcHJvcHMuZmxvYXQgPT09IHVuZGVmaW5lZCA/IHRoaXMucHJvcHMudGltZWxpbmUudGltZVRvVG9wKHRoaXMucHJvcHMudGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpIDogcHJvcHMuZmxvYXQudG9wLFxuICAgICAgbGVmdDogcHJvcHMuZmxvYXQgPT09IHVuZGVmaW5lZCA/IHRoaXMucHJvcHMudGltZWxpbmUuZ2V0TGluZUxlZnQodGhpcy5wcm9wcy5saW5lSWQpIDogcHJvcHMuZmxvYXQubGVmdCxcbiAgICAgIGNvbG9yOiB0aGlzLnByb3BzLmNvbG9yLFxuICAgICAgZHJhZ2dhYmxlOiBwcm9wcy5mbG9hdCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0cnVlLFxuICAgICAgcmVzaXphYmxlOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nRGlzcGxheTogJycsXG4gICAgICBkaXNwbGF5OiBwcm9wcy5kaXNwbGF5LFxuICAgIH1cblxuICAgIHRoaXMubGluZUlkID0gdGhpcy5wcm9wcy5saW5lSWQ7XG4gICAgdGhpcy50aW1lU3BhbiA9IHRoaXMucHJvcHMudGltZVNwYW47XG4gICAgdGhpcy5kcmFnZ2luZ1Bvc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6aW5nVGltZVNwYW4gPSBudWxsO1xuICAgIHRoaXMucmVzaXppbmcgPSBmYWxzZTtcbiAgICB0aGlzLnZhcnMgPSB0aGlzLnByb3BzLnZhcnMgPyB0aGlzLnByb3BzLnZhcnMgOiB7fTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYodGhpcy5wcm9wcy5mbG9hdCl7XG4gICAgICAvLyDpq5jjgZXjgpLoqK3lrppcbiAgICAgIHRoaXMuc3RhdGUuaGVpZ2h0ID0gdGhpcy5wcm9wcy50aW1lbGluZS5taW51dGVUb0hlaWdodCh0aGlzLnByb3BzLmZsb2F0Lm1pbnV0ZSk7XG4gICAgICBjb25zdCB0aW1lID0gdGhpcy5wcm9wcy50aW1lbGluZS50b3BUb1RpbWUodGhpcy5zdGF0ZS50b3ApO1xuICAgICAgdGhpcy5kcmFnZ2luZ1Bvc2l0aW9uID0ge3RpbWU6IHRpbWUsIGxpbmVJZDogdW5kZWZpbmVkfTtcbiAgICAgIHRoaXMuc3RhdGUuZHJhZ2dpbmdEaXNwbGF5ID0gdGltZS5nZXREaXNwbGF5VGltZSgpO1xuICAgICAgdGhpcy50aW1lU3BhbiA9IG5ldyBUaW1lU3Bhbih0aW1lLCB0aW1lLmFkZE1pbih0aGlzLnByb3BzLmZsb2F0Lm1pbnV0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmhlaWdodCA9IHRoaXMucHJvcHMudGltZWxpbmUudGltZVNwYW5Ub0hlaWdodCh0aGlzLnRpbWVTcGFuKTtcbiAgICB9XG4gIH1cblxuICB0b0pzb24oKXtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICBsaW5lSWQ6IHRoaXMubGluZUlkLFxuICAgICAgdGltZVNwYW46IHRoaXMudGltZVNwYW4sXG4gICAgICB2YXJzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudmFycykpLFxuICAgICAgY29sb3I6IHRoaXMuc3RhdGUuY29sb3IsXG4gICAgICBkaXNwbGF5OiB0aGlzLnByb3BzLmRpc3BsYXksXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB0b3A6IHRoaXMuc3RhdGUudG9wLFxuICAgICAgICBsZWZ0OiB0aGlzLnN0YXRlLmxlZnQsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlcyl7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB7fTtcbiAgICBpZih2YWx1ZXMudGltZVNwYW4pe1xuICAgICAgbmV3U3RhdGUuaGVpZ2h0ID0gdGhpcy5wcm9wcy50aW1lbGluZS50aW1lU3BhblRvSGVpZ2h0KHZhbHVlcy50aW1lU3Bhbik7XG4gICAgICBuZXdTdGF0ZS50b3AgPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVUb1RvcCh2YWx1ZXMudGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpO1xuICAgICAgdGhpcy50aW1lU3BhbiA9IHZhbHVlcy50aW1lU3BhbjtcbiAgICB9XG5cbiAgICBpZih2YWx1ZXMuY29sb3Ipe1xuICAgICAgbmV3U3RhdGUuY29sb3IgPSB2YWx1ZXMuY29sb3I7XG4gICAgfVxuXG4gICAgaWYodmFsdWVzLmRpc3BsYXkpe1xuICAgICAgbmV3U3RhdGUuZGlzcGxheSA9IHZhbHVlcy5kaXNwbGF5O1xuICAgIH1cblxuICAgIGlmKHZhbHVlcy52YXJzKXtcbiAgICAgIHRoaXMudmFycyA9IHZhbHVlcy52YXJzO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lU3Bhbigpe1xuICAgIHJldHVybiB0aGlzLnJlc2l6aW5nVGltZVNwYW4gfHwgdGhpcy50aW1lU3BhbjtcbiAgfVxuXG4gIGdldCBuZXh0UG9zaXRpb24oKXtcbiAgICBpZih0aGlzLmRyYWdnaW5nUG9zaXRpb24pe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUlkOiB0aGlzLmRyYWdnaW5nUG9zaXRpb24ubGluZUlkLFxuICAgICAgICB0aW1lU3BhbjogdGhpcy50aW1lU3Bhbi5zaGlmdFN0YXJ0VGltZSh0aGlzLmRyYWdnaW5nUG9zaXRpb24udGltZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodGhpcy5yZXNpemluZ1RpbWVTcGFuKXtcbiAgICAgIHJldHVybntcbiAgICAgICAgbGluZUlkOiB0aGlzLmxpbmVJZCxcbiAgICAgICAgdGltZVNwYW46IHRoaXMucmVzaXppbmdUaW1lU3BhblxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IHByZXZQb3NpdGlvbigpe1xuICAgIGlmKCF0aGlzLmRyYWdnaW5nUG9zaXRpb24gJiYgIXRoaXMucmVzaXppbmdUaW1lU3Bhbil7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJue1xuICAgICAgICBsaW5lSWQ6IHRoaXMubGluZUlkLFxuICAgICAgICB0aW1lU3BhbjogdGhpcy50aW1lU3BhblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDku5bjga5FdmVudOOBqOmHjeOBquOBo+OBpuOBhOOBquOBhOOBi+ODgeOCp+ODg+OCr+OBmeOCi1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb3NpdGlvbiB7bGluZUlkOiAqKiosIHRpbWVTcGFuOiAqKip9XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZyZWVQb3NpdGlvbihwb3NpdGlvbil7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLnRpbWVsaW5lLmV2ZW50Q29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGV2ID0gdGhpcy5wcm9wcy50aW1lbGluZS5ldmVudENvbXBvbmVudHNbaV07XG4gICAgICBpZihldiA9PT0gdGhpcykgY29udGludWU7XG4gICAgICBpZihldi5saW5lSWQgIT0gcG9zaXRpb24ubGluZUlkKSBjb250aW51ZTtcbiAgICAgIGlmKGV2LmN1cnJlbnRUaW1lU3Bhbi5vdmVybGFwcyhwb3NpdGlvbi50aW1lU3Bhbikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBtb3ZlVG8odG9wLCBsZWZ0KXtcbiAgICB0aGlzLnNldFN0YXRlKHt0b3A6IHRvcCwgbGVmdDogbGVmdH0pO1xuICB9XG5cbiAgb25DbGljayhlKXtcbiAgICBpZih0aGlzLnByb3BzLnRpbWVsaW5lLnByb3BzLmV2ZW50RGlkQ2xpY2spe1xuICAgICAgaWYodGhpcy5yZXNpemluZyl7XG4gICAgICAgIHJldHVybiA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnREaWRDbGljayh7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgc2Nyb2xsVG9wOiB0aGlzLnByb3BzLnRpbWVsaW5lLmZyYW1lQ29tcG9uZW50LnJlZnMubGluZXNXcmFwcGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICBzY3JvbGxMZWZ0OiB0aGlzLnByb3BzLnRpbWVsaW5lLmZyYW1lQ29tcG9uZW50LmVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGUuY2xpZW50WSxcbiAgICAgICAgICBsZWZ0OiBlLmNsaWVudFgsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgbGluZUNvbXBvbmVudDogdGhpcy5wcm9wcy50aW1lbGluZS5saW5lQ29tcG9uZW50cy5maW5kKGxpbmVDb21wb25lbnQgPT4gbGluZUNvbXBvbmVudC5wcm9wcy5pZCA9PSB0aGlzLmxpbmVJZCksXG4gICAgICAgIGV2ZW50OiBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkcmFnZ2luZyh0aW1lLCBsaW5lSWQpe1xuICAgIHRoaXMuZHJhZ2dpbmdQb3NpdGlvbiA9IHt0aW1lOiB0aW1lLCBsaW5lSWQ6IGxpbmVJZH07XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZHJhZ2dpbmdEaXNwbGF5OiB0aW1lLmdldERpc3BsYXlUaW1lKCl9KTtcbiAgfVxuXG4gIHJlc2l6ZVVwKGUpe1xuICAgIHRoaXMucHJvcHMudGltZWxpbmUuZnJhbWVDb21wb25lbnQucmVzaXplVXAodGhpcywgZS5jbGllbnRZKTtcbiAgfVxuXG4gIHJlc2l6ZURvd24oZSl7XG4gICAgdGhpcy5wcm9wcy50aW1lbGluZS5mcmFtZUNvbXBvbmVudC5yZXNpemVEb3duKHRoaXMsIGUuY2xpZW50WSk7XG4gIH1cblxuICBlbmRSZXNpemluZyhlKXtcbiAgICBpZih0aGlzLnJlc2l6aW5nVGltZVNwYW4pe1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIGRyYWdnaW5nRGlzcGxheTogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdEaXNwbGF5VG9wOiBudWxsXG4gICAgICB9O1xuXG4gICAgICBpZih0aGlzLnJlc2l6aW5nVGltZVNwYW4pe1xuICAgICAgICBuZXdTdGF0ZS50b3AgPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVUb1RvcCh0aGlzLnJlc2l6aW5nVGltZVNwYW4uZ2V0U3RhcnRUaW1lKCkpO1xuICAgICAgICBuZXdTdGF0ZS5oZWlnaHQgPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVTcGFuVG9IZWlnaHQodGhpcy5yZXNpemluZ1RpbWVTcGFuKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH1cblxuICAgIC8vb25DbGlja+OCiOOCimVuZFJlc2l6aW5n44Gu5YWI44Gr55m655Sf44GX44Gm44GX44G+44GG44CCXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc2l6aW5nID0gZmFsc2UsIDEwMCk7XG4gIH1cblxuICBvbkNvbnRleHRNZW51KGUpe1xuICAgIGlmKHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnREaWRSaWdodENsaWNrKXtcbiAgICAgIHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnREaWRSaWdodENsaWNrKHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RHJhZ2dpbmdTdHlsZSgpe1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0LFxuICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXG4gICAgICB0b3A6IHRoaXMuc3RhdGUudG9wLFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLnN0YXRlLmNvbG9yLFxuICAgIH1cbiAgfVxuXG4gIGdldE9mZnNldCgpe1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHRoaXMuc3RhdGUudG9wLFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0XG4gICAgfVxuICB9XG5cbiAgc2V0Q29sb3IoY29sb3Ipe1xuICAgIHRoaXMuc2V0U3RhdGUoe2NvbG9yOiBjb2xvcn0pO1xuICB9XG5cbiAgc2V0RGlzcGxheShkaXNwbGF5KXtcbiAgICB0aGlzLnNldFN0YXRlKHtkaXNwbGF5OiBkaXNwbGF5fSk7XG4gIH1cblxuICByZXNpemUoKXtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHJlc2l6YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZmxvYXQoKXtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGRyYWdnaW5nRGlzcGxheTogdGhpcy50aW1lU3Bhbi5nZXRTdGFydFRpbWUoKS5nZXREaXNwbGF5VGltZSgpXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdnaW5nUG9zaXRpb24gPSB7dGltZTogdGhpcy50aW1lU3Bhbi5nZXRTdGFydFRpbWUoKSwgbGluZUlkOiB0aGlzLmxpbmVJZH07XG4gIH1cblxuICBpc0ZpeGVkKCl7XG4gICAgcmV0dXJuICF0aGlzLnN0YXRlLmRyYWdnYWJsZSAmJiAhdGhpcy5zdGF0ZS5yZXNpemFibGU7XG4gIH1cblxuICBpc0ZpeGFibGUoKXtcbiAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLm5leHRQb3NpdGlvbjtcbiAgICBpZighbmV3UG9zaXRpb24pe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNGcmVlUG9zaXRpb24obmV3UG9zaXRpb24pO1xuICB9XG5cbiAgaXNDYW5jZWxhYmxlKCl7XG4gICAgdmFyIG5ld1Bvc2l0aW9uID0gdGhpcy5wcmV2UG9zaXRpb247XG4gICAgaWYoIW5ld1Bvc2l0aW9uKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzRnJlZVBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcbiAgfVxuXG4gIGNhbmNlbCgpe1xuICAgIGlmKHRoaXMuZHJhZ2dpbmdQb3NpdGlvbil7XG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy5wcm9wcy50aW1lbGluZS5nZXRMaW5lTGVmdCh0aGlzLmxpbmVJZCk7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVUb1RvcCh0aGlzLnRpbWVTcGFuLmdldFN0YXJ0VGltZSgpKTtcbiAgICAgIHRoaXMuZHJhZ2dpbmdQb3NpdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dpbmdEaXNwbGF5OiAnJyxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZih0aGlzLnJlc2l6aW5nVGltZVNwYW4pe1xuICAgICAgY29uc3QgdG9wID0gdGhpcy5wcm9wcy50aW1lbGluZS50aW1lVG9Ub3AodGhpcy50aW1lU3Bhbi5nZXRTdGFydFRpbWUoKSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVTcGFuVG9IZWlnaHQodGhpcy50aW1lU3Bhbik7XG4gICAgICB0aGlzLnJlc2l6aW5nVGltZVNwYW4gPSBudWxsO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gICAgICAgIGRyYWdnaW5nRGlzcGxheTogJycsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICByZXNpemFibGU6IGZhbHNlLFxuICAgICAgICBkcmFnZ2luZ0Rpc3BsYXk6ICcnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLnRpbWVsaW5lLmNsZWFyRHJhZ2dpbmdPdmVyKCk7XG4gIH1cblxuICBnZXRNaW51dGUoKXtcbiAgICBpZih0aGlzLnRpbWVTcGFuKXtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVTcGFuLmdldERpc3RhbmNlKCk7XG4gICAgfSBlbHNlIGlmKHRoaXMucHJvcHMuZmxvYXQpe1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMucHJvcHMuZmxvYXQubWludXRlLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgZml4KCl7XG4gICAgaWYodGhpcy5kcmFnZ2luZ1Bvc2l0aW9uKXtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICB0b3A6IHRoaXMucHJvcHMudGltZWxpbmUudGltZVRvVG9wKHRoaXMuZHJhZ2dpbmdQb3NpdGlvbi50aW1lKSxcbiAgICAgICAgbGVmdDogdGhpcy5wcm9wcy50aW1lbGluZS5nZXRMaW5lTGVmdCh0aGlzLmRyYWdnaW5nUG9zaXRpb24ubGluZUlkKSxcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dpbmdEaXNwbGF5OiAnJ1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RpbWVTcGFuID0gdGhpcy50aW1lU3Bhbi5zaGlmdFN0YXJ0VGltZSh0aGlzLmRyYWdnaW5nUG9zaXRpb24udGltZSk7XG4gICAgICBpZih0aGlzLnByb3BzLnRpbWVsaW5lLnByb3BzLmV2ZW50V2lsbEZpeCl7XG4gICAgICAgIHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnRXaWxsRml4KHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgIGxpbmVJZDogdGhpcy5kcmFnZ2luZ1Bvc2l0aW9uLmxpbmVJZCxcbiAgICAgICAgICB0aW1lU3BhbjogbmV3VGltZVNwYW5cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgdGhpcy5saW5lSWQgPSB0aGlzLmRyYWdnaW5nUG9zaXRpb24ubGluZUlkO1xuICAgICAgdGhpcy50aW1lU3BhbiA9IG5ld1RpbWVTcGFuO1xuICAgICAgdGhpcy5kcmFnZ2luZ1Bvc2l0aW9uID0gbnVsbDtcbiAgICB9IGVsc2UgaWYodGhpcy5yZXNpemluZ1RpbWVTcGFuKXtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICByZXNpemFibGU6IGZhbHNlLFxuICAgICAgICBkcmFnZ2luZ0Rpc3BsYXk6ICcnXG4gICAgICB9XG4gICAgICBpZih0aGlzLnByb3BzLnRpbWVsaW5lLnByb3BzLmV2ZW50V2lsbEZpeCl7XG4gICAgICAgIHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnRXaWxsRml4KHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgIGxpbmVJZDogdGhpcy5saW5lSWQsXG4gICAgICAgICAgdGltZVNwYW46IHRoaXMucmVzaXppbmdUaW1lU3BhblxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICB0aGlzLnRpbWVTcGFuID0gdGhpcy5yZXNpemluZ1RpbWVTcGFuO1xuICAgICAgdGhpcy5yZXNpemluZ1RpbWVTcGFuID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gICAgICAgIGRyYWdnaW5nRGlzcGxheTogJydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMudGltZWxpbmUuY2xlYXJEcmFnZ2luZ092ZXIoKTtcbiAgICBpZih0aGlzLnByb3BzLnRpbWVsaW5lLnByb3BzLmV2ZW50RGlkRml4KXtcbiAgICAgIHRoaXMucHJvcHMudGltZWxpbmUucHJvcHMuZXZlbnREaWRGaXgoe1xuICAgICAgICBjb21wb25lbnQ6IHRoaXNcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc2V0VmFyKGtleSwgdmFsdWUpe1xuICAgIHRoaXMudmFyc1trZXldID0gdmFsdWU7XG4gIH1cblxuICBnZXRWYXIoa2V5KXtcbiAgICByZXR1cm4gdGhpcy52YXJzW2tleV07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpe1xuICAgIHRoaXMucHJvcHMudGltZWxpbmUuZXZlbnRDb21wb25lbnRzLnB1c2godGhpcylcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgdGhpcy5wcm9wcy50aW1lbGluZS5ldmVudENvbXBvbmVudHMgPSB0aGlzLnByb3BzLnRpbWVsaW5lLmV2ZW50Q29tcG9uZW50cy5maWx0ZXIoZXYgPT4gZXYgIT09IHRoaXMpXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcyl7XG4gICAgaWYodGhpcy5pc0ZpeGVkKCkpe1xuICAgICAgaWYobmV4dFByb3BzLmFjdGlvbiA9PSAnZmxvYXQnKXtcbiAgICAgICAgdGhpcy5mbG9hdCgpXG4gICAgICB9IGVsc2UgaWYobmV4dFByb3BzLmFjdGlvbiA9PSAncmVzaXplJyl7XG4gICAgICAgIHRoaXMucmVzaXplKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYobmV4dFByb3BzLmFjdGlvbiA9PSAnZml4Jyl7XG4gICAgICAgIHRoaXMuZml4KClcbiAgICAgIH0gZWxzZSBpZihuZXh0UHJvcHMuYWN0aW9uID09ICdjYW5jZWwnKXtcbiAgICAgICAgdGhpcy5jYW5jZWwoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvcnJlY3RQb3NpdGlvbigpe1xuICAgIGlmKHRoaXMuc3RhdGUuZHJhZ2dhYmxlKXtcbiAgICAgIGNvbnN0IG5ld1BvcyA9IHt9XG4gICAgICAvLyBsaW5l44KS54m55a6a44GZ44KLXG4gICAgICB2YXIgbGluZSA9IHRoaXMucHJvcHMudGltZWxpbmUuZmluZExpbmVCeUxlZnQodGhpcy5zdGF0ZS5sZWZ0KVxuICAgICAgLy8g44Gv44G/5Ye644Gm44Gf44KJ56e75YuVXG4gICAgICBpZighbGluZSl7XG4gICAgICAgIGxpbmUgPSB0aGlzLnByb3BzLnRpbWVsaW5lLmxhc3RMaW5lXG4gICAgICAgIG5ld1Bvcy5sZWZ0ID0gdGhpcy5wcm9wcy50aW1lbGluZS5nZXRMaW5lTGVmdChsaW5lLnByb3BzLmlkKVxuICAgICAgfVxuXG4gICAgICBpZihsaW5lKXtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1Bvc2l0aW9uLmxpbmVJZCA9IGxpbmUucHJvcHMuaWRcbiAgICAgIH1cblxuICAgICAgLy8g6auY44GV44GM44Gv44G/5Ye644Gm44Gq44GE44GL44OB44Kn44OD44KvXG4gICAgICBjb25zdCBib3R0b20gPSB0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVUb1RvcCh0aGlzLnByb3BzLnRpbWVsaW5lLnRpbWVTcGFuLmdldEVuZFRpbWUoKSkgLSB0aGlzLnN0YXRlLmhlaWdodFxuICAgICAgaWYodGhpcy5zdGF0ZS50b3AgPiBib3R0b20pe1xuICAgICAgICBuZXdQb3MudG9wID0gYm90dG9tXG5cbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMucHJvcHMudGltZWxpbmUudG9wVG9UaW1lKG5ld1Bvcy50b3ApXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdQb3NpdGlvbi50aW1lID0gdGltZVxuICAgICAgICBuZXdQb3MuZHJhZ2dpbmdEaXNwbGF5ID0gdGltZS5nZXREaXNwbGF5VGltZSgpXG4gICAgICAgIHRoaXMudGltZVNwYW4gPSBuZXcgVGltZVNwYW4odGltZSwgdGltZS5hZGRNaW4odGhpcy50aW1lU3Bhbi5nZXREaXN0YW5jZSgpKSlcbiAgICAgIH1cblxuICAgICAgaWYoT2JqZWN0LmtleXMobmV3UG9zKS5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1BvcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogdGhpcy5zdGF0ZS50b3AgKyAncHgnLFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0ICsgJ3B4JyxcbiAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoICsgJ3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5zdGF0ZS5jb2xvcixcbiAgICAgIGRpc3BsYXk6IHRoaXMucHJvcHMuaXNEcmFnZ2luZyA/ICdub25lJyA6ICdibG9jaydcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY29ubmVjdERyYWdTb3VyY2UoXG4gICAgICA8ZGl2IGRhdGEtaWQ9e3RoaXMucHJvcHMuaWR9IHJlZj17ZWxlbSA9PiB0aGlzLmVsZW1lbnQgPSBlbGVtfSBvbkNvbnRleHRNZW51PXtlID0+IHRoaXMub25Db250ZXh0TWVudShlKX0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKCd0bEV2ZW50VmlldycsIHt0bERyYWdnaW5nRXZlbnQ6IHRoaXMuc3RhdGUuZHJhZ2dhYmxlLCB0bFJlc2l6YWJsZUV2ZW50OiB0aGlzLnN0YXRlLnJlc2l6YWJsZX0pfSBzdHlsZT17c3R5bGV9IG9uQ2xpY2s9e2UgPT4gdGhpcy5vbkNsaWNrKGUpfT5cbiAgICAgICAgeygoKSA9PiB7XG4gICAgICAgICAgaWYodGhpcy5zdGF0ZS5yZXNpemFibGUpe1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0bFJlc2l6ZUhhbmRsZVwiIG9uVG91Y2hTdGFydD17ZSA9PiB0aGlzLnJlc2l6ZVVwKGUpfSBvbk1vdXNlRG93bj17ZSA9PiB0aGlzLnJlc2l6ZVVwKGUpfT5cbiAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS1iYXJzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgICAgIDxFdmVudEJhc2VcbiAgICAgICAgICBkcmFnZ2luZ0Rpc3BsYXk9e3RoaXMuc3RhdGUuZHJhZ2dpbmdEaXNwbGF5fVxuICAgICAgICAgIGRyYWdnaW5nRGlzcGxheVRvcD17dGhpcy5zdGF0ZS5kcmFnZ2luZ0Rpc3BsYXlUb3B9XG4gICAgICAgICAgZGlzcGxheT17dGhpcy5zdGF0ZS5kaXNwbGF5fVxuICAgICAgICAgIHRpbWVsaW5lPXt0aGlzLnByb3BzLnRpbWVsaW5lfVxuICAgICAgICAvPlxuICAgICAgICB7KCgpID0+IHtcbiAgICAgICAgICBpZih0aGlzLnN0YXRlLnJlc2l6YWJsZSl7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRsUmVzaXplSGFuZGxlIHRsQm90dG9tXCIgb25Ub3VjaFN0YXJ0PXtlID0+IHRoaXMucmVzaXplRG93bihlKX0gb25Nb3VzZURvd249e2UgPT4gdGhpcy5yZXNpemVEb3duKGUpfT5cbiAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS1iYXJzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkV2ZW50LmRlZmF1bHRQcm9wcyA9IHtcbiAgZGlzcGxheTogW11cbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdTb3VyY2UoXCJFdmVudFwiLCBzb3VyY2UsIGNvbGxlY3QpKEV2ZW50KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL0V2ZW50LmpzeFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0V2ZW50LmpzeCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7VGltZWxpbmUsIFRpbWUsIFRpbWVTcGFufSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgaW5pdGlhbEV2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnQGdvbW8vcmVhY3QtY29udGV4dC1tZW51JztcblxuY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG57XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy4kd3JhcHBlciA9ICQoJyNhcHAnKVxuICAgIHRoaXMuZXZlbnRNZW51ID0gbnVsbFxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsaW5lczogW1xuICAgICAgICB7bGFiZWw6J2xhYmVsMScsIGlkOidfXzEnfSxcbiAgICAgICAge2xhYmVsOidsYWJlbDInLCBpZDonX18yJ30sXG4gICAgICAgIHtsYWJlbDonbGFiZWwzJywgaWQ6J19fMyd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsNCcsIGlkOidfXzQnfSxcbiAgICAgICAge2xhYmVsOidsYWJlbDUnLCBpZDonX181J30sXG4gICAgICAgIHtsYWJlbDonbGFiZWw2JywgaWQ6J19fNid9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsNycsIGlkOidfXzcnfSxcbiAgICAgICAge2xhYmVsOidsYWJlbDgnLCBpZDonX184J30sXG4gICAgICAgIHtsYWJlbDonbGFiZWw5JywgaWQ6J19fOSd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTAnLCBpZDonX18xMCd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTEnLCBpZDonX18xMSd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTInLCBpZDonX18xMid9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTMnLCBpZDonX18xMyd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTQnLCBpZDonX18xNCd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTUnLCBpZDonX18xNSd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTYnLCBpZDonX18xNid9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTcnLCBpZDonX18xNyd9LFxuICAgICAgICB7bGFiZWw6J2xhYmVsMTgnLCBpZDonX18xOCd9XG4gICAgICBdLFxuICAgICAgZXZlbnRzOiBpbml0aWFsRXZlbnRzLFxuICAgICAgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTAsIDBdLCBbMjUsIDBdKSxcbiAgICAgIGhlaWdodDogdGhpcy5jYWxjSGVpZ2h0KClcbiAgICB9XG5cbiAgICB3aW5kb3cub25yZXNpemUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtoZWlnaHQ6IHRoaXMuY2FsY0hlaWdodCgpfSlcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RMaW5lSWQgPSAxOFxuICB9XG5cbiAgY2FsY0hlaWdodCgpe1xuICAgIGNvbnN0IHdyYXBwZXJCb3VuZHMgPSB0aGlzLiR3cmFwcGVyLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gdGhpcy5nZXRXaW5kb3dTaXplKCk7XG4gICAgcmV0dXJuIHdpbmRvd1NpemUuaGVpZ2h0IC0gd3JhcHBlckJvdW5kcy50b3A7XG4gIH1cblxuICBnZXRXaW5kb3dTaXplKCl7XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG4gIFxuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbiAgXG4gICAgcmV0dXJuIHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fTtcbiAgfVxuXG4gIGdlbmVyYXRlRXZlbnRJZCgpe1xuICAgIHRoaXMubGFzdEV2ZW50SWQgPSB0aGlzLmxhc3RFdmVudElkfHwwXG4gICAgdGhpcy5sYXN0RXZlbnRJZCArPSAxXG4gICAgcmV0dXJuICduZXdfJyArIHRoaXMubGFzdEV2ZW50SWRcbiAgfVxuXG4gIGFkZEV2ZW50KGRhdGEpe1xuICAgIHRoaXMuc2V0U3RhdGUoe2V2ZW50czogWy4uLnRoaXMuc3RhdGUuZXZlbnRzLCB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUV2ZW50SWQoKSxcbiAgICAgIGxpbmVJZDogZGF0YS5jb21wb25lbnQucHJvcHMuaWQsXG4gICAgICB0aW1lU3BhbjogbmV3IFRpbWVTcGFuKGRhdGEudGltZSwgZGF0YS50aW1lLmFkZE1pbig2MCkpLFxuICAgICAgY29sb3I6ICcjRkZEQ0I2JyxcbiAgICAgIGRpc3BsYXk6IFtcbiAgICAgICAge2tleTogJ3N0YXJ0VGltZScsIHZhbHVlOiBkYXRhLnRpbWUuZ2V0RGlzcGxheVRpbWUoKX1cbiAgICAgIF1cbiAgICB9XX0pXG4gIH1cblxuICBmbG9hdEV2ZW50KGNvbnRleHQpe1xuICAgIHRoaXMuc2V0QWN0aW9uVG9FdmVudChjb250ZXh0LmNvbXBvbmVudC5wcm9wcy5pZCwgJ2Zsb2F0JylcbiAgfVxuXG4gIHJlc2l6ZUV2ZW50KGNvbnRleHQpe1xuICAgIHRoaXMuc2V0QWN0aW9uVG9FdmVudChjb250ZXh0LmNvbXBvbmVudC5wcm9wcy5pZCwgJ3Jlc2l6ZScpXG4gIH1cblxuICBjYW5jZWxFdmVudChjb250ZXh0KXtcbiAgICB0aGlzLnNldEFjdGlvblRvRXZlbnQoY29udGV4dC5jb21wb25lbnQucHJvcHMuaWQsICdjYW5jZWwnKVxuICB9XG5cbiAgZml4RXZlbnQoY29udGV4dCl7XG4gICAgdGhpcy5zZXRBY3Rpb25Ub0V2ZW50KGNvbnRleHQuY29tcG9uZW50LnByb3BzLmlkLCAnZml4JylcbiAgfVxuXG4gIHNldEFjdGlvblRvRXZlbnQoZXZlbnRJZCwgYWN0aW9uKXtcbiAgICB0aGlzLnNldFN0YXRlKHtldmVudHM6IHRoaXMuc3RhdGUuZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICBpZihldmVudC5pZCA9PSBldmVudElkKXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZXZlbnQsIHthY3Rpb246IGFjdGlvbn0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXZlbnRcbiAgICAgIH1cbiAgICB9KX0pXG4gIH1cblxuICBhZGRMaW5lKCl7XG4gICAgKyt0aGlzLmxhc3RMaW5lSWRcbiAgICB0aGlzLnNldFN0YXRlKHtsaW5lczogWy4uLnRoaXMuc3RhdGUubGluZXMsIHtcbiAgICAgIGxhYmVsOidsYWJlbCcgKyB0aGlzLmxhc3RMaW5lSWQsIGlkOidfXycgKyB0aGlzLmxhc3RMaW5lSWRcbiAgICB9XX0pXG4gIH1cblxuICByZW1vdmVMaW5lKGlkKXtcbiAgICB0aGlzLnNldFN0YXRlKHtsaW5lczogdGhpcy5zdGF0ZS5saW5lcy5maWx0ZXIobGluZSA9PiBsaW5lLmlkICE9IGlkKX0pXG4gIH1cblxuICByZW1vdmVFdmVudChpZCl7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZXZlbnRzOiB0aGlzLnN0YXRlLmV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gZXZlbnQuaWQgIT0gaWQpfSlcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8ZGl2IHN0eWxlPXt7bWFyZ2luQm90dG9tOiAnMjBweCd9fT5cbiAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHRoaXMuYWRkTGluZSgpfT5MSU5F44KS6L+95YqgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8Q29udGV4dE1lbnVcbiAgICAgICAgICByZWY9e21lbnUgPT4gdGhpcy5ldmVudE1lbnUgPSBtZW51fVxuICAgICAgICAgIGl0ZW1zPXtbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IGNvbnRleHQgPT4gJ2Zsb2F0JyxcbiAgICAgICAgICAgICAgb25DbGljazogY29udGV4dCA9PiB0aGlzLmZsb2F0RXZlbnQoY29udGV4dCksXG4gICAgICAgICAgICAgIHNob3c6IGNvbnRleHQgPT4gY29udGV4dC5jb21wb25lbnQuY29uc3RydWN0b3IubmFtZSA9PSAnRXZlbnQnICYmIGNvbnRleHQuY29tcG9uZW50LmlzRml4ZWQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogY29udGV4dCA9PiAncmVzaXplJyxcbiAgICAgICAgICAgICAgb25DbGljazogY29udGV4dCA9PiB0aGlzLnJlc2l6ZUV2ZW50KGNvbnRleHQpLFxuICAgICAgICAgICAgICBzaG93OiBjb250ZXh0ID0+IGNvbnRleHQuY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0V2ZW50JyAmJiBjb250ZXh0LmNvbXBvbmVudC5pc0ZpeGVkKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IGNvbnRleHQgPT4gJ2NhbmNlbCcsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IGNvbnRleHQgPT4gdGhpcy5jYW5jZWxFdmVudChjb250ZXh0KSxcbiAgICAgICAgICAgICAgc2hvdzogY29udGV4dCA9PiBjb250ZXh0LmNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lID09ICdFdmVudCcgJiYgIWNvbnRleHQuY29tcG9uZW50LmlzRml4ZWQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogY29udGV4dCA9PiAnZml4JyxcbiAgICAgICAgICAgICAgb25DbGljazogY29udGV4dCA9PiB0aGlzLmZpeEV2ZW50KGNvbnRleHQpLFxuICAgICAgICAgICAgICBzaG93OiBjb250ZXh0ID0+IGNvbnRleHQuY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0V2ZW50JyAmJiAhY29udGV4dC5jb21wb25lbnQuaXNGaXhlZCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBjb250ZXh0ID0+ICctJyxcbiAgICAgICAgICAgICAgc2hvdzogY29udGV4dCA9PiBjb250ZXh0LmNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lID09ICdFdmVudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBjb250ZXh0ID0+ICdyZW1vdmUnLFxuICAgICAgICAgICAgICBvbkNsaWNrOiBjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lbGluZSA9IGNvbnRleHQuY29tcG9uZW50LnByb3BzLnRpbWVsaW5lXG4gICAgICAgICAgICAgICAgaWYoY29udGV4dC5jb21wb25lbnQuY29uc3RydWN0b3IubmFtZSA9PSAnTGluZScpe1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaW5lKGNvbnRleHQuY29tcG9uZW50LnByb3BzLmlkKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KGNvbnRleHQuY29tcG9uZW50LnByb3BzLmlkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZW5hYmxlOiBjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lbGluZSA9IGNvbnRleHQuY29tcG9uZW50LnByb3BzLnRpbWVsaW5lXG4gICAgICAgICAgICAgICAgaWYoY29udGV4dC5jb21wb25lbnQuY29uc3RydWN0b3IubmFtZSA9PSAnTGluZScpe1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRpbWVsaW5lLmdldEV2ZW50c09uTGluZShjb250ZXh0LmNvbXBvbmVudC5wcm9wcy5pZClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudHMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudC5pc0ZpeGVkKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdfVxuICAgICAgICAgIHpJbmRleD17MTAwMH1cbiAgICAgICAgLz5cbiAgICAgICAgPFRpbWVsaW5lXG4gICAgICAgICAgbGluZURhdGE9e3RoaXMuc3RhdGUubGluZXN9XG4gICAgICAgICAgdGltZVNwYW49e3RoaXMuc3RhdGUudGltZVNwYW59XG4gICAgICAgICAgZXZlbnRzPXt0aGlzLnN0YXRlLmV2ZW50c31cbiAgICAgICAgICBsaW5lV2lkdGg9ezYyfVxuICAgICAgICAgIG1pbkhlaWdodD17MTd9XG4gICAgICAgICAgbWluSW50ZXJ2YWw9ezV9XG4gICAgICAgICAgcnVsZXJJbnRlcnZhbD17NH1cbiAgICAgICAgICBoZWlnaHQ9e3RoaXMuc3RhdGUuaGVpZ2h0fVxuICAgICAgICAgIGxpbmVEaWRDbGljaz17ZGF0YSA9PiB0aGlzLmFkZEV2ZW50KGRhdGEpfVxuICAgICAgICAgIGxpbmVEaWRSaWdodENsaWNrPXtkYXRhID0+IHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNZW51LnNob3coe3RvcDogZGF0YS5ldmVudC5jbGllbnRZLCBsZWZ0OiBkYXRhLmV2ZW50LmNsaWVudFh9LCBkYXRhKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGV2ZW50RGlkQ2xpY2s9e2RhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2xlZnQnLCBkYXRhKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGV2ZW50RGlkUmlnaHRDbGljaz17ZGF0YSA9PiB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWVudS5zaG93KHt0b3A6IGRhdGEuZXZlbnQuY2xpZW50WSwgbGVmdDogZGF0YS5ldmVudC5jbGllbnRYfSwgZGF0YSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBldmVudFdpbGxGaXg9e2RhdGEgPT4ge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSBkYXRhLmNvbXBvbmVudC5zdGF0ZS5kaXNwbGF5LmZpbHRlcihyb3cgPT4gcm93LmtleSAhPSAnc3RhcnRUaW1lJyk7XG4gICAgICAgICAgICBkaXNwbGF5LnB1c2goe2tleTogJ3N0YXJ0VGltZScsIHZhbHVlOiBkYXRhLnRpbWVTcGFuLmdldFN0YXJ0VGltZSgpLmdldERpc3BsYXlUaW1lKCl9KVxuICAgICAgICAgICAgZGF0YS5zdGF0ZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGV2ZW50RGlkRml4PXtkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbiQoKCkgPT4ge1xuICBSZWFjdERPTS5yZW5kZXIoPEFwcCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2V4YW1wbGUvYXBwLmpzeCIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJSZWFjdERPTVwiXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtUaW1lbGluZSwgVGltZSwgVGltZVNwYW59IGZyb20gJy4uL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgW1xuICB7aWQ6ICcxMjMxJywgbGluZUlkOiAnX18xJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTIsIDMwXSwgWzEzLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI0MScsIGxpbmVJZDogJ19fMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MScsIGxpbmVJZDogJ19fMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE3LCAwXSwgWzE4LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI2MScsIGxpbmVJZDogJ19fMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE4LCAzMF0sIFsxOSwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNzEnLCBsaW5lSWQ6ICdfXzEnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxJywgbGluZUlkOiAnX18xJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMjAsIDMwXSwgWzIxLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI5MScsIGxpbmVJZDogJ19fMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzIyLCAzMF0sIFsyMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG5cbiAge2lkOiAnMTIzJywgbGluZUlkOiAnX18yJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTIsIDMwXSwgWzEzLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI0JywgbGluZUlkOiAnX18yJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTQsIDBdLCBbMTYsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjUnLCBsaW5lSWQ6ICdfXzInLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNywgMF0sIFsxOCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG5cbiAge2lkOiAnMTIzMycsIGxpbmVJZDogJ19fMycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDMnLCBsaW5lSWQ6ICdfXzMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNCwgMF0sIFsxNiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNTMnLCBsaW5lSWQ6ICdfXzMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNywgMF0sIFsxOCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG5cbiAge2lkOiAnMTIzNCcsIGxpbmVJZDogJ19fNCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDQnLCBsaW5lSWQ6ICdfXzQnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNCwgMF0sIFsxNiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNTQnLCBsaW5lSWQ6ICdfXzQnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNywgMF0sIFsxOCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG5cbiAge2lkOiAnMTIzNTUnLCBsaW5lSWQ6ICdfXzUnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxMiwgMzBdLCBbMTMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjQ1NScsIGxpbmVJZDogJ19fNScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1NTUnLCBsaW5lSWQ6ICdfXzUnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNywgMF0sIFsxOCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG5cbiAge2lkOiAnMTIyNicsIGxpbmVJZDogJ19fNicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzYnLCBsaW5lSWQ6ICdfXzYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxMiwgMzBdLCBbMTMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjQ2JywgbGluZUlkOiAnX182JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTQsIDBdLCBbMTYsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjU2JywgbGluZUlkOiAnX182JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjY2JywgbGluZUlkOiAnX182JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTgsIDMwXSwgWzE5LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI3NicsIGxpbmVJZDogJ19fNicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE5LCAzMF0sIFsyMCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyODYnLCBsaW5lSWQ6ICdfXzYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjk2JywgbGluZUlkOiAnX182JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMjIsIDMwXSwgWzIzLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcblxuICB7aWQ6ICcxMjM3NycsIGxpbmVJZDogJ19fNycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDc3JywgbGluZUlkOiAnX183JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTQsIDBdLCBbMTYsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjU3NycsIGxpbmVJZDogJ19fNycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE3LCAwXSwgWzE4LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcblxuICB7aWQ6ICcxMjI4JywgbGluZUlkOiAnX184JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTEsIDE1XSwgWzEyLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTIzOCcsIGxpbmVJZDogJ19fOCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDgnLCBsaW5lSWQ6ICdfXzgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNCwgMF0sIFsxNiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNTgnLCBsaW5lSWQ6ICdfXzgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxNywgMF0sIFsxOCwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNjgnLCBsaW5lSWQ6ICdfXzgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjc4JywgbGluZUlkOiAnX184JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTksIDMwXSwgWzIwLCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI4OCcsIGxpbmVJZDogJ19fOCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzIwLCAzMF0sIFsyMSwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyOTgnLCBsaW5lSWQ6ICdfXzgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMzknLCBsaW5lSWQ6ICdfXzknLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxMiwgMzBdLCBbMTMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjQ5JywgbGluZUlkOiAnX185JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTQsIDBdLCBbMTYsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjU5JywgbGluZUlkOiAnX185JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMjEwJywgbGluZUlkOiAnX18xMCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzEwJywgbGluZUlkOiAnX18xMCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDEwJywgbGluZUlkOiAnX18xMCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTAnLCBsaW5lSWQ6ICdfXzEwJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjYxMCcsIGxpbmVJZDogJ19fMTAnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjcxMCcsIGxpbmVJZDogJ19fMTAnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxMCcsIGxpbmVJZDogJ19fMTAnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjkxMCcsIGxpbmVJZDogJ19fMTAnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMzExJywgbGluZUlkOiAnX18xMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDExJywgbGluZUlkOiAnX18xMScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTEnLCBsaW5lSWQ6ICdfXzExJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMzEyJywgbGluZUlkOiAnX18xMicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDEyJywgbGluZUlkOiAnX18xMicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTInLCBsaW5lSWQ6ICdfXzEyJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMjEzJywgbGluZUlkOiAnX18xMycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzEzJywgbGluZUlkOiAnX18xMycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDEzJywgbGluZUlkOiAnX18xMycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTMnLCBsaW5lSWQ6ICdfXzEzJywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjYxMycsIGxpbmVJZDogJ19fMTMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjcxMycsIGxpbmVJZDogJ19fMTMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxMycsIGxpbmVJZDogJ19fMTMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjkxMycsIGxpbmVJZDogJ19fMTMnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMzE0JywgbGluZUlkOiAnX18xNCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDE0JywgbGluZUlkOiAnX18xNCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTQnLCBsaW5lSWQ6ICdfXzE0JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMzE1JywgbGluZUlkOiAnX18xNScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDE1JywgbGluZUlkOiAnX18xNScsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTUnLCBsaW5lSWQ6ICdfXzE1JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMjE2JywgbGluZUlkOiAnX18xNicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzE2JywgbGluZUlkOiAnX18xNicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDE2JywgbGluZUlkOiAnX18xNicsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTYnLCBsaW5lSWQ6ICdfXzE2JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjYxNicsIGxpbmVJZDogJ19fMTYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjcxNicsIGxpbmVJZDogJ19fMTYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxNicsIGxpbmVJZDogJ19fMTYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjkxNicsIGxpbmVJZDogJ19fMTYnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMjE3JywgbGluZUlkOiAnX18xNycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzE3JywgbGluZUlkOiAnX18xNycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDE3JywgbGluZUlkOiAnX18xNycsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTcnLCBsaW5lSWQ6ICdfXzE3JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjYxNycsIGxpbmVJZDogJ19fMTcnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjcxNycsIGxpbmVJZDogJ19fMTcnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxNycsIGxpbmVJZDogJ19fMTcnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjkxNycsIGxpbmVJZDogJ19fMTcnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuXG4gIHtpZDogJzEyMjE4JywgbGluZUlkOiAnX18xOCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzExLCAxNV0sIFsxMiwgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyMzE4JywgbGluZUlkOiAnX18xOCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzEyLCAzMF0sIFsxMywgMzBdKSwgY29sb3I6ICcjRkZEQ0I2J30sXG4gIHtpZDogJzEyNDE4JywgbGluZUlkOiAnX18xOCcsIHRpbWVTcGFuOiBUaW1lU3Bhbi5jcmVhdGUoWzE0LCAwXSwgWzE2LCAzMF0pLCBjb2xvcjogJyNGRkRDQjYnfSxcbiAge2lkOiAnMTI1MTgnLCBsaW5lSWQ6ICdfXzE4JywgdGltZVNwYW46IFRpbWVTcGFuLmNyZWF0ZShbMTcsIDBdLCBbMTgsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjYxOCcsIGxpbmVJZDogJ19fMTgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOCwgMzBdLCBbMTksIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjcxOCcsIGxpbmVJZDogJ19fMTgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsxOSwgMzBdLCBbMjAsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjgxOCcsIGxpbmVJZDogJ19fMTgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMCwgMzBdLCBbMjEsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7aWQ6ICcxMjkxOCcsIGxpbmVJZDogJ19fMTgnLCB0aW1lU3BhbjogVGltZVNwYW4uY3JlYXRlKFsyMiwgMzBdLCBbMjMsIDMwXSksIGNvbG9yOiAnI0ZGRENCNid9LFxuICB7XG4gICAgaWQ6ICdmbG9hdDEnLFxuICAgIGNvbG9yOiAnI0ZGQjZCNicsXG4gICAgZmxvYXQ6IHt0b3A6IDEwLCBsZWZ0OiAxMCwgbWludXRlOiA2MH1cbiAgfSxcbiAge1xuICAgIGlkOiAnZmxvYXQyJyxcbiAgICBjb2xvcjogJyNGRkI2QjYnLFxuICAgIGZsb2F0OiB7dG9wOiAxMDAwMCwgbGVmdDogMTAwMDAsIG1pbnV0ZTogNjB9XG4gIH1cbl1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9leGFtcGxlL2V2ZW50cy5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSwgcmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIiwgXCJjbGFzc25hbWVzXCIsIFwicHJvcC10eXBlc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpLCByZXF1aXJlKFwicHJvcC10eXBlc1wiKSkgOiBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcImNsYXNzTmFtZXNcIl0sIHJvb3RbXCJQcm9wVHlwZXNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbnRleHRNZW51ID0gdW5kZWZpbmVkO1xuXG52YXIgX0NvbnRleHRNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9Db250ZXh0TWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250ZXh0TWVudSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuQ29udGV4dE1lbnUgPSBfQ29udGV4dE1lbnUyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfQ29udGV4dE1lbnUyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIF9Db250ZXh0TWVudUl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX0NvbnRleHRNZW51SXRlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250ZXh0TWVudUl0ZW0pO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbnRleHRNZW51ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKENvbnRleHRNZW51LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBfY3JlYXRlQ2xhc3MoQ29udGV4dE1lbnUsIG51bGwsIFt7XG4gICAga2V5OiAnZ2V0V2luZG93U2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpbmRvd1NpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcblxuICAgICAgdmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xuXG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gQ29udGV4dE1lbnUocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGV4dE1lbnUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbnRleHRNZW51Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udGV4dE1lbnUpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICAgIHpJbmRleDogX3RoaXMucHJvcHMuekluZGV4XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpcy5vdmVybGF5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncm1NZW51T3ZlcmxheScpO1xuICAgIF90aGlzLm92ZXJsYXkuc3R5bGVbXCJwb3NpdGlvblwiXSA9ICdhYnNvbHV0ZSc7XG4gICAgX3RoaXMub3ZlcmxheS5zdHlsZVtcInRvcFwiXSA9ICcwJztcbiAgICBfdGhpcy5vdmVybGF5LnN0eWxlW1wibGVmdFwiXSA9ICcwJztcbiAgICBfdGhpcy5vdmVybGF5LnN0eWxlW1wiZGlzcGxheVwiXSA9ICdub25lJztcbiAgICBfdGhpcy5vdmVybGF5LnN0eWxlW1wiekluZGV4XCJdID0gX3RoaXMucHJvcHMuekluZGV4IC0gMTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF90aGlzLm92ZXJsYXkpO1xuICAgIF90aGlzLm92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgX3RoaXMub3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb250ZXh0TWVudSwgW3tcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhwb3MsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3R5bGU6ICgwLCBfb2JqZWN0QXNzaWduMi5kZWZhdWx0KSh7fSwgdGhpcy5zdGF0ZS5zdHlsZSwgcG9zLCB7IGRpc3BsYXk6ICdibG9jaycgfSksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSBDb250ZXh0TWVudS5nZXRXaW5kb3dTaXplKCk7XG4gICAgICAgIF90aGlzMi5vdmVybGF5LnN0eWxlW1wid2lkdGhcIl0gPSB3aW5kb3dTaXplLndpZHRoICsgJ3B4JztcbiAgICAgICAgX3RoaXMyLm92ZXJsYXkuc3R5bGVbXCJoZWlnaHRcIl0gPSB3aW5kb3dTaXplLmhlaWdodCArICdweCc7XG4gICAgICAgIF90aGlzMi5vdmVybGF5LnN0eWxlWydkaXNwbGF5J10gPSAnYmxvY2snO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZU91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VPdXQoKSB7XG4gICAgICBjb25zb2xlLmxvZygnb3V0Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZU92ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlT3ZlcigpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdvdmVyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgc3R5bGU6ICgwLCBfb2JqZWN0QXNzaWduMi5kZWZhdWx0KSh7fSwgdGhpcy5zdGF0ZS5zdHlsZSwgeyBkaXNwbGF5OiAnbm9uZScgfSkgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMub3ZlcmxheS5zdHlsZVsnZGlzcGxheSddID0gJ25vbmUnO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgcmVmOiAnbWVudScsIGNsYXNzTmFtZTogJ3JtTWVudScsIHN0eWxlOiB0aGlzLnN0YXRlLnN0eWxlIH0sXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd1bCcsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdybU1lbnVJdGVtTGlzdCcgfSxcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPyB0aGlzLnByb3BzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc2hvdyB8fCBpdGVtLnNob3coX3RoaXM0LnN0YXRlLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfQ29udGV4dE1lbnVJdGVtMi5kZWZhdWx0LCB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lKF90aGlzNC5zdGF0ZS5jb250ZXh0KSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBpdGVtLm9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgbWVudTogX3RoaXM0LFxuICAgICAgICAgICAgICAgIGVuYWJsZTogaXRlbS5lbmFibGUgPyBpdGVtLmVuYWJsZShfdGhpczQuc3RhdGUuY29udGV4dCkgOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pIDogbnVsbFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb250ZXh0TWVudTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRleHRNZW51O1xuXG5cbkNvbnRleHRNZW51LnByb3BUeXBlcyA9IHtcbiAgaXRlbXM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBuYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgc2hvdzogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICAgIGVuYWJsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jXG4gIH0pKS5pc1JlcXVpcmVkLFxuICB6SW5kZXg6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyXG59O1xuXG5Db250ZXh0TWVudS5kZWZhdWx0UHJvcHMgPSB7XG4gIHpJbmRleDogMTAwXG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbnRleHRNZW51SXRlbSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDb250ZXh0TWVudUl0ZW0sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENvbnRleHRNZW51SXRlbShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0TWVudUl0ZW0pO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbnRleHRNZW51SXRlbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnRleHRNZW51SXRlbSkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgbW91c2VPdmVyOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRleHRNZW51SXRlbSwgW3tcbiAgICBrZXk6ICdvbk1vdXNlT3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU91dCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbW91c2VPdmVyOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1vdXNlT3ZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VPdmVyKCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb3VzZU92ZXI6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayh0aGlzLnByb3BzLm1lbnUuc3RhdGUuY29udGV4dCk7XG4gICAgICAgIHRoaXMucHJvcHMubWVudS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczIuZGVmYXVsdCkoXCJybU1lbnVJdGVtXCIsIHsgcm1Nb3VzZU92ZXI6IHRoaXMuc3RhdGUubW91c2VPdmVyLCBybURpc2FibGVkOiAhdGhpcy5wcm9wcy5lbmFibGUsIHJtU2VwYXJhdG9yOiB0aGlzLnByb3BzLm5hbWUgPT0gJy0nIH0pLFxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24gb25Nb3VzZU92ZXIoZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIub25Nb3VzZU92ZXIoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uIG9uTW91c2VPdXQoZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIub25Nb3VzZU91dChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5vbkNsaWNrKGUpO1xuICAgICAgICB9LFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IHRoaXMucHJvcHMubmFtZSA9PSAnLScgPyBudWxsIDogdGhpcy5wcm9wcy5uYW1lIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb250ZXh0TWVudUl0ZW07XG59KF9yZWFjdDIuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb250ZXh0TWVudUl0ZW07XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2ZDJWaWNHRmpheTkxYm1sMlpYSnpZV3hOYjJSMWJHVkVaV1pwYm1sMGFXOXVJaXdpZDJWaWNHRmphem92THk5M1pXSndZV05yTDJKdmIzUnpkSEpoY0NBMU56TTRNMkZqWm1GbVkyTXlaV05rTW1ZM01DSXNJbmRsWW5CaFkyczZMeTh2WlhoMFpYSnVZV3dnZTF3aWNtOXZkRndpT2x3aVVtVmhZM1JjSWl4Y0ltTnZiVzF2Ym1wek1sd2lPbHdpY21WaFkzUmNJaXhjSW1OdmJXMXZibXB6WENJNlhDSnlaV0ZqZEZ3aUxGd2lZVzFrWENJNlhDSnlaV0ZqZEZ3aWZTSXNJbmRsWW5CaFkyczZMeTh2TGk5emNtTXZhVzVrWlhndVpYTTJJaXdpZDJWaWNHRmphem92THk4dUwzTnlZeTlxY3k5amIyMXdiMjVsYm5SekwwTnZiblJsZUhSTlpXNTFMbXB6ZUNJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmIySnFaV04wTFdGemMybG5iaTlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXpjbU12YW5NdlkyOXRjRzl1Wlc1MGN5OURiMjUwWlhoMFRXVnVkVWwwWlcwdWFuTjRJaXdpZDJWaWNHRmphem92THk5bGVIUmxjbTVoYkNCN1hDSnliMjkwWENJNlhDSmpiR0Z6YzA1aGJXVnpYQ0lzWENKamIyMXRiMjVxY3pKY0lqcGNJbU5zWVhOemJtRnRaWE5jSWl4Y0ltTnZiVzF2Ym1welhDSTZYQ0pqYkdGemMyNWhiV1Z6WENJc1hDSmhiV1JjSWpwY0ltTnNZWE56Ym1GdFpYTmNJbjBpTENKM1pXSndZV05yT2k4dkwyVjRkR1Z5Ym1Gc0lIdGNJbkp2YjNSY0lqcGNJbEJ5YjNCVWVYQmxjMXdpTEZ3aVkyOXRiVzl1YW5NeVhDSTZYQ0p3Y205d0xYUjVjR1Z6WENJc1hDSmpiMjF0YjI1cWMxd2lPbHdpY0hKdmNDMTBlWEJsYzF3aUxGd2lZVzFrWENJNlhDSndjbTl3TFhSNWNHVnpYQ0o5SWwwc0ltNWhiV1Z6SWpwYklrTnZiblJsZUhSTlpXNTFJaXdpZDJsa2RHZ2lMQ0ozYVc1a2IzY2lMQ0pwYm01bGNsZHBaSFJvSWl3aVpHOWpkVzFsYm5RaUxDSmtiMk4xYldWdWRFVnNaVzFsYm5RaUxDSmpiR2xsYm5SWGFXUjBhQ0lzSW1KdlpIa2lMQ0pvWldsbmFIUWlMQ0pwYm01bGNraGxhV2RvZENJc0ltTnNhV1Z1ZEVobGFXZG9kQ0lzSW5CeWIzQnpJaXdpYzNSaGRHVWlMQ0p6ZEhsc1pTSXNJbkJ2YzJsMGFXOXVJaXdpWkdsemNHeGhlU0lzSW5wSmJtUmxlQ0lzSW05MlpYSnNZWGtpTENKamNtVmhkR1ZGYkdWdFpXNTBJaXdpYzJWMFFYUjBjbWxpZFhSbElpd2lZWEJ3Wlc1a1EyaHBiR1FpTENKaFpHUkZkbVZ1ZEV4cGMzUmxibVZ5SWl3aVkyeHZjMlVpTENKbElpd2ljSEpsZG1WdWRFUmxabUYxYkhRaUxDSndiM01pTENKamIyNTBaWGgwSWl3aWMyVjBVM1JoZEdVaUxDSjNhVzVrYjNkVGFYcGxJaXdpWjJWMFYybHVaRzkzVTJsNlpTSXNJbU52Ym5OdmJHVWlMQ0pzYjJjaUxDSnBkR1Z0Y3lJc0ltMWhjQ0lzSW1sMFpXMGlMQ0pyWlhraUxDSnphRzkzSWl3aWJtRnRaU0lzSW05dVEyeHBZMnNpTENKbGJtRmliR1VpTENKRGIyMXdiMjVsYm5RaUxDSndjbTl3Vkhsd1pYTWlMQ0poY25KaGVVOW1JaXdpYzJoaGNHVWlMQ0ptZFc1aklpd2lhWE5TWlhGMWFYSmxaQ0lzSW01MWJXSmxjaUlzSW1SbFptRjFiSFJRY205d2N5SXNJa052Ym5SbGVIUk5aVzUxU1hSbGJTSXNJbTF2ZFhObFQzWmxjaUlzSW0xbGJuVWlMQ0p5YlUxdmRYTmxUM1psY2lJc0luSnRSR2x6WVdKc1pXUWlMQ0p5YlZObGNHRnlZWFJ2Y2lJc0ltOXVUVzkxYzJWUGRtVnlJaXdpYjI1TmIzVnpaVTkxZENJc0lsOWZhSFJ0YkNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORUxFODdRVU5XUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWVVGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVOQlFUSkNMREJDUVVFd1FpeEZRVUZGTzBGQlEzWkVMSGxEUVVGcFF5eGxRVUZsTzBGQlEyaEVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTERoRVFVRnpSQ3dyUkVGQkswUTdPMEZCUlhKSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN096czdPenRCUXpkRVFTd3JRenM3T3pzN096czdPenM3T3pzN1FVTkJRVHM3T3pzN08xRkJRMUZCTEZjN096czdPenM3T3pzN096czdPenM3UVVORVVqczdPenRCUVVOQk96czdPMEZCUTBFN096czdRVUZEUVRzN096czdPenM3T3pzN08wbEJSWEZDUVN4WE96czdPenR2UTBGRlJ6dEJRVU53UWl4VlFVRk5ReXhSUVVGUlF5eFBRVUZQUXl4VlFVRlFMRWxCUTFoRExGTkJRVk5ETEdWQlFWUXNRMEZCZVVKRExGZEJSR1FzU1VGRldFWXNVMEZCVTBjc1NVRkJWQ3hEUVVGalJDeFhRVVpxUWpzN1FVRkpRU3hWUVVGTlJTeFRRVUZUVGl4UFFVRlBUeXhYUVVGUUxFbEJRMXBNTEZOQlFWTkRMR1ZCUVZRc1EwRkJlVUpMTEZsQlJHSXNTVUZGV2s0c1UwRkJVMGNzU1VGQlZDeERRVUZqUnl4WlFVWnFRanM3UVVGSlFTeGhRVUZQTEVWQlFVTlVMRTlCUVU5QkxFdEJRVklzUlVGQlpVOHNVVUZCVVVFc1RVRkJka0lzUlVGQlVEdEJRVU5FT3pzN1FVRkZSQ3gxUWtGQldVY3NTMEZCV2l4RlFVRnRRanRCUVVGQk96dEJRVUZCTERCSVFVTllRU3hMUVVSWE96dEJRVVZxUWl4VlFVRkxReXhMUVVGTUxFZEJRV0U3UVVGRFdFTXNZVUZCVHp0QlFVTk1ReXhyUWtGQlZTeFZRVVJNTzBGQlJVeERMR2xDUVVGVExFMUJSa283UVVGSFRFTXNaMEpCUVZFc1RVRkJTMHdzUzBGQlRDeERRVUZYU3p0QlFVaGtPMEZCUkVrc1MwRkJZanM3UVVGUlFTeFZRVUZMUXl4UFFVRk1MRWRCUVdWaUxGTkJRVk5qTEdGQlFWUXNRMEZCZFVJc1MwRkJka0lzUTBGQlpqdEJRVU5CTEZWQlFVdEVMRTlCUVV3c1EwRkJZVVVzV1VGQllpeERRVUV3UWl4UFFVRXhRaXhGUVVGdFF5eGxRVUZ1UXp0QlFVTkJMRlZCUVV0R0xFOUJRVXdzUTBGQllVb3NTMEZCWWl4RFFVRnRRaXhWUVVGdVFpeEpRVUZwUXl4VlFVRnFRenRCUVVOQkxGVkJRVXRKTEU5QlFVd3NRMEZCWVVvc1MwRkJZaXhEUVVGdFFpeExRVUZ1UWl4SlFVRTBRaXhIUVVFMVFqdEJRVU5CTEZWQlFVdEpMRTlCUVV3c1EwRkJZVW9zUzBGQllpeERRVUZ0UWl4TlFVRnVRaXhKUVVFMlFpeEhRVUUzUWp0QlFVTkJMRlZCUVV0SkxFOUJRVXdzUTBGQllVb3NTMEZCWWl4RFFVRnRRaXhUUVVGdVFpeEpRVUZuUXl4TlFVRm9RenRCUVVOQkxGVkJRVXRKTEU5QlFVd3NRMEZCWVVvc1MwRkJZaXhEUVVGdFFpeFJRVUZ1UWl4SlFVRXJRaXhOUVVGTFJpeExRVUZNTEVOQlFWZExMRTFCUVZnc1IwRkJiMElzUTBGQmJrUTdRVUZEUVZvc1lVRkJVMGNzU1VGQlZDeERRVUZqWVN4WFFVRmtMRU5CUVRCQ0xFMUJRVXRJTEU5QlFTOUNPMEZCUTBFc1ZVRkJTMEVzVDBGQlRDeERRVUZoU1N4blFrRkJZaXhEUVVFNFFpeFBRVUU1UWl4RlFVRjFRenRCUVVGQkxHRkJRVXNzVFVGQlMwTXNTMEZCVEN4RlFVRk1PMEZCUVVFc1MwRkJka003UVVGRFFTeFZRVUZMVEN4UFFVRk1MRU5CUVdGSkxHZENRVUZpTEVOQlFUaENMR0ZCUVRsQ0xFVkJRVFpETEdGQlFVczdRVUZEYUVSRkxGRkJRVVZETEdOQlFVWTdRVUZEUVN4WlFVRkxSaXhMUVVGTU8wRkJRMFFzUzBGSVJEdEJRVzVDYVVJN1FVRjFRbXhDT3pzN08zbENRVVZKUnl4SExFVkJRVXRETEU4c1JVRkJVVHRCUVVGQk96dEJRVU5vUWl4WFFVRkxReXhSUVVGTUxFTkJRV003UVVGRFdtUXNaVUZCVHl3MFFrRkJUeXhGUVVGUUxFVkJRVmNzUzBGQlMwUXNTMEZCVEN4RFFVRlhReXhMUVVGMFFpeEZRVUUyUWxrc1IwRkJOMElzUlVGQmEwTXNSVUZCUTFZc1UwRkJVeXhQUVVGV0xFVkJRV3hETEVOQlJFczdRVUZGV2xjc2FVSkJRVk5CTzBGQlJrY3NUMEZCWkN4RlFVZEhMRmxCUVUwN1FVRkRVQ3haUVVGSlJTeGhRVUZoTlVJc1dVRkJXVFpDTEdGQlFWb3NSVUZCYWtJN1FVRkRRU3hsUVVGTFdpeFBRVUZNTEVOQlFXRktMRXRCUVdJc1EwRkJiVUlzVDBGQmJrSXNTVUZCT0VKbExGZEJRVmN6UWl4TFFVRllMRWRCUVcxQ0xFbEJRV3BFTzBGQlEwRXNaVUZCUzJkQ0xFOUJRVXdzUTBGQllVb3NTMEZCWWl4RFFVRnRRaXhSUVVGdVFpeEpRVUVyUW1Vc1YwRkJWM0JDTEUxQlFWZ3NSMEZCYjBJc1NVRkJia1E3UVVGRFFTeGxRVUZMVXl4UFFVRk1MRU5CUVdGS0xFdEJRV0lzUTBGQmJVSXNVMEZCYmtJc1NVRkJaME1zVDBGQmFFTTdRVUZEUkN4UFFWSkVPMEZCVTBRN096dHBRMEZGVnp0QlFVTldhVUlzWTBGQlVVTXNSMEZCVWl4RFFVRlpMRXRCUVZvN1FVRkRSRHM3TzJ0RFFVVlpPMEZCUTFoRUxHTkJRVkZETEVkQlFWSXNRMEZCV1N4TlFVRmFPMEZCUTBRN096czBRa0ZGVFR0QlFVRkJPenRCUVVOTUxGZEJRVXRLTEZGQlFVd3NRMEZEUlN4RlFVRkRaQ3hQUVVGUExEUkNRVUZQTEVWQlFWQXNSVUZCVnl4TFFVRkxSQ3hMUVVGTUxFTkJRVmRETEV0QlFYUkNMRVZCUVRaQ0xFVkJRVU5GTEZOQlFWTXNUVUZCVml4RlFVRTNRaXhEUVVGU0xFVkJSRVlzUlVGRlJTeFpRVUZOTzBGQlEwb3NaVUZCUzBVc1QwRkJUQ3hEUVVGaFNpeExRVUZpTEVOQlFXMUNMRk5CUVc1Q0xFbEJRV2RETEUxQlFXaERPMEZCUTBRc1QwRktTRHRCUVUxRU96czdOa0pCUlU4N1FVRkJRVHM3UVVGRFRpeGhRVU5GTzBGQlFVRTdRVUZCUVN4VlFVRkxMRXRCUVVrc1RVRkJWQ3hGUVVGblFpeFhRVUZWTEZGQlFURkNMRVZCUVcxRExFOUJRVThzUzBGQlMwUXNTMEZCVEN4RFFVRlhReXhMUVVGeVJEdEJRVU5GTzBGQlFVRTdRVUZCUVN4WlFVRkpMRmRCUVZVc1owSkJRV1E3UVVGRFJ5eGxRVUZMUkN4TFFVRk1MRU5CUVZkakxFOUJRVmdzUjBGQmNVSXNTMEZCUzJZc1MwRkJUQ3hEUVVGWGNVSXNTMEZCV0N4RFFVRnBRa01zUjBGQmFrSXNRMEZCY1VJc1ZVRkJRME1zU1VGQlJDeEZRVUZQUXl4SFFVRlFMRVZCUVdVN1FVRkRlRVFzWjBKQlFVY3NRMEZCUTBRc1MwRkJTMFVzU1VGQlRpeEpRVUZqUml4TFFVRkxSU3hKUVVGTUxFTkJRVlVzVDBGQlMzaENMRXRCUVV3c1EwRkJWMk1zVDBGQmNrSXNRMEZCYWtJc1JVRkJLME03UVVGRE4wTXNjVUpCUTBVN1FVRkRSU3h4UWtGQlMxTXNSMEZFVUR0QlFVVkZMSE5DUVVGTlJDeExRVUZMUnl4SlFVRk1MRU5CUVZVc1QwRkJTM3BDTEV0QlFVd3NRMEZCVjJNc1QwRkJja0lzUTBGR1VqdEJRVWRGTEhsQ1FVRlRVU3hMUVVGTFNTeFBRVWhvUWp0QlFVbEZMRFJDUVVwR08wRkJTMFVzZDBKQlFWRktMRXRCUVV0TExFMUJRVXdzUjBGQlkwd3NTMEZCUzBzc1RVRkJUQ3hEUVVGWkxFOUJRVXN6UWl4TFFVRk1MRU5CUVZkakxFOUJRWFpDTEVOQlFXUXNSMEZCWjBRN1FVRk1NVVFzWjBKQlJFWTdRVUZUUkR0QlFVTkdMRmRCV25GQ0xFTkJRWEpDTEVkQldVazdRVUZpVUR0QlFVUkdMRTlCUkVZN1FVRnRRa1E3T3pzN1JVRjRSbk5ETEdkQ1FVRk5ZeXhUT3p0clFrRkJNVUo0UXl4WE96czdRVUV5Um5KQ1FTeFpRVUZaZVVNc1UwRkJXaXhIUVVGM1FqdEJRVU4wUWxRc1UwRkJUeXh2UWtGQlZWVXNUMEZCVml4RFFVRnJRaXh2UWtGQlZVTXNTMEZCVml4RFFVRm5RanRCUVVOMlEwNHNWVUZCVFN4dlFrRkJWVThzU1VGQlZpeERRVUZsUXl4VlFVUnJRanRCUVVWMlExQXNZVUZCVXl4dlFrRkJWVTBzU1VGR2IwSTdRVUZIZGtOU0xGVkJRVTBzYjBKQlFWVlJMRWxCU0hWQ08wRkJTWFpEVEN4WlFVRlJMRzlDUVVGVlN6dEJRVXB4UWl4SFFVRm9RaXhEUVVGc1FpeEZRVXRJUXl4VlFVNXJRanRCUVU5MFFqZENMRlZCUVZFc2IwSkJRVlU0UWp0QlFWQkpMRU5CUVhoQ096dEJRVlZCT1VNc1dVRkJXU3RETEZsQlFWb3NSMEZCTWtJN1FVRkRla0l2UWl4VlFVRlJPMEZCUkdsQ0xFTkJRVE5DTEVNN096czdPenM3UVVNeFIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRXNaME5CUVdkRE8wRkJRMmhETzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc1VVRkJVVHRCUVVONlFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGdzYTBOQlFXdERPMEZCUTJ4RE8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRVZCUVVVN1FVRkRSanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeG5Ra0ZCWjBJc2MwSkJRWE5DTzBGQlEzUkRPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxHdENRVUZyUWl4dlFrRkJiMEk3UVVGRGRFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPenM3T3pzN096czdPenM3T3pzN1FVTnNSa0U3T3pzN1FVRkRRVHM3T3pzN096czdPenM3TzBsQlJYRkNaME1zWlRzN08wRkJSVzVDTERKQ1FVRlpja01zUzBGQldpeEZRVUZ0UWp0QlFVRkJPenRCUVVGQkxHdEpRVU5ZUVN4TFFVUlhPenRCUVVWcVFpeFZRVUZMUXl4TFFVRk1MRWRCUVdFN1FVRkRXSEZETEdsQ1FVRlhPMEZCUkVFc1MwRkJZanRCUVVacFFqdEJRVXRzUWpzN096dHBRMEZGVnp0QlFVTldMRlZCUVVjc1MwRkJTM1JETEV0QlFVd3NRMEZCVnpSQ0xFMUJRV1FzUlVGQmNVSTdRVUZEYmtJc1lVRkJTMW9zVVVGQlRDeERRVUZqTEVWQlFVTnpRaXhYUVVGWExFdEJRVm9zUlVGQlpEdEJRVU5FTzBGQlEwWTdPenRyUTBGRldUdEJRVU5ZTEZWQlFVY3NTMEZCUzNSRExFdEJRVXdzUTBGQlZ6UkNMRTFCUVdRc1JVRkJjVUk3UVVGRGJrSXNZVUZCUzFvc1VVRkJUQ3hEUVVGakxFVkJRVU56UWl4WFFVRlhMRWxCUVZvc1JVRkJaRHRCUVVORU8wRkJRMFk3T3pzMFFrRkZUekZDTEVNc1JVRkJSVHRCUVVOU0xGVkJRVWNzUzBGQlMxb3NTMEZCVEN4RFFVRlhORUlzVFVGQlpDeEZRVUZ4UWp0QlFVTnVRaXhoUVVGTE5VSXNTMEZCVEN4RFFVRlhNa0lzVDBGQldDeERRVUZ0UWl4TFFVRkxNMElzUzBGQlRDeERRVUZYZFVNc1NVRkJXQ3hEUVVGblFuUkRMRXRCUVdoQ0xFTkJRWE5DWXl4UFFVRjZRenRCUVVOQkxHRkJRVXRtTEV0QlFVd3NRMEZCVjNWRExFbEJRVmdzUTBGQlowSTFRaXhMUVVGb1FqdEJRVU5FTzBGQlEwWTdPenMyUWtGRlR6dEJRVUZCT3p0QlFVTk9MR0ZCUTBVN1FVRkRSU3h0UWtGQlZ5d3dRa0ZCVnl4WlFVRllMRVZCUVhsQ0xFVkJRVU0yUWl4aFFVRmhMRXRCUVV0MlF5eExRVUZNTEVOQlFWZHhReXhUUVVGNlFpeEZRVUZ2UTBjc1dVRkJXU3hEUVVGRExFdEJRVXQ2UXl4TFFVRk1MRU5CUVZjMFFpeE5RVUUxUkN4RlFVRnZSV01zWVVGQllTeExRVUZMTVVNc1MwRkJUQ3hEUVVGWE1FSXNTVUZCV0N4SlFVRnRRaXhIUVVGd1J5eEZRVUY2UWl4RFFVUmlPMEZCUlVVc2NVSkJRV0U3UVVGQlFTeHBRa0ZCU3l4UFFVRkxhVUlzVjBGQlRDeERRVUZwUWk5Q0xFTkJRV3BDTEVOQlFVdzdRVUZCUVN4VFFVWm1PMEZCUjBVc2IwSkJRVms3UVVGQlFTeHBRa0ZCU3l4UFFVRkxaME1zVlVGQlRDeERRVUZuUW1oRExFTkJRV2hDTEVOQlFVdzdRVUZCUVN4VFFVaGtPMEZCU1VVc2FVSkJRVk03UVVGQlFTeHBRa0ZCU3l4UFFVRkxaU3hQUVVGTUxFTkJRV0ZtTEVOQlFXSXNRMEZCVER0QlFVRkJMRk5CU2xnN1FVRkxSU3hwUTBGQmVVSXNSVUZCUTJsRExGRkJRVkVzUzBGQlN6ZERMRXRCUVV3c1EwRkJWekJDTEVsQlFWZ3NTVUZCYlVJc1IwRkJia0lzUjBGQmVVSXNTVUZCZWtJc1IwRkJaME1zUzBGQlN6RkNMRXRCUVV3c1EwRkJWekJDTEVsQlFYQkVPMEZCVEROQ0xGRkJSRVk3UVVGVlJEczdPenRGUVhaRE1FTXNaMEpCUVUxSExGTTdPMnRDUVVFNVFsRXNaVHM3T3pzN08wRkRTSEpDTEN0RE96czdPenM3UVVOQlFTd3JReUlzSW1acGJHVWlPaUpwYm1SbGVDNXFjeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWlobWRXNWpkR2x2YmlCM1pXSndZV05yVlc1cGRtVnljMkZzVFc5a2RXeGxSR1ZtYVc1cGRHbHZiaWh5YjI5MExDQm1ZV04wYjNKNUtTQjdYRzVjZEdsbUtIUjVjR1Z2WmlCbGVIQnZjblJ6SUQwOVBTQW5iMkpxWldOMEp5QW1KaUIwZVhCbGIyWWdiVzlrZFd4bElEMDlQU0FuYjJKcVpXTjBKeWxjYmx4MFhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWmhZM1J2Y25rb2NtVnhkV2x5WlNoY0luSmxZV04wWENJcExDQnlaWEYxYVhKbEtGd2lZMnhoYzNOdVlXMWxjMXdpS1N3Z2NtVnhkV2x5WlNoY0luQnliM0F0ZEhsd1pYTmNJaWtwTzF4dVhIUmxiSE5sSUdsbUtIUjVjR1Z2WmlCa1pXWnBibVVnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnWkdWbWFXNWxMbUZ0WkNsY2JseDBYSFJrWldacGJtVW9XMXdpY21WaFkzUmNJaXdnWENKamJHRnpjMjVoYldWelhDSXNJRndpY0hKdmNDMTBlWEJsYzF3aVhTd2dabUZqZEc5eWVTazdYRzVjZEdWc2MyVWdlMXh1WEhSY2RIWmhjaUJoSUQwZ2RIbHdaVzltSUdWNGNHOXlkSE1nUFQwOUlDZHZZbXBsWTNRbklEOGdabUZqZEc5eWVTaHlaWEYxYVhKbEtGd2ljbVZoWTNSY0lpa3NJSEpsY1hWcGNtVW9YQ0pqYkdGemMyNWhiV1Z6WENJcExDQnlaWEYxYVhKbEtGd2ljSEp2Y0MxMGVYQmxjMXdpS1NrZ09pQm1ZV04wYjNKNUtISnZiM1JiWENKU1pXRmpkRndpWFN3Z2NtOXZkRnRjSW1Oc1lYTnpUbUZ0WlhOY0lsMHNJSEp2YjNSYlhDSlFjbTl3Vkhsd1pYTmNJbDBwTzF4dVhIUmNkR1p2Y2loMllYSWdhU0JwYmlCaEtTQW9kSGx3Wlc5bUlHVjRjRzl5ZEhNZ1BUMDlJQ2R2WW1wbFkzUW5JRDhnWlhod2IzSjBjeUE2SUhKdmIzUXBXMmxkSUQwZ1lWdHBYVHRjYmx4MGZWeHVmU2tvZEdocGN5d2dablZ1WTNScGIyNG9YMTlYUlVKUVFVTkxYMFZZVkVWU1RrRk1YMDFQUkZWTVJWOHdYMThzSUY5ZlYwVkNVRUZEUzE5RldGUkZVazVCVEY5TlQwUlZURVZmTlY5ZkxDQmZYMWRGUWxCQlEwdGZSVmhVUlZKT1FVeGZUVTlFVlV4Rlh6WmZYeWtnZTF4dWNtVjBkWEp1SUZ4dVhHNWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNJQzh2WEc0dkx5QjNaV0p3WVdOckwzVnVhWFpsY25OaGJFMXZaSFZzWlVSbFptbHVhWFJwYjI0aUxDSWdYSFF2THlCVWFHVWdiVzlrZFd4bElHTmhZMmhsWEc0Z1hIUjJZWElnYVc1emRHRnNiR1ZrVFc5a2RXeGxjeUE5SUh0OU8xeHVYRzRnWEhRdkx5QlVhR1VnY21WeGRXbHlaU0JtZFc1amRHbHZibHh1SUZ4MFpuVnVZM1JwYjI0Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5aHRiMlIxYkdWSlpDa2dlMXh1WEc0Z1hIUmNkQzh2SUVOb1pXTnJJR2xtSUcxdlpIVnNaU0JwY3lCcGJpQmpZV05vWlZ4dUlGeDBYSFJwWmlocGJuTjBZV3hzWldSTmIyUjFiR1Z6VzIxdlpIVnNaVWxrWFNrZ2UxeHVJRngwWEhSY2RISmxkSFZ5YmlCcGJuTjBZV3hzWldSTmIyUjFiR1Z6VzIxdlpIVnNaVWxrWFM1bGVIQnZjblJ6TzF4dUlGeDBYSFI5WEc0Z1hIUmNkQzh2SUVOeVpXRjBaU0JoSUc1bGR5QnRiMlIxYkdVZ0tHRnVaQ0J3ZFhRZ2FYUWdhVzUwYnlCMGFHVWdZMkZqYUdVcFhHNGdYSFJjZEhaaGNpQnRiMlIxYkdVZ1BTQnBibk4wWVd4c1pXUk5iMlIxYkdWelcyMXZaSFZzWlVsa1hTQTlJSHRjYmlCY2RGeDBYSFJwT2lCdGIyUjFiR1ZKWkN4Y2JpQmNkRngwWEhSc09pQm1ZV3h6WlN4Y2JpQmNkRngwWEhSbGVIQnZjblJ6T2lCN2ZWeHVJRngwWEhSOU8xeHVYRzRnWEhSY2RDOHZJRVY0WldOMWRHVWdkR2hsSUcxdlpIVnNaU0JtZFc1amRHbHZibHh1SUZ4MFhIUnRiMlIxYkdWelcyMXZaSFZzWlVsa1hTNWpZV3hzS0cxdlpIVnNaUzVsZUhCdmNuUnpMQ0J0YjJSMWJHVXNJRzF2WkhWc1pTNWxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLVHRjYmx4dUlGeDBYSFF2THlCR2JHRm5JSFJvWlNCdGIyUjFiR1VnWVhNZ2JHOWhaR1ZrWEc0Z1hIUmNkRzF2WkhWc1pTNXNJRDBnZEhKMVpUdGNibHh1SUZ4MFhIUXZMeUJTWlhSMWNtNGdkR2hsSUdWNGNHOXlkSE1nYjJZZ2RHaGxJRzF2WkhWc1pWeHVJRngwWEhSeVpYUjFjbTRnYlc5a2RXeGxMbVY0Y0c5eWRITTdYRzRnWEhSOVhHNWNibHh1SUZ4MEx5OGdaWGh3YjNObElIUm9aU0J0YjJSMWJHVnpJRzlpYW1WamRDQW9YMTkzWldKd1lXTnJYMjF2WkhWc1pYTmZYeWxjYmlCY2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHViU0E5SUcxdlpIVnNaWE03WEc1Y2JpQmNkQzh2SUdWNGNHOXpaU0IwYUdVZ2JXOWtkV3hsSUdOaFkyaGxYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtTWdQU0JwYm5OMFlXeHNaV1JOYjJSMWJHVnpPMXh1WEc0Z1hIUXZMeUJrWldacGJtVWdaMlYwZEdWeUlHWjFibU4wYVc5dUlHWnZjaUJvWVhKdGIyNTVJR1Y0Y0c5eWRITmNiaUJjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dVpDQTlJR1oxYm1OMGFXOXVLR1Y0Y0c5eWRITXNJRzVoYldVc0lHZGxkSFJsY2lrZ2UxeHVJRngwWEhScFppZ2hYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTV2S0dWNGNHOXlkSE1zSUc1aGJXVXBLU0I3WEc0Z1hIUmNkRngwVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtHVjRjRzl5ZEhNc0lHNWhiV1VzSUh0Y2JpQmNkRngwWEhSY2RHTnZibVpwWjNWeVlXSnNaVG9nWm1Gc2MyVXNYRzRnWEhSY2RGeDBYSFJsYm5WdFpYSmhZbXhsT2lCMGNuVmxMRnh1SUZ4MFhIUmNkRngwWjJWME9pQm5aWFIwWlhKY2JpQmNkRngwWEhSOUtUdGNiaUJjZEZ4MGZWeHVJRngwZlR0Y2JseHVJRngwTHk4Z1oyVjBSR1ZtWVhWc2RFVjRjRzl5ZENCbWRXNWpkR2x2YmlCbWIzSWdZMjl0Y0dGMGFXSnBiR2wwZVNCM2FYUm9JRzV2Ymkxb1lYSnRiMjU1SUcxdlpIVnNaWE5jYmlCY2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHViaUE5SUdaMWJtTjBhVzl1S0cxdlpIVnNaU2tnZTF4dUlGeDBYSFIyWVhJZ1oyVjBkR1Z5SUQwZ2JXOWtkV3hsSUNZbUlHMXZaSFZzWlM1ZlgyVnpUVzlrZFd4bElEOWNiaUJjZEZ4MFhIUm1kVzVqZEdsdmJpQm5aWFJFWldaaGRXeDBLQ2tnZXlCeVpYUjFjbTRnYlc5a2RXeGxXeWRrWldaaGRXeDBKMTA3SUgwZ09seHVJRngwWEhSY2RHWjFibU4wYVc5dUlHZGxkRTF2WkhWc1pVVjRjRzl5ZEhNb0tTQjdJSEpsZEhWeWJpQnRiMlIxYkdVN0lIMDdYRzRnWEhSY2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHVaQ2huWlhSMFpYSXNJQ2RoSnl3Z1oyVjBkR1Z5S1R0Y2JpQmNkRngwY21WMGRYSnVJR2RsZEhSbGNqdGNiaUJjZEgwN1hHNWNiaUJjZEM4dklFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWFHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JGeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1dklEMGdablZ1WTNScGIyNG9iMkpxWldOMExDQndjbTl3WlhKMGVTa2dleUJ5WlhSMWNtNGdUMkpxWldOMExuQnliM1J2ZEhsd1pTNW9ZWE5QZDI1UWNtOXdaWEowZVM1allXeHNLRzlpYW1WamRDd2djSEp2Y0dWeWRIa3BPeUI5TzF4dVhHNGdYSFF2THlCZlgzZGxZbkJoWTJ0ZmNIVmliR2xqWDNCaGRHaGZYMXh1SUZ4MFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NXdJRDBnWENKY0lqdGNibHh1SUZ4MEx5OGdURzloWkNCbGJuUnllU0J0YjJSMWJHVWdZVzVrSUhKbGRIVnliaUJsZUhCdmNuUnpYRzRnWEhSeVpYUjFjbTRnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHloZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxuTWdQU0F4S1R0Y2JseHVYRzVjYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTSUM4dlhHNHZMeUIzWldKd1lXTnJMMkp2YjNSemRISmhjQ0ExTnpNNE0yRmpabUZtWTJNeVpXTmtNbVkzTUNJc0ltMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1gxOVhSVUpRUVVOTFgwVllWRVZTVGtGTVgwMVBSRlZNUlY4d1gxODdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnWlhoMFpYSnVZV3dnZTF3aWNtOXZkRndpT2x3aVVtVmhZM1JjSWl4Y0ltTnZiVzF2Ym1wek1sd2lPbHdpY21WaFkzUmNJaXhjSW1OdmJXMXZibXB6WENJNlhDSnlaV0ZqZEZ3aUxGd2lZVzFrWENJNlhDSnlaV0ZqZEZ3aWZWeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKcGJYQnZjblFnUTI5dWRHVjRkRTFsYm5VZ1puSnZiU0FuTGk5cWN5OWpiMjF3YjI1bGJuUnpMME52Ym5SbGVIUk5aVzUxSnp0Y2JtVjRjRzl5ZENCN1EyOXVkR1Y0ZEUxbGJuVjlYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQkRiMjUwWlhoMFRXVnVkVnh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDJsdVpHVjRMbVZ6TmlJc0ltbHRjRzl5ZENCU1pXRmpkQ0JtY205dElDZHlaV0ZqZENjN1hHNXBiWEJ2Y25RZ1lYTnphV2R1SUdaeWIyMGdKMjlpYW1WamRDMWhjM05wWjI0blhHNXBiWEJ2Y25RZ1RXVnVkVWwwWlcwZ1puSnZiU0FuTGk5RGIyNTBaWGgwVFdWdWRVbDBaVzBuWEc1cGJYQnZjblFnVUhKdmNGUjVjR1Z6SUdaeWIyMGdKM0J5YjNBdGRIbHdaWE1uWEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRU52Ym5SbGVIUk5aVzUxSUdWNGRHVnVaSE1nVW1WaFkzUXVRMjl0Y0c5dVpXNTBYRzU3WEc0Z0lITjBZWFJwWXlCblpYUlhhVzVrYjNkVGFYcGxLQ2w3WEc0Z0lDQWdZMjl1YzNRZ2QybGtkR2dnUFNCM2FXNWtiM2N1YVc1dVpYSlhhV1IwYUZ4dUlDQWdJSHg4SUdSdlkzVnRaVzUwTG1SdlkzVnRaVzUwUld4bGJXVnVkQzVqYkdsbGJuUlhhV1IwYUZ4dUlDQWdJSHg4SUdSdlkzVnRaVzUwTG1KdlpIa3VZMnhwWlc1MFYybGtkR2c3WEc1Y2JpQWdJQ0JqYjI1emRDQm9aV2xuYUhRZ1BTQjNhVzVrYjNjdWFXNXVaWEpJWldsbmFIUmNiaUFnSUNCOGZDQmtiMk4xYldWdWRDNWtiMk4xYldWdWRFVnNaVzFsYm5RdVkyeHBaVzUwU0dWcFoyaDBYRzRnSUNBZ2ZId2daRzlqZFcxbGJuUXVZbTlrZVM1amJHbGxiblJJWldsbmFIUTdYRzVjYmlBZ0lDQnlaWFIxY200Z2UzZHBaSFJvT2lCM2FXUjBhQ3dnYUdWcFoyaDBPaUJvWldsbmFIUjlPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUnlkV04wYjNJb2NISnZjSE1wSUh0Y2JpQWdJQ0J6ZFhCbGNpaHdjbTl3Y3lrN1hHNGdJQ0FnZEdocGN5NXpkR0YwWlNBOUlIdGNiaUFnSUNBZ0lITjBlV3hsT2lCN1hHNGdJQ0FnSUNBZ0lIQnZjMmwwYVc5dU9pQW5ZV0p6YjJ4MWRHVW5MRnh1SUNBZ0lDQWdJQ0JrYVhOd2JHRjVPaUFuYm05dVpTY3NYRzRnSUNBZ0lDQWdJSHBKYm1SbGVEb2dkR2hwY3k1d2NtOXdjeTU2U1c1a1pYaGNiaUFnSUNBZ0lIMWNiaUFnSUNCOU8xeHVYRzRnSUNBZ2RHaHBjeTV2ZG1WeWJHRjVJRDBnWkc5amRXMWxiblF1WTNKbFlYUmxSV3hsYldWdWRDZ25aR2wySnlrN1hHNGdJQ0FnZEdocGN5NXZkbVZ5YkdGNUxuTmxkRUYwZEhKcFluVjBaU2duWTJ4aGMzTW5MQ0FuY20xTlpXNTFUM1psY214aGVTY3BPMXh1SUNBZ0lIUm9hWE11YjNabGNteGhlUzV6ZEhsc1pWdGNJbkJ2YzJsMGFXOXVYQ0pkSUQwZ0oyRmljMjlzZFhSbEp6dGNiaUFnSUNCMGFHbHpMbTkyWlhKc1lYa3VjM1I1YkdWYlhDSjBiM0JjSWwwZ1BTQW5NQ2M3WEc0Z0lDQWdkR2hwY3k1dmRtVnliR0Y1TG5OMGVXeGxXMXdpYkdWbWRGd2lYU0E5SUNjd0p6dGNiaUFnSUNCMGFHbHpMbTkyWlhKc1lYa3VjM1I1YkdWYlhDSmthWE53YkdGNVhDSmRJRDBnSjI1dmJtVW5PMXh1SUNBZ0lIUm9hWE11YjNabGNteGhlUzV6ZEhsc1pWdGNJbnBKYm1SbGVGd2lYU0E5SUhSb2FYTXVjSEp2Y0hNdWVrbHVaR1Y0SUMwZ01UdGNiaUFnSUNCa2IyTjFiV1Z1ZEM1aWIyUjVMbUZ3Y0dWdVpFTm9hV3hrS0hSb2FYTXViM1psY214aGVTazdYRzRnSUNBZ2RHaHBjeTV2ZG1WeWJHRjVMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9KMk5zYVdOckp5d2daU0E5UGlCMGFHbHpMbU5zYjNObEtDa3BPMXh1SUNBZ0lIUm9hWE11YjNabGNteGhlUzVoWkdSRmRtVnVkRXhwYzNSbGJtVnlLQ2RqYjI1MFpYaDBiV1Z1ZFNjc0lHVWdQVDRnZTF4dUlDQWdJQ0FnWlM1d2NtVjJaVzUwUkdWbVlYVnNkQ2dwTzF4dUlDQWdJQ0FnZEdocGN5NWpiRzl6WlNncE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1Y2JpQWdjMmh2ZHlod2IzTXNJR052Ym5SbGVIUXBlMXh1SUNBZ0lIUm9hWE11YzJWMFUzUmhkR1VvZTF4dUlDQWdJQ0FnYzNSNWJHVTZJR0Z6YzJsbmJpaDdmU3dnZEdocGN5NXpkR0YwWlM1emRIbHNaU3dnY0c5ekxDQjdaR2x6Y0d4aGVUb2dKMkpzYjJOckozMHBMRnh1SUNBZ0lDQWdZMjl1ZEdWNGREb2dZMjl1ZEdWNGRGeHVJQ0FnSUgwc0lDZ3BJRDArSUh0Y2JpQWdJQ0FnSUd4bGRDQjNhVzVrYjNkVGFYcGxJRDBnUTI5dWRHVjRkRTFsYm5VdVoyVjBWMmx1Wkc5M1UybDZaU2dwTzF4dUlDQWdJQ0FnZEdocGN5NXZkbVZ5YkdGNUxuTjBlV3hsVzF3aWQybGtkR2hjSWwwZ1BTQjNhVzVrYjNkVGFYcGxMbmRwWkhSb0lDc2dKM0I0Snp0Y2JpQWdJQ0FnSUhSb2FYTXViM1psY214aGVTNXpkSGxzWlZ0Y0ltaGxhV2RvZEZ3aVhTQTlJSGRwYm1SdmQxTnBlbVV1YUdWcFoyaDBJQ3NnSjNCNEp6dGNiaUFnSUNBZ0lIUm9hWE11YjNabGNteGhlUzV6ZEhsc1pWc25aR2x6Y0d4aGVTZGRJRDBnSjJKc2IyTnJKenRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUc5dVRXOTFjMlZQZFhRb0tYdGNiaUFnSUNCamIyNXpiMnhsTG14dlp5Z25iM1YwSnlrN1hHNGdJSDFjYmx4dUlDQnZiazF2ZFhObFQzWmxjaWdwZTF4dUlDQWdJR052Ym5OdmJHVXViRzluS0NkdmRtVnlKeWs3WEc0Z0lIMWNibHh1SUNCamJHOXpaU2dwZTF4dUlDQWdJSFJvYVhNdWMyVjBVM1JoZEdVb1hHNGdJQ0FnSUNCN2MzUjViR1U2SUdGemMybG5iaWg3ZlN3Z2RHaHBjeTV6ZEdGMFpTNXpkSGxzWlN3Z2UyUnBjM0JzWVhrNklDZHViMjVsSjMwcGZTeGNiaUFnSUNBZ0lDZ3BJRDArSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV2ZG1WeWJHRjVMbk4wZVd4bFd5ZGthWE53YkdGNUoxMGdQU0FuYm05dVpTYzdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0tUdGNiaUFnZlZ4dVhHNGdJSEpsYm1SbGNpZ3BlMXh1SUNBZ0lISmxkSFZ5YmlBb1hHNGdJQ0FnSUNBOFpHbDJJSEpsWmoxY0ltMWxiblZjSWlCamJHRnpjMDVoYldVOVhDSnliVTFsYm5WY0lpQnpkSGxzWlQxN2RHaHBjeTV6ZEdGMFpTNXpkSGxzWlgwK1hHNGdJQ0FnSUNBZ0lEeDFiQ0JqYkdGemMwNWhiV1U5WENKeWJVMWxiblZKZEdWdFRHbHpkRndpUGx4dUlDQWdJQ0FnSUNBZ0lIdDBhR2x6TG5OMFlYUmxMbU52Ym5SbGVIUWdQeUIwYUdsekxuQnliM0J6TG1sMFpXMXpMbTFoY0Nnb2FYUmxiU3dnYTJWNUtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaWdoYVhSbGJTNXphRzkzSUh4OElHbDBaVzB1YzJodmR5aDBhR2x6TG5OMFlYUmxMbU52Ym5SbGVIUXBLWHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThUV1Z1ZFVsMFpXMWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVQxN2EyVjVmVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYm1GdFpUMTdhWFJsYlM1dVlXMWxLSFJvYVhNdWMzUmhkR1V1WTI5dWRHVjRkQ2w5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdmJrTnNhV05yUFh0cGRHVnRMbTl1UTJ4cFkydDlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0Wlc1MVBYdDBhR2x6ZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1pXNWhZbXhsUFh0cGRHVnRMbVZ1WVdKc1pTQS9JR2wwWlcwdVpXNWhZbXhsS0hSb2FYTXVjM1JoZEdVdVkyOXVkR1Y0ZENrZ09pQjBjblZsZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM4K1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNsY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOUtTQTZJRzUxYkd4OVhHNGdJQ0FnSUNBZ0lEd3ZkV3crWEc0Z0lDQWdJQ0E4TDJScGRqNWNiaUFnSUNBcE8xeHVJQ0I5WEc1OVhHNWNia052Ym5SbGVIUk5aVzUxTG5CeWIzQlVlWEJsY3lBOUlIdGNiaUFnYVhSbGJYTTZJRkJ5YjNCVWVYQmxjeTVoY25KaGVVOW1LRkJ5YjNCVWVYQmxjeTV6YUdGd1pTaDdYRzRnSUNBZ2JtRnRaVG9nVUhKdmNGUjVjR1Z6TG1aMWJtTXVhWE5TWlhGMWFYSmxaQ3hjYmlBZ0lDQnZia05zYVdOck9pQlFjbTl3Vkhsd1pYTXVablZ1WXl4Y2JpQWdJQ0J6YUc5M09pQlFjbTl3Vkhsd1pYTXVablZ1WXl4Y2JpQWdJQ0JsYm1GaWJHVTZJRkJ5YjNCVWVYQmxjeTVtZFc1alhHNGdJSDBwS1M1cGMxSmxjWFZwY21Wa0xGeHVJQ0I2U1c1a1pYZzZJRkJ5YjNCVWVYQmxjeTV1ZFcxaVpYSmNibjFjYmx4dVEyOXVkR1Y0ZEUxbGJuVXVaR1ZtWVhWc2RGQnliM0J6SUQwZ2UxeHVJQ0I2U1c1a1pYZzZJREV3TUZ4dWZWeHVYRzVjYmx4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZJZ0x5OWNiaTh2SUM0dmMzSmpMMnB6TDJOdmJYQnZibVZ1ZEhNdlEyOXVkR1Y0ZEUxbGJuVXVhbk40SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1THlvZ1pYTnNhVzUwTFdScGMyRmliR1VnYm04dGRXNTFjMlZrTFhaaGNuTWdLaTljYm5aaGNpQm9ZWE5QZDI1UWNtOXdaWEowZVNBOUlFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWFHRnpUM2R1VUhKdmNHVnlkSGs3WEc1MllYSWdjSEp2Y0VselJXNTFiV1Z5WVdKc1pTQTlJRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVjSEp2Y0dWeWRIbEpjMFZ1ZFcxbGNtRmliR1U3WEc1Y2JtWjFibU4wYVc5dUlIUnZUMkpxWldOMEtIWmhiQ2tnZTF4dVhIUnBaaUFvZG1Gc0lEMDlQU0J1ZFd4c0lIeDhJSFpoYkNBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc1Y2RGeDBkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduVDJKcVpXTjBMbUZ6YzJsbmJpQmpZVzV1YjNRZ1ltVWdZMkZzYkdWa0lIZHBkR2dnYm5Wc2JDQnZjaUIxYm1SbFptbHVaV1FuS1R0Y2JseDBmVnh1WEc1Y2RISmxkSFZ5YmlCUFltcGxZM1FvZG1Gc0tUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2MyaHZkV3hrVlhObFRtRjBhWFpsS0NrZ2UxeHVYSFIwY25rZ2UxeHVYSFJjZEdsbUlDZ2hUMkpxWldOMExtRnpjMmxuYmlrZ2UxeHVYSFJjZEZ4MGNtVjBkWEp1SUdaaGJITmxPMXh1WEhSY2RIMWNibHh1WEhSY2RDOHZJRVJsZEdWamRDQmlkV2RuZVNCd2NtOXdaWEowZVNCbGJuVnRaWEpoZEdsdmJpQnZjbVJsY2lCcGJpQnZiR1JsY2lCV09DQjJaWEp6YVc5dWN5NWNibHh1WEhSY2RDOHZJR2gwZEhCek9pOHZZblZuY3k1amFISnZiV2wxYlM1dmNtY3ZjQzkyT0M5cGMzTjFaWE12WkdWMFlXbHNQMmxrUFRReE1UaGNibHgwWEhSMllYSWdkR1Z6ZERFZ1BTQnVaWGNnVTNSeWFXNW5LQ2RoWW1NbktUc2dJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1WY2JseDBYSFIwWlhOME1WczFYU0E5SUNka1pTYzdYRzVjZEZ4MGFXWWdLRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpLSFJsYzNReEtWc3dYU0E5UFQwZ0p6VW5LU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdabUZzYzJVN1hHNWNkRngwZlZ4dVhHNWNkRngwTHk4Z2FIUjBjSE02THk5aWRXZHpMbU5vY205dGFYVnRMbTl5Wnk5d0wzWTRMMmx6YzNWbGN5OWtaWFJoYVd3L2FXUTlNekExTmx4dVhIUmNkSFpoY2lCMFpYTjBNaUE5SUh0OU8xeHVYSFJjZEdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z01UQTdJR2tyS3lrZ2UxeHVYSFJjZEZ4MGRHVnpkREpiSjE4bklDc2dVM1J5YVc1bkxtWnliMjFEYUdGeVEyOWtaU2hwS1YwZ1BTQnBPMXh1WEhSY2RIMWNibHgwWEhSMllYSWdiM0prWlhJeUlEMGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTW9kR1Z6ZERJcExtMWhjQ2htZFc1amRHbHZiaUFvYmlrZ2UxeHVYSFJjZEZ4MGNtVjBkWEp1SUhSbGMzUXlXMjVkTzF4dVhIUmNkSDBwTzF4dVhIUmNkR2xtSUNodmNtUmxjakl1YW05cGJpZ25KeWtnSVQwOUlDY3dNVEl6TkRVMk56ZzVKeWtnZTF4dVhIUmNkRngwY21WMGRYSnVJR1poYkhObE8xeHVYSFJjZEgxY2JseHVYSFJjZEM4dklHaDBkSEJ6T2k4dlluVm5jeTVqYUhKdmJXbDFiUzV2Y21jdmNDOTJPQzlwYzNOMVpYTXZaR1YwWVdsc1AybGtQVE13TlRaY2JseDBYSFIyWVhJZ2RHVnpkRE1nUFNCN2ZUdGNibHgwWEhRbllXSmpaR1ZtWjJocGFtdHNiVzV2Y0hGeWMzUW5Mbk53YkdsMEtDY25LUzVtYjNKRllXTm9LR1oxYm1OMGFXOXVJQ2hzWlhSMFpYSXBJSHRjYmx4MFhIUmNkSFJsYzNRelcyeGxkSFJsY2wwZ1BTQnNaWFIwWlhJN1hHNWNkRngwZlNrN1hHNWNkRngwYVdZZ0tFOWlhbVZqZEM1clpYbHpLRTlpYW1WamRDNWhjM05wWjI0b2UzMHNJSFJsYzNRektTa3VhbTlwYmlnbkp5a2dJVDA5WEc1Y2RGeDBYSFJjZENkaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRDY3BJSHRjYmx4MFhIUmNkSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseDBYSFI5WEc1Y2JseDBYSFJ5WlhSMWNtNGdkSEoxWlR0Y2JseDBmU0JqWVhSamFDQW9aU2tnZTF4dVhIUmNkQzh2SUZkbElHUnZiaWQwSUdWNGNHVmpkQ0JoYm5rZ2IyWWdkR2hsSUdGaWIzWmxJSFJ2SUhSb2NtOTNMQ0JpZFhRZ1ltVjBkR1Z5SUhSdklHSmxJSE5oWm1VdVhHNWNkRngwY21WMGRYSnVJR1poYkhObE8xeHVYSFI5WEc1OVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdjMmh2ZFd4a1ZYTmxUbUYwYVhabEtDa2dQeUJQWW1wbFkzUXVZWE56YVdkdUlEb2dablZ1WTNScGIyNGdLSFJoY21kbGRDd2djMjkxY21ObEtTQjdYRzVjZEhaaGNpQm1jbTl0TzF4dVhIUjJZWElnZEc4Z1BTQjBiMDlpYW1WamRDaDBZWEpuWlhRcE8xeHVYSFIyWVhJZ2MzbHRZbTlzY3p0Y2JseHVYSFJtYjNJZ0tIWmhjaUJ6SUQwZ01Uc2djeUE4SUdGeVozVnRaVzUwY3k1c1pXNW5kR2c3SUhNckt5a2dlMXh1WEhSY2RHWnliMjBnUFNCUFltcGxZM1FvWVhKbmRXMWxiblJ6VzNOZEtUdGNibHh1WEhSY2RHWnZjaUFvZG1GeUlHdGxlU0JwYmlCbWNtOXRLU0I3WEc1Y2RGeDBYSFJwWmlBb2FHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JDaG1jbTl0TENCclpYa3BLU0I3WEc1Y2RGeDBYSFJjZEhSdlcydGxlVjBnUFNCbWNtOXRXMnRsZVYwN1hHNWNkRngwWEhSOVhHNWNkRngwZlZ4dVhHNWNkRngwYVdZZ0tFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITXBJSHRjYmx4MFhIUmNkSE41YldKdmJITWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6S0daeWIyMHBPMXh1WEhSY2RGeDBabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J6ZVcxaWIyeHpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNWNkRngwWEhSY2RHbG1JQ2h3Y205d1NYTkZiblZ0WlhKaFlteGxMbU5oYkd3b1puSnZiU3dnYzNsdFltOXNjMXRwWFNrcElIdGNibHgwWEhSY2RGeDBYSFIwYjF0emVXMWliMnh6VzJsZFhTQTlJR1p5YjIxYmMzbHRZbTlzYzF0cFhWMDdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjZEgxY2JseHVYSFJ5WlhSMWNtNGdkRzg3WEc1OU8xeHVYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5dWIyUmxYMjF2WkhWc1pYTXZiMkpxWldOMExXRnpjMmxuYmk5cGJtUmxlQzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTTF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0pwYlhCdmNuUWdVbVZoWTNRZ1puSnZiU0FuY21WaFkzUW5PMXh1YVcxd2IzSjBJR05zWVhOelRtRnRaWE1nWm5KdmJTQW5ZMnhoYzNOdVlXMWxjeWM3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRU52Ym5SbGVIUk5aVzUxU1hSbGJTQmxlSFJsYm1SeklGSmxZV04wTGtOdmJYQnZibVZ1ZEZ4dWUxeHVJQ0JqYjI1emRISjFZM1J2Y2lod2NtOXdjeWtnZTF4dUlDQWdJSE4xY0dWeUtIQnliM0J6S1R0Y2JpQWdJQ0IwYUdsekxuTjBZWFJsSUQwZ2UxeHVJQ0FnSUNBZ2JXOTFjMlZQZG1WeU9pQm1ZV3h6WlZ4dUlDQWdJSDA3WEc0Z0lIMWNibHh1SUNCdmJrMXZkWE5sVDNWMEtDbDdYRzRnSUNBZ2FXWW9kR2hwY3k1d2NtOXdjeTVsYm1GaWJHVXBlMXh1SUNBZ0lDQWdkR2hwY3k1elpYUlRkR0YwWlNoN2JXOTFjMlZQZG1WeU9pQm1ZV3h6WlgwcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHOXVUVzkxYzJWUGRtVnlLQ2w3WEc0Z0lDQWdhV1lvZEdocGN5NXdjbTl3Y3k1bGJtRmliR1VwZTF4dUlDQWdJQ0FnZEdocGN5NXpaWFJUZEdGMFpTaDdiVzkxYzJWUGRtVnlPaUIwY25WbGZTazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdiMjVEYkdsamF5aGxLWHRjYmlBZ0lDQnBaaWgwYUdsekxuQnliM0J6TG1WdVlXSnNaU2w3WEc0Z0lDQWdJQ0IwYUdsekxuQnliM0J6TG05dVEyeHBZMnNvZEdocGN5NXdjbTl3Y3k1dFpXNTFMbk4wWVhSbExtTnZiblJsZUhRcE8xeHVJQ0FnSUNBZ2RHaHBjeTV3Y205d2N5NXRaVzUxTG1Oc2IzTmxLQ2s3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WdVpHVnlLQ2w3WEc0Z0lDQWdjbVYwZFhKdUlDaGNiaUFnSUNBZ0lEeHNhVnh1SUNBZ0lDQWdJQ0JqYkdGemMwNWhiV1U5ZTJOc1lYTnpUbUZ0WlhNb1hDSnliVTFsYm5WSmRHVnRYQ0lzSUh0eWJVMXZkWE5sVDNabGNqb2dkR2hwY3k1emRHRjBaUzV0YjNWelpVOTJaWElzSUhKdFJHbHpZV0pzWldRNklDRjBhR2x6TG5CeWIzQnpMbVZ1WVdKc1pTd2djbTFUWlhCaGNtRjBiM0k2SUhSb2FYTXVjSEp2Y0hNdWJtRnRaU0E5UFNBbkxTZDlLWDFjYmlBZ0lDQWdJQ0FnYjI1TmIzVnpaVTkyWlhJOWUyVWdQVDRnZEdocGN5NXZiazF2ZFhObFQzWmxjaWhsS1gxY2JpQWdJQ0FnSUNBZ2IyNU5iM1Z6WlU5MWREMTdaU0E5UGlCMGFHbHpMbTl1VFc5MWMyVlBkWFFvWlNsOVhHNGdJQ0FnSUNBZ0lHOXVRMnhwWTJzOWUyVWdQVDRnZEdocGN5NXZia05zYVdOcktHVXBmVnh1SUNBZ0lDQWdJQ0JrWVc1blpYSnZkWE5zZVZObGRFbHVibVZ5U0ZSTlREMTdlMTlmYUhSdGJEb2dkR2hwY3k1d2NtOXdjeTV1WVcxbElEMDlJQ2N0SnlBL0lHNTFiR3dnT2lCMGFHbHpMbkJ5YjNCekxtNWhiV1Y5ZlZ4dUlDQWdJQ0FnUGx4dUlDQWdJQ0FnUEM5c2FUNWNiaUFnSUNBcE8xeHVJQ0I5WEc1OVhHNWNibHh1WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWlBdkwxeHVMeThnTGk5emNtTXZhbk12WTI5dGNHOXVaVzUwY3k5RGIyNTBaWGgwVFdWdWRVbDBaVzB1YW5ONElpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQmZYMWRGUWxCQlEwdGZSVmhVUlZKT1FVeGZUVTlFVlV4Rlh6VmZYenRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlCbGVIUmxjbTVoYkNCN1hDSnliMjkwWENJNlhDSmpiR0Z6YzA1aGJXVnpYQ0lzWENKamIyMXRiMjVxY3pKY0lqcGNJbU5zWVhOemJtRnRaWE5jSWl4Y0ltTnZiVzF2Ym1welhDSTZYQ0pqYkdGemMyNWhiV1Z6WENJc1hDSmhiV1JjSWpwY0ltTnNZWE56Ym1GdFpYTmNJbjFjYmk4dklHMXZaSFZzWlNCcFpDQTlJRFZjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQmZYMWRGUWxCQlEwdGZSVmhVUlZKT1FVeGZUVTlFVlV4Rlh6WmZYenRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlCbGVIUmxjbTVoYkNCN1hDSnliMjkwWENJNlhDSlFjbTl3Vkhsd1pYTmNJaXhjSW1OdmJXMXZibXB6TWx3aU9sd2ljSEp2Y0MxMGVYQmxjMXdpTEZ3aVkyOXRiVzl1YW5OY0lqcGNJbkJ5YjNBdGRIbHdaWE5jSWl4Y0ltRnRaRndpT2x3aWNISnZjQzEwZVhCbGMxd2lmVnh1THk4Z2JXOWtkV3hsSUdsa0lEMGdObHh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlKOVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bnb21vL3JlYWN0LWNvbnRleHQtbWVudS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==